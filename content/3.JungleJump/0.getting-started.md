
# Jungle Jump – Бег и Прыжки в 2D Платформере

В этой главе вы создадите игру в жанре платформера в духе классических произведений, таких как Super Mario Bros. Платформеры являются очень популярным жанром, и понимание их работы может помочь вам создавать различные стили игр. Если вы никогда не пробовали создавать подобные игры ранее, движение игрока в платформерах может оказаться удивительно сложным для реализации, и вы увидите, как узлы CharacterBody2D в Godot предоставляют функции, которые помогут вам в этом процессе.

В этом проекте вы узнаете о следующем:

::list
- Использование узла CharacterBody2D
- Использование узла Camera2D
- Сочетание анимаций и ввода пользователя для создания сложного поведения персонажа
- Проектирование уровней с использованием TileMap
- Создание бесконечно прокручиваемого фона с использованием ParallaxLayer
- Переход между сценами
- Организация вашего проекта и планирование для будущего расширения
::
Вот скриншот завершенной игры:

![ Completed game screenshot](/img/jungle-jump/1.png)


## Настройка проекта

Для создания нового проекта начнем с открытия настроек проекта, чтобы настроить параметры по умолчанию, которые вам понадобятся.

Графические ресурсы для этой игры используют стиль пиксельного искусства, что означает, что они выглядят лучше, когда изображения не сглаживаются, что является настройкой по умолчанию в Godot для фильтрации текстур:

![Фильтрация текстур](/img/jungle-jump/2.png)

Хотя можно установить это для каждого Sprite2D, более удобно указать значение по умолчанию. Нажмите на переключатель Advanced в верхнем правом углу и найдите раздел Rendering/Textures слева. В списке настроек прокрутите вниз и найдите настройку Canvas Textures/Default Texture Filter. Измените ее с Linear на Nearest.

Затем, в разделе Display/Window, измените Stretch/Mode на canvas items и Aspect на expand. Эти настройки позволят пользователю изменять размер игрового окна, сохраняя при этом качество изображения. Когда проект будет завершен, вы сможете увидеть эффекты этой настройки.

Затем можно настроить слои столкновения. Поскольку в этой игре будет несколько различных типов объектов столкновения, которые должны взаимодействовать разными способами, вы будете использовать систему слоев столкновения Godot для их удобной организации. Слои будут более удобными в использовании, если им будут присвоены имена. Перейдите в раздел Layer Names | 2D Physics и назовите первые четыре слоя так (напечатайте непосредственно в поле рядом с номером слоя):
![Фильтрация текстур](/img/jungle-jump/3.png)

Наконец, добавьте следующие действия для управления игроком в раздел Input Map:



| Клавиши  | Действия  |
|----------|-----------|
| right    | D, →      |
| left     | A, ←      |
| jump     | Space     |
| up       | S,  ↑     |
| down     | W, ↓      |
| -------- | --------- |

Убедитесь, что вы используете точные названия для действий ввода, поскольку вы будете ссылаться на них в коде позже.

Это все, что вам нужно настроить в **Project Settings**. Но перед тем как приступить к созданию сцены игрока, вам нужно узнать о другом типе узла физики.

## Введение в кинематические тела
Для платформера требуется гравитация, столкновения, прыжки и другие физические поведения, поэтому вы могли бы подумать, что RigidBody2D был бы идеальным выбором для реализации движения персонажа. На практике вы обнаружите, что более реалистичная физика твердого тела не является желательной для платформенного персонажа. Для игрока реализм менее важен, чем отзывчивое управление и ощущение действия. Таким образом, как разработчик, вам хочется иметь точный контроль над движениями персонажа и его реакцией на столкновения. По этой причине кинематический стиль физики обычно является более предпочтительным выбором для платформенного персонажа.

Узел CharacterBody2D предназначен для реализации физических тел, которые могут быть управляемы напрямую через код. Эти узлы обнаруживают столкновения с другими телами при движении, но не подвержены глобальным свойствам физики, таким как гравитация или трение. Это не означает, что они не могут быть подвержены гравитации и другим силам - просто вы должны рассчитывать эти силы и их воздействие в коде; физический движок не будет автоматически перемещать узел CharacterBody2D.

При перемещении узла CharacterBody2D, так же как и с RigidBody2D, вы не должны устанавливать его свойство position напрямую. Вместо этого вы должны использовать методы move_and_collide() или move_and_slide(), предоставленные узлом. Эти методы перемещают тело вдоль заданного вектора и мгновенно останавливают его, если обнаружено столкновение с другим телом. Затем вам придется решить, как реагировать на столкновение.

Реакция на столкновение
После столкновения вы, возможно, захотите, чтобы тело отскакивало, скользило вдоль стены или изменяло свойства объекта, с которым оно столкнулось. Способ обработки реакции на столкновение зависит от того, какой метод вы используете для перемещения тела:

## move_and_collide()

При использовании этого метода функция возвращает объект KinematicCollision2D при столкновении. Этот объект содержит информацию о столкновении и теле, с которым произошло столкновение. Вы можете использовать эту информацию для определения реакции. Обратите внимание, что функция возвращает null, когда перемещение завершается успешно без столкновения.

Например, если вы хотите, чтобы тело отскакивало от столкнувшегося объекта, вы можете использовать следующий скрипт:

```gdscript
extends CharacterBody2D

var velocity = Vector2(250, 250)

func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.bounce(collision.get_normal())
```

## move_and_slide()
Скольжение - очень распространенный вариант реакции на столкновение. Представьте себе игрока, движущегося вдоль стены в игре сверху вниз или бегущего по земле в платформере. Возможно реализовать реакцию самостоятельно после использования move_and_collide(), но move_and_slide() предоставляет удобный способ реализации скользящего движения. При использовании этого метода тело автоматически будет скользить вдоль поверхности столкновения. Кроме того, скользящие столкновения позволят вам определить ориентацию поверхности с использованием методов, таких как is_on_floor().

Поскольку в этом проекте вам нужно будет разрешить игровому персонажу двигаться по земле и вдоль наклонов вверх и вниз, move_and_slide() будет играть важную роль в движении вашего персонажа.

Теперь, когда у вас есть представление о том, что такое кинематические тела, вы будете использовать одно из них для создания персонажа для этой игры.


## Создание сцены игрока
Узел Godot, реализующий кинематическое движение и столкновение, называется CharacterBody2D. Откройте новую сцену и добавьте узел CharacterBody2D с именем Player в качестве корневого и сохраните сцену. Не забудьте нажать кнопку "Group Selected Node(s)". При сохранении сцены Player вы также должны создать новую папку для её содержимого. Это поможет поддерживать порядок в папке проекта по мере добавления новых сцен и скриптов.

Ознакомьтесь со свойствами CharacterBody2D в инспекторе. Обратите внимание на значения по умолчанию для режима движения (Motion Mode) и направления вверх (Up Direction). Режим "Grounded" означает, что тело будет рассматривать одно направление столкновения как "пол", противоположную стену как "потолок", а любые другие как "стены" – какое именно определяется направлением вверх (Up Direction).

Как и в предыдущих проектах, вы включите все узлы, необходимые для функционирования персонажа-игрока, в сцену Player. Для этой игры это означает обработку столкновений с различными игровыми объектами, такими как платформы, враги и предметы для сбора; отображение анимаций для действий, таких как бег или прыжок; и прикрепление камеры для слежения за игроком по уровню.

Сценарии для различных анимаций могут быстро стать неуправляемыми, поэтому вам нужно будет использовать конечный автомат (FSM) для управления и отслеживания состояний игрока. Ознакомьтесь с главой 3, чтобы вспомнить, как можно создать упрощенный FSM. Вы будете следовать подобному паттерну и для этого проекта.

## Слои столкновений и маски
Свойство Collision/Layer тела определяет на каком (на каких) слое(ах) в физическом мире находится тело. Игроку необходимо быть присвоенным слою "player" (который вы назвали в настройках проекта). Точно так же, свойство Collision/Mask определяет, с какими слоями тело может "видеть" или взаимодействовать. Если объект находится на слое, отсутствующем в маске игрока, то игрок не взаимодействует с ним вообще.
Установите слой игрока на "player" и маску на "environment", "enemies" и "items". Нажмите на три точки справа, чтобы открыть список флажков, отображающих имена, которые вы присвоили слоям:

![Свойство Collision/Layer](/img/jungle-jump/4.jpg)
Это гарантирует, что игрок находится на слое "player", что позволяет настраивать другие объекты на обнаружение или игнорирование игрока. Установка значения маски для всех трех слоев означает, что игрок сможет взаимодействовать с объектами на любом из этих слоев.

## О AnimationPlayer
Ранее в этой книге вы использовали AnimatedSprite2D для отображения анимаций на основе кадров ваших персонажей. Это отличный инструмент, но он полезен только для анимации визуальной текстуры узла. Что если вы также хотите анимировать любые другие свойства узла?

В этом случае пригодится AnimationPlayer. Этот узел является очень мощным инструментом для создания анимаций, которые могут влиять на несколько узлов одновременно; вы можете изменять любые из их свойств.

## Animations
Для настройки анимаций персонажа выполните следующие шаги:

Добавьте узел Sprite2D к узлу Player. Перетащите файл res://assets/player_sheet.png из панели FileSystem и отпустите его в свойство Texture. Анимация игрока будет сохранена в виде спрайт-листа:

![Спрайт-лист](/img/jungle-jump/B19289_04_05.jpg)

Вы будете использовать AnimationPlayer для управления анимациями. В свойствах анимации узла Sprite2D установите HFrames равным 19. Затем установите Frame равным 7, чтобы увидеть стоящего игрока. Наконец, поднимите Sprite2D вверх, пока его ноги не будут стоять на земле, установив свойство Position равным (0, -16). Это упростит написание кода для взаимодействия с игроком, так как вы будете знать, что свойство позиции игрока представляет собой местоположение его ног.

Добавьте узел AnimationPlayer в сцену. Вы будете использовать этот узел для изменения свойства Frame узла Sprite2D на соответствующие значения для каждой анимации. Прежде чем начать, ознакомьтесь с различными частями панели анимации:

![Панель анимации](/img/jungle-jump/B19289_04_06.jpg)


Нажмите кнопку Animation и выберите New. Назовите новую анимацию idle.
Установите ее продолжительность равной 0,4 секунды. Нажмите на иконку Loop, чтобы сделать анимацию цикличной, и установите режим обновления трека в Continuous.
Измените свойство Frame узла Sprite2D на 7, что является первым кадром анимации покоя, и щелкните на иконку ключевого кадра рядом со свойством, чтобы добавить трек анимации с новым ключевым кадром:

![Добавление ключевого кадра](/img/jungle-jump/B19289_04_07.jpg)

Переместите ползунок воспроизведения на 0,3 (вы можете отрегулировать регулятор масштаба в правом нижнем углу, чтобы упростить поиск). Добавьте ключевой кадр для кадра 10, который является последним кадром покоя.
Нажмите кнопку Play, чтобы посмотреть анимацию. Если она выглядит неправильно, вернитесь к предыдущему пункту и убедитесь, что вы точно следовали всем шагам, особенно тому факту, что начинаете с кадра 7 и заканчиваете на кадре 10.
Теперь повторите этот процесс для других анимаций. Смотрите таблицу ниже для списка их настроек:

| Имя       | Продолжительность | Кадры        | Цикличность |
|-----------|-------------------|--------------|-------------|
| idle      | 0.4 сек           | 7 → 10       | Вкл         |
| run       | 0.5 сек           | 13 → 18      | Вкл         |
| hurt      | 0.2 сек           | 5 → 6        | Вкл         |
| jump_up   | 0.1 сек           | 11           | Выкл        |
| jump_down | 0.1 сек           | 12           | Выкл        |

Также есть анимации для приседания и лазания в спрайт-листе, но вы можете добавить их позже, когда базовое движение будет завершено.

## Collision shape

Как и с другими телами, CharacterBody2D требуется форма, назначенная для определения его границ столкновения. Добавьте узел CollisionShape2D и создайте внутри него новую форму RectangleShape2D. При размерировании формы вы хотите, чтобы она достигала до нижней части изображения (ноги игрока), но была немного уже, чем изображение самого игрока. В целом, сделать форму немного меньше, чем изображение, приведет к лучшему ощущению во время игры, избегая впечатления о столкновении с чем-то, что, казалось бы, не должно вызывать столкновение.

Вам также нужно сместить форму немного, чтобы она подходила. Установка свойства Position узла CollisionShape2D в (0, -10) хорошо подходит. Когда вы закончите, это должно выглядеть примерно так:

![Форма столкновения игрока](/img/jungle-jump/B19289_04_08.jpg)

## Несколько форм

В некоторых случаях, в зависимости от сложности вашего персонажа и его взаимодействий с другими объектами, вы можете захотеть добавить несколько форм к одному и тому же объекту. Вы можете иметь одну форму у ног игрока для обнаружения столкновений с землей, другую на его теле для обнаружения урона и еще одну, покрывающую переднюю часть игрока для обнаружения столкновений со стенами.

## Завершение сцены игрока
Добавьте узел Camera2D в сцену Player. Этот узел будет центрировать игровое окно на игроке по мере его перемещения по уровню. Вы также можете использовать его для увеличения изображения игрока, так как пиксель-арт относительно мал по сравнению с размером игрового окна. Помните, что, поскольку вы установили опцию фильтрации в Настройках проекта, текстура игрока останется пиксельной и блочной при увеличении масштаба.

Чтобы включить камеру, установите свойство Enabled в On, а затем установите Zoom в (2.5, 2.5). Значения меньше 1 уменьшают масштаб камеры, а большие значения увеличивают его.

Вы увидите розовато-пурпурный прямоугольник вокруг игрока. Это экранная область камеры и показывает, что увидит камера. Вы можете регулировать свойство Zoom, чтобы увеличивать или уменьшать ее размер и видеть больше или меньше мира вокруг игрока.

## Состояния игрока
У игрового персонажа есть разнообразное поведение, такое как прыжки, бег и приседания. Программирование таких поведений может стать очень сложным и трудным в управлении. Один из способов решения этой проблемы - использовать булевы переменные (например, is_jumping или is_running), но это может привести к возможно запутанным состояниям (что, если и is_crouching, и is_jumping одновременно true?) и быстро привести к _spaghetti_ коду.

Лучшим решением этой проблемы является использование конечного автомата для управления текущим состоянием игрока и управления переходом к другим состояниям. Этот концепт был представлен в главе 3, и вы будете расширять его в этом проекте.

![Вот диаграмма состояний игрока](/img/jungle-jump/B19289_04_09.jpg)

Как видно, диаграммы состояний могут стать достаточно сложными, даже с относительно небольшим количеством состояний.

## Другие состояния

Обратите внимание, что, хотя в спрайт-листе содержатся анимации для них, состояния CROUCH и CLIMB здесь не включены. Это сделано для упрощения управления количеством состояний в начале проекта. Позднее у вас будет возможность добавить их.

## Скрипт игрока
Присоедините новый скрипт к узлу Player. Обратите внимание, что в диалоге отображается свойство Template с примером кода Basic Movement для этого типа узла в Godot. Отключите флажок Template - вам не понадобится этот пример кода для этого проекта.

Добавьте следующий код для начала настройки конечного автомата игрока. Как и в игре Space Rocks, вы можете использовать тип enum для определения допустимых состояний для системы. Когда вы захотите изменить состояние игрока, вы можете вызвать change_state():

```gdscript
extends CharacterBody2D
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            hide()
```

На данный момент скрипт только изменяет воспроизводимую анимацию, но позже вы добавите больше функциональности состояния.

## Движение игрока
Игроку нужны три управления: влево, вправо и прыжок. Сравнение текущего состояния с тем, какие клавиши нажаты, вызовет изменение состояния, если переход разрешен правилами диаграммы состояний. Добавьте функцию get_input() для обработки ввода и определения результата. Каждое условие if представляет один из переходов в диаграмме состояний:

```gdscript
func get_input():
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")

    # movement occurs in all states
    velocity.x = 0

    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false

    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true

    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed

    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)

    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)

    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)

```

Обратите внимание, что проверка прыжка использует is_action_just_pressed() вместо is_action_pressed(). В то время как последнее возвращает true, пока клавиша удерживается, первое будет true только в том кадре, в котором клавиша была нажата. Это означает, что игрок должен нажимать клавишу прыжка каждый раз, когда они хотят прыгнуть.

Вызывайте эту функцию из _physics_process(), добавляйте гравитацию к скорости игрока и вызывайте метод move_and_slide() для перемещения:

```gdscript
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()
```

Помните, что поскольку свойство Up Direction установлено на (0, -1), любое столкновение под ногами игрока будет считаться "полом", и is_on_floor() будет установлено в true методом move_and_slide(). Вы можете использовать это для определения окончания прыжка, добавив это сразу после move_and_slide():

```gdscript
if state == JUMP and is_on_floor():
    change_state(IDLE)
```

Прыжок будет выглядеть лучше, если анимация переключится с jump_up на jump_down при падении:

```gdscript
if state == JUMP and velocity.y > 0:
    $AnimationPlayer.play("jump_down")
```

Позже, после завершения уровня, игроку будет передано местоположение появления. Чтобы обработать это, добавьте эту функцию в скрипт:

```gdscript
func reset(_position):
    position = _position
    show()
    change_state(IDLE)
```

Таким образом, вы завершили добавление движения, и для каждой ситуации должна воспроизводиться правильная анимация. Это было бы хорошей точкой остановки и проверки игрока, чтобы убедиться, что все работает. Однако вы не можете просто запустить сцену, потому что игрок начнет падать без поверхности для стояния.


## Тестирование движения
Создайте новую сцену и добавьте объект Node с именем Main (позднее это станет вашей основной сценой). Добавьте экземпляр Player, затем добавьте узел StaticBody2D с прямоугольной формой столкновения. Растяните форму столкновения горизонтально так, чтобы она была достаточно широкой для движения туда и обратно, и разместите ее под персонажем:

![Тестовая сцена с платформой](/img/jungle-jump/B19289_04_10.jpg)

Поскольку у него нет узла Sprite2D, статическое тело будет невидимым при запуске игры. В меню выберите Debug > Visible Collision Shapes. Это полезная настройка отладки, которая будет рисовать формы столкновения во время выполнения игры. Вы можете включить ее в любое время, когда вам нужно тестировать или устранять проблемы с столкновениями.

Нажмите Play Scene; вы должны увидеть, что игрок перестает падать и начинает воспроизводить анимацию покоя, когда он касается статического тела.

Прежде чем перейти дальше, убедитесь, что все движения и анимации работают правильно. Бегите и прыгайте во всех направлениях и проверьте, что правильные анимации воспроизводятся, когда состояние изменяется. Если вы обнаружите какие-либо проблемы, просмотрите предыдущие разделы и убедитесь, что вы ничего не упустили.

## Здоровье игрока
В конечном итоге игрок столкнется с опасностью, поэтому вы должны добавить систему урона. Игрок начнет с тремя сердцами и потеряет одно каждый раз, когда ему наносят урон.

Добавьте следующее в верхнюю часть скрипта (сразу после строки extends):

```gdscript
signal life_changed
signal died
var life = 3 setget set_life
func set_life(value):
    life = value
    life_changed.emit(life)
    if life <= 0:
        change_state(DEAD)
```

Вы будете излучать сигнал life_changed каждый раз, когда значение life изменяется, уведомляя дисплей о необходимости обновления. died будет излучен, когда life достигнет 0.

Добавьте `life = 3` в функцию reset().

Есть два возможных способа, которыми игрок может получить урон: столкновение с объектом шипа в окружении или удар врага. В любом случае может быть вызвана следующая функция:


```gdscript
func hurt():
    if state != HURT:
        change_state(HURT)
```

Этот код относится к дружелюбному отношению к игроку: если он уже ранен, его нельзя ранить снова (по крайней мере, в течение короткого времени, пока анимация урона не завершится). Без этого легко застрять в цикле получения урона, что приведет к быстрой смерти.

Есть несколько вещей, которые нужно сделать, когда состояние изменяется на HURT в функции change_state(), которую вы ранее создали:

```gdscript
HURT:
    $AnimationPlayer.play("hurt")
    velocity.y = -200
    velocity.x = -100 * sign(velocity.x)
    life -= 1
    await get_tree().create_timer(0.5).timeout
    change_state(IDLE)
DEAD:
    died.emit()
    hide()
```

Когда игрок получает урон, не только он теряет одну жизнь, но и отбрасывается вверх и в сторону от повреждающего объекта. Через некоторое время состояние возвращается к IDLE.

Кроме того, ввод должен быть отключен во время состояния HURT. Добавьте это в начало функции get_input():

```gdscript
if state == HURT:
    return
```

Теперь игрок готов получать урон после того, как остальная часть игры будет настроена. Далее вы создадите объекты, которые игрок будет собирать в игре.

## Collectible items
Прежде чем приступить к созданию уровня, вам нужно создать несколько предметов, которые игрок сможет собирать, поскольку они также будут частью уровня. В папке assets/sprites содержатся спрайт-листы для двух типов собираемых предметов: вишен и самоцветов.

Вместо того чтобы создавать отдельную сцену для каждого типа предмета, вы можете использовать одну сцену и заменять свойство текстуры в скрипте. Оба объекта имеют одинаковое поведение: анимация на месте и исчезновение при сборе игроком. Вы также можете добавить эффект плавного перехода для сбора (см. главу 2).

## Настройка сцены
Начните новую сцену с Area2D и назовите ее Item. Сохраните сцену в новой папке items.

Область - хороший выбор для этих объектов, потому что вы хотите определить, когда с ними контактирует игрок, но вам не нужен ответ на столкновение от них. В инспекторе установите Collision/Layer на collectibles (слой 4) и Collision/Mask на player (слои 2). Это обеспечит возможность собирать их только игроку, в то время как враги будут проходить сквозь них.

Добавьте три дочерних узла: Sprite2D, CollisionShape2D и AnimationPlayer. Перетащите res://assets/sprites/cherry.png в текстуру узла Sprite2D. Установите HFrames в 5. Затем добавьте форму круга к CollisionShape2D и подгоните ее размер:

![Настройка сцены](/img/jungle-jump/B19289_04_11.jpg)


## Выбор размера столкновения

Как общее правило, вы должны размерировать формы столкновения так, чтобы они были выгодны для игрока. Это означает, что хитбоксы врагов должны быть немного меньше изображения, в то время как хитбоксы полезных предметов должны быть немного увеличены. Это снижает разочарование игрока и обеспечивает лучший игровой опыт.

Добавьте новую анимацию к AnimationPlayer (вам нужна только одна, поэтому вы можете назвать ее как угодно). Установите Length на 1,6 секунды, Snap на 0,2 секунды и Looping в положение on. Нажмите кнопку Autoplay on Load, чтобы анимация запускалась автоматически.

Установите свойство Frame узла Sprite2D на 0 и нажмите кнопку key, чтобы создать трек. Этот спрайт-лист содержит только половину анимации, поэтому анимация должна воспроизводить кадры в следующем порядке:

0 -> 1 -> 2 -> 3 -> 4 -> 3 -> 2 -> 1

Переместите ползунок к моменту времени 0,8 и установите ключевой кадр Frame на 4. Затем, установите ключевой кадр Frame 1 в момент времени 1,4. Установите Update Mode в Continuous и нажмите кнопку Play. У вас будет красиво анимированная вишня! Обратите внимание, что вы также можете перетащить изображение res://assets/sprites/coin.png в Texture, и это будет работать так же, поскольку у него такое же количество кадров. Это облегчит создание как вишен, так и самоцветов в вашей игре.


## Сценарий для собираемых предметов
Сценарий Item должен выполнять две задачи:

1. Устанавливать начальные условия (какую текстуру и позицию использовать).
2. Обнаруживать перекрытие с игроком.

Для первой части добавьте следующий код в ваш новый сценарий предмета:

```gd
extends Area2D
signal picked_up
var textures = {
    "cherry": "res://assets/sprites/cherry.png",
    "gem": "res://assets/sprites/gem.png"
}

func init(type, _position):
    $Sprite2D.texture = load(textures[type])
    position = _position
```

Вы будете вызывать сигнал picked_up, когда игрок соберет предмет. В словаре textures вы найдете список типов предметов и соответствующих файлов изображений. Обратите внимание, что вы можете быстро вставить эти пути в сценарий, перетащив файл из FileSystem и бросив его в редактор сценария.

Затем функция init() устанавливает текстуру и позицию. Сценарий вашего уровня будет использовать это для создания всех предметов, которые вы поместили на карту вашего уровня.

Наконец, подключите сигнал body_entered Item и добавьте этот код:

```gd
func _on_item_body_entered(body):
    picked_up.emit()
    queue_free()
```

Этот сигнал позволит основному сценарию игры реагировать на подбор предмета. Он может увеличивать счет, увеличивать здоровье игрока или применять любой другой эффект, который вы хотите применить к предмету.

Вы, возможно, заметили, что эти собираемые предметы устроены очень похоже на монеты из Coin Dash. Области очень полезны для любого типа предметов, где вам нужно знать, когда их касаются. В следующем разделе вы начнете создавать сцену уровня, чтобы размещать эти собираемые предметы.

## Дизайн уровня
Для большинства из вас этот раздел займет большую часть времени. Как только вы начнете проектировать уровень, вы обнаружите, что это весело – расставлять все элементы, создавать сложные прыжки, секретные пути и опасные встречи.

Сначала вы создадите общий сценарий Level, содержащий все узлы и код, общий для всех уровней. Затем вы можете создать любое количество сценариев Level, которые наследуются от этого основного уровня.

## Использование TileMap
Создайте новую сцену и добавьте узел Node2D с именем LevelBase. Сохраните сцену в новой папке с именем levels. Здесь вы будете сохранять все уровни, которые создадите, и все они будут наследовать функционал от этой сцены level_base.tscn. У них будет одна и та же иерархия узлов, только расположение будет разным.

TileMap - это распространенное средство для проектирования игровых окружений с использованием сетки тайлов. Они позволяют вам рисовать макет уровня, нанося тайлы на сетку, вместо того чтобы размещать много отдельных узлов поочередно. Они также более эффективны, потому что они объединяют все индивидуальные текстуры тайлов и формы столкновения в единый игровой объект.

Добавьте узел TileMap; внизу окна редактора появится новая панель TileMap. Обратите внимание, что там написано: "The edited TileMap has no TileSet resource" ("Редактируемый TileMap не имеет ресурса TileSet").

## О TileSet
Чтобы рисовать карту с использованием TileMap, ей должен быть назначен TileSet. Этот TileSet содержит все индивидуальные текстуры тайлов, а также любые формы столкновения, которые они могут иметь.

В зависимости от того, сколько у вас может быть тайлов, создание TileSet может потребовать много времени, особенно впервые. По этой причине в папке assets включены некоторые заранее сгенерированные тайлсеты. Вы можете использовать их, но прочитайте следующий раздел. В нем содержится полезная информация, чтобы вы поняли, как работает TileSet. Если вы предпочтете использовать предоставленные тайлсеты, перейдите к разделу Использование предоставленных TileSet.

## Создание TileSet
В Godot TileSet - это тип Ресурса. Примеры других ресурсов включают Текстуру, Анимацию и RectangleShape2D. Они не являются узлами; вместо этого они являются контейнерами, содержащими определенный тип данных и обычно сохраняются в файлах .tres.


Вот шаги для создания контейнера TileSet:

1. Нажмите "New TileSet" в области Tile Set TileMap. Теперь у вас появится доступная панель TileSet, которую вы можете выбрать внизу окна редактора. Вы можете нажать две стрелки вверх, чтобы сделать панель на весь экран редактора. Нажмите ее еще раз, чтобы уменьшить панель.

2. Вкладка Tiles слева в панели TileSet - это место, где вы можете поместить текстуры, которые вы хотите нарезать на тайлы. Перетащите res://assets/environment/tileset.png в это поле. Всплывет окно с запросом о том, хотите ли вы автоматически создать тайлы. Выберите "Yes". Вы увидите, что вокруг всех тайлов размером 16x16 пикселей на изображении нарисованы рамки:

   ![Добавление TileSet](/img/jungle-jump/B19289_04_13.jpg)

3. Попробуйте выбрать панель TileMap внизу, а затем выберите изображение блока с травой в верхнем левом углу тайлов. Затем щелкните в окне редактора, чтобы нарисовать несколько тайлов, нажимая левой кнопкой мыши. Вы можете щелкнуть правой кнопкой мыши по тайлу, чтобы его очистить:

   ![Рисование с использованием TileMaps](/img/jungle-jump/B19289_04_14.jpg)

4. Если все, что вам нужно, - это нарисовать фон, вы закончили. Однако вам также нужно добавить столкновения к этим тайлам, чтобы игрок мог стоять на них.

5. Откройте снова панель TileSet и в разделе Inspector найдите свойство PhysicsLayers и нажмите "Add Element":

   ![Добавление физического слоя в TileSet](/img/jungle-jump/B19289_04_15.jpg)

6. Поскольку эти тайлы будут в слое окружающей среды, вам не нужно изменять настройки слоя/маски.

7. Нажмите "Paint" в панели TileSet и в разделе "Paint Properties" выберите Physics Layer 0:

   ![Добавление столкновений к тайлам](/img/jungle-jump/B19289_04_16.jpg)

8. Начните щелкать по тайлам, чтобы добавить к ним стандартную квадратную форму столкновения. Если вы хотите отредактировать форму столкновения тайла, вы можете сделать это - щелкните по тайлу снова, чтобы применить изменения. Если вы застряли с формой, которая вам не нравится, нажмите три точки и выберите "Reset to default tile shape".

Вы также можете перетащить изображение props.png в список текстур для добавления декоративных элементов в ваш уровень.



Использование предоставленных наборов тайлов
В загруженных для этого проекта ресурсах уже предварительно настроенные наборы тайлов. Их три, и их нужно добавить к трем разным узлам TileMap:

- World – tiles_world.tres: Тайлы земли и платформ
- Items – tiles_items.tres: Маркеры для появления предметов
- Danger – tiles_spikes.tres: Предметы, которые наносят урон при столкновении
  Создайте TileMap-узлы Items и Danger и добавьте соответствующий набор тайлов к свойству Tile Set.

Добавьте экземпляр сцены Player и узел Marker2D с именем SpawnPoint. Вы можете использовать этот узел для обозначения места, где вы хотите, чтобы игрок начинал уровень.

Присоедините скрипт к узлу Level:

```gdscript
extends Node2D

func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
```

Позже вы будете сканировать карту Items, чтобы создавать предметы в указанных местах. Этот слой карты не должен быть виден, поэтому его можно скрыть в сцене. Тем не менее, легко забыть об этом, поэтому _ready() гарантирует, что он не будет виден во время игры.

Проектирование первого уровня
Теперь вы готовы начать рисовать уровень! Выберите Scene > New Inherited Scene и выберите level_base.tscn. Назовите корневой узел Level01 и сохраните его (в папку levels). Обратите внимание, что дочерние узлы окрашены в желтый цвет, что указывает на то, что они унаследованы от исходного уровня level_base.tscn. Если вы внесете изменения в этот исходный уровень, эти изменения также будут видны в этом уровне.

Начните с карты World и будьте творческими. Вам нравятся многочисленные прыжки, извилистые туннели для исследования? Длинные беги или осторожные восхождения вверх?

Прежде чем слишком углубляться в проектирование уровня, убедитесь, что вы экспериментируете с длиной прыжка. Вы можете изменить свойства движения игрока, такие как jump_speed, run_speed и gravity, чтобы изменить высоту и дальность прыжка. Настройте несколько разных размеров промежутков и запустите сцену, чтобы их опробовать. Не забудьте переместить узел SpawnPoint в то место, где вы хотите, чтобы игрок начал. Как вы настраиваете свойства движения игрока, сильно влияет на то, как должен быть оформлен ваш уровень. Удостоверьтесь, что вы довольны своими настройками, прежде чем тратить слишком много времени на полное проектирование..


Как только у вас будет готова карта World, используйте карту Items, чтобы отметить места, где вы хотели бы разместить вишни и драгоценные камни. Тайлы, отмечающие места появления, отрисованы с маджентовым фоном, чтобы выделяться. Помните, что они будут заменены во время выполнения, и сами тайлы не будут видны.

Как только ваш уровень будет готов, вы можете ограничить горизонтальную прокрутку камеры игрока, чтобы она соответствовала размеру карты (плюс небольшой буфер с каждого конца). Добавьте этот код в level_base.gd:

```gdscript
func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
    set_camera_limits()

func set_camera_limits():
    var map_size = $World.get_used_rect()
    var cell_size = $World.tile_set.tile_size
    $Player/Camera2D.limit_left = (map_size.position.x - 5) * cell_size.x
    $Player/Camera2D.limit_right = (map_size.end.x + 5) * cell_size.x
```

Сценарию также нужно просканировать карту Items и искать маркеры предметов. Сбор предметов добавит очки игроку, поэтому вы также можете добавить переменную для их отслеживания:

```gdscript
signal score_changed
var item_scene = load("res://items/item.tscn")
var score = 0: set = set_score

func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        var item = item_scene.instance()
        add_child(item)
        item.init(type, $Items.map_to_local(cell))
        item.picked_up.connect(self._on_item_picked_up)

func _on_item_picked_up():
    score += 1

func set_score(value):
    score = value
    score_changed.emit(score)
```

Функция spawn_items() использует get_used_cells(), чтобы получить список ячеек в TileMap, которые не являются пустыми. Эти ячейки находятся в _координатах карты_, а не в пиксельных координатах. Позднее, когда вы создадите предмет, вы сможете использовать map_to_local(), чтобы преобразовать значения.

Маркерные тайлы имеют слой пользовательских данных, прикрепленный к ним (аналогично слою физики, который вы добавили к тайлам мира), который указывает, какого они типа: gem (драгоценный камень) или cherry (вишня). Это затем используется для определения новому экземпляру, каким типом предмета он должен быть.

Переменная score предназначена для отслеживания количества предметов, собранных игроком. Вы можете использовать это для завершения уровня, предоставления бонусов и так далее.

Добавьте spawn_items() в _ready() и попробуйте запустить уровень. Вы должны увидеть, что гемы и вишни появляются в тех местах, где вы их разместили. Также проверьте, что они исчезают, когда вы их собираете.

## Слой опасности (Danger)
Слой опасности (Danger) на карте предназначен для размещения объектов в виде шипов, которые нанесут урон игроку при соприкосновении. Любой тайл на этой TileMap вызовет урон игроку! Попробуйте разместить несколько из них там, где вы сможете легко их протестировать.

Во вкладке Node добавьте TileMap опасности в группу с названием "danger", чтобы вы могли легко идентифицировать ее при столкновении. Это также позволит вам создавать другие опасные объекты, добавляя их в ту же группу.

## О коллизиях со скольжением

Когда узел CharacterBody2D перемещается с помощью move_and_slide(), он может столкнуться с более чем одним объектом в том же движении кадра. Например, при столкновении с углом тело может одновременно удариться о стену и пол. Вы можете использовать функцию get_slide_collision_count() для определения количества коллизий; затем вы можете получить информацию о каждой коллизии с помощью get_slide_collision().

В случае с игроком вы хотите обнаружить столкновение с TileMap опасности. Вы можете сделать это сразу после использования move_and_slide() в файле player.gd:

```gdscript
if state == HURT:
    return
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()
```

Обратите внимание, что перед проверкой столкновения с группой опасности вы можете сначала проверить, находится ли игрок уже в состоянии HURT. Если это так, вы можете пропустить проверку того, сталкивается ли он с опасным объектом.

Цикл for перебирает количество столкновений, заданное get_slide_collision_count(), чтобы проверить каждое из них на наличие объекта в группе опасности.

Воспроизведите вашу сцену и попробуйте столкнуться с одним из шипов. Вы должны увидеть, что игрок переходит в состояние HURT (воспроизводится анимация) на короткое время, прежде чем вернуться к состоянию IDLE. После трех ударов игрок войдет в состояние DEAD, которое в настоящее время просто скрывает игрока.

В папке res://assets/environment/ есть два фоновых изображения: back.png и middle.png для дальнего и ближнего фона соответственно. Разместив эти изображения за тайлмапом и прокручив их с разной скоростью относительно камеры, вы можете создать привлекательную иллюзию глубины в фоне:
::list
 - Добавьте узел ParallaxBackground к сцене LevelBase (чтобы он присутствовал во всех унаследованных уровнях). Этот узел взаимодействует с камерой, создавая эффект прокрутки. Перетащите этот узел в верхнюю часть дерева сцены, чтобы он рисовался за остальными узлами. Затем добавьте узел ParallaxLayer в качестве его дочернего элемента. У ParallaxBackground может быть любое количество дочерних узлов ParallaxLayer, что позволяет создавать несколько независимых прокручиваемых слоев.
 - Добавьте узел Sprite2D в качестве дочернего элемента ParallaxLayer и перетащите изображение back.png в его область Texture. Убедитесь, что свойство Offset/Centered не отмечено, чтобы изображение располагалось относительно начала экрана. Также увеличьте масштаб узла Sprite2D, установив Scale равным (1.5, 1.5).
 - На ParallaxLayer установите Motion/Scale в (0.2, 1) (вам придется щелкнуть значок ссылки, чтобы разрешить установку значений x и y отдельно). Эта настройка контролирует скорость прокрутки фона относительно движения камеры. Установив ее менее 1, изображение будет перемещаться незначительно при движении игрока влево и вправо.
 - Убедитесь, что изображение повторяется, если ваш уровень шире размера изображения, поэтому установите Motion/Mirroring в (576, 0). Это точно ширина изображения (384 умножить на 1.5), поэтому изображение будет повторяться, когда оно переместится на эту величину в пикселях.
 - Обратите внимание, что это изображение задумано для уровней, которые шире, чем высоки. Если вы прыгнете слишком высоко, вы увидите верхнюю часть изображения. Вы можете исправить это, установив верхний предел камеры. Если вы не переместили позицию фона, его верхний левый угол все равно будет в точке (0, 0), поэтому вы можете установить верхний предел камеры в 0. Если вы переместили ParallaxLayer или его узел Sprite2D, вы можете найти правильное значение, посмотрев на значение y позиции узла.
 - Попробуйте запустить уровень и перемещаться влево и вправо. Вы должны увидеть, что фон двигается незначительно по сравнению с тем, как далеко вы бежите.
 - Добавьте еще один узел ParallaxLayer (также в качестве дочернего для ParallaxBackground) и добавьте ему дочерний узел Sprite2D. На этот раз используйте изображение middle.png. Это изображение значительно уже, чем изображение неба, поэтому вам нужно настроить некоторые параметры для правильного повторения. Это связано с тем, что ParallaxBackground должен иметь изображения, по крайней мере, такие же большие, как область видимости.
 - Найдите свойство Texture/Repeat у узла Sprite2D в разделе CanvasItem и установите его значение на Mirror. Затем разверните раздел Region и убедитесь, что включена опция Enabled. В разделе Rect установите ширину и высоту равными (880, 368). 880 - это ширина изображения (176), умноженная на 5, поэтому теперь вы увидите пять повторений изображения, каждое зеркальное предыдущему.
 - Переместите узел Sprite2D так, чтобы изображение перекрывалось нижней половиной изображения океана/неба: !()[/img/jungle-jump/B19289_04_17.jpg] 
 - Установите параметр Motion/Scale второго узла ParallaxLayer на (0.6, 1), а параметр Motion/Mirroring на (880, 0). Использование более высокого коэффициента масштабирования означает, что этот слой будет прокручиваться немного быстрее слоя облаков за ним. Воспроизведите сцену, чтобы протестировать эффект.
::

Дерево узлов вашей сцены уровня теперь должно выглядеть следующим образом:
![Фильтрация текстур](/img/jungle-jump/B19289_04_18.jpg)

Ваша сцена уровня теперь имеет все необходимые элементы для создания дизайна уровня. Хотите, чтобы ваш игрок должен был делать очень точные прыжки (уровень паркура), пробегать через серию извилистых проходов, пытаясь найти все предметы (уровень лабиринта) или какое-то сочетание обоих? Это ваш шанс попробовать некоторые креативные идеи, но убедитесь, что вы оставляете место для следующего объекта, который вы создадите: врагов.

## Добавление врагов
Есть много различных поведений, которые можно добавить для врага. В этой игре враг будет идти по платформе в прямой линии и изменять направление при столкновении с препятствием.

## Настройка сцены
Как и раньше, вам нужно создать новую сцену для представления врага:


::list
  -  Начните с узла CharacterBody2D с именем Enemy и добавьте три дочерних узла: Sprite2D, CollisionShape2D и AnimationPlayer.
  -  Сохраните сцену в папку с именем enemies. Если вы решите добавить больше типов врагов в игру, вы можете сохранить их все здесь.
  -  Установите слой столкновения тела врага на enemies, а Маску на environment, player и enemies. Как и в случае с игроком, это определяет с какими типами объектов враг будет сталкиваться.
  -  Также полезно группировать врагов вместе, поэтому перейдите во вкладку Node и добавьте тело в группу с именем enemies.
  -  Добавьте res://assets/sprites/opossum.png в текстуру и установите Animation/Hframes в 6.
  -  Добавьте прямоугольную форму столкновения, которая покрывает большую часть (но не всю) изображения, убедившись, что нижняя часть формы столкновения выровнена с нижней частью ног опоссума:![опоссум](/img/jungle-jump/B19289_04_19.jpg)
  - Добавьте новую анимацию в AnimationPlayer с именем walk. Установите Длительность на 0,6 секунды и включите Петля и Автовоспроизведение при загрузке. 
  - У анимации walk должно быть две дорожки: одна, которая устанавливает свойство Texture узла Sprite2D, и другая, которая изменяет свойство Frame. Нажмите на значок ключа рядом с Texture, чтобы добавить первую дорожку, затем добавьте ключевые кадры для Frame 0 в момент времени 0 и Frame 5 в момент времени 0,5. Не забудьте изменить Режим обновления на Continue.
::

По завершении ваша анимация должна выглядеть так:

![Aнимация](/img/jungle-jump/B19289_04_20.jpg)


# Программируем врагов

На данный момент перемещение узла CharacterBody2D должно быть вам знакомо. Посмотрите на этот скрипт и попробуйте понять, что он делает, прежде чем прочитать предоставленное объяснение.
```gdscript
extends CharacterBody2D
@export var speed = 50
@export var gravity = 900
var facing = 1
func _physics_process(delta):
    velocity.y += gravity * delta
    velocity.x = facing * speed
    $Sprite2D.flip_h = velocity.x > 0
    move_and_slide()
    for i in get_slide_collision_count():
        var collision = get_slide_collision(i)
        if collision.get_collider().name == "Player":
            collision.get_collider().hurt()
        if collision.get_normal().x != 0:
            facing = sign(collision.get_normal().x)
            velocity.y = -100
    if position.y > 10000:
        queue_free()
```

В этом скрипте переменная facing отслеживает движение в направлении x, либо 1, либо -1. Как и с игроком, после перемещения необходимо проверить столкновения с поверхностью. Если сталкивается с объектом игрока, необходимо вызвать его функцию hurt().

Далее нужно проверить, имеет ли нормальный вектор столкнувшегося тела компонент x, отличный от 0. Это означает, что он направлен влево или вправо, что указывает на стену или другое препятствие. Направление нормали затем используется для установки нового значения facing. Придание телу небольшой вертикальной скорости создаст у врага небольшой эффект отскока при развороте, что выглядит более привлекательно.

Наконец, если по какой-то причине враг упадет с платформы, необходимо удалить врага, чья координата y станет слишком большой, чтобы избежать бесконечного отслеживания его падения.

Добавьте экземпляр Enemy в вашу сцену уровня. Убедитесь, что по обе стороны от него есть препятствия, и запустите сцену. Проверьте, что враг перемещается туда-сюда между препятствиями. Поставьте игрока на его путь и удостоверьтесь, что вызывается функция hurt() игрока.

Вы можете заметить, что если вы прыгнете на врага, ничего не произойдет. Этот аспект мы рассмотрим далее.

# Урон по врагов

Это нечестно, если у игрока нет возможности ответить ударом, поэтому, по традиции Марио, прыжок сверху на врага победит его.

Начните с добавления новой анимации в узел AnimationPlayer врага с именем death. Установите Длительность на 0,3 и Магнит на 0,05. Не включайте циклическое воспроизведение для этой анимации.

Анимация смерти также установит и Texture, и Frame. Перетащите изображение res://assets/sprites/enemy_death.png в область Texture спрайта, затем щелкните по ключу, чтобы добавить для него ключевой кадр. Как и раньше, установите ключевые кадры для значений 0 и 5 свойства Frame в начале и конце анимации. Не забудьте установить Режим обновления на Постоянный.

Добавьте следующий код в **enemy.gd**, чтобы у вас был способ запустить анимацию смерти на враге:

```gdscript
func take_damage():
    $AnimationPlayer.play("death")
    $CollisionShape2D.set_deferred("disabled", true)
    set_physics_process(false)
```


Когда игрок атакует врага при определенных условиях, вызывается функция take_damage(), которая воспроизводит анимацию смерти, отключает столкновения и останавливает движение.

Когда анимация смерти заканчивает воспроизведение, безопасно удалять врага, поэтому подключите сигнал animation_finished от AnimationPlayer:

![AAnimationPlayer](/img/jungle-jump/B19289_04_21.jpg)

Этот сигнал вызывается каждый раз, когда завершается любая анимация, поэтому необходимо проверить, что это именно та анимация:

```gdscript
func _on_animation_player_animation_finished(anim_name):
    if anim_name == "death":
        queue_free()
```

Чтобы завершить этот процесс, перейдите в скрипт player.gd и добавьте следующий код в раздел _physics_process(), где вы проверяете столкновения. Этот код проверит, если игрок ударил врага сверху:

```gdscript
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()
    if collision.get_collider().is_in_group("enemies"):
        if position.y < collision.get_collider().position.y:
            collision.get_collider().take_damage()
            velocity.y = -200
        else:
            hurt()
```

Этот код сравнивает положение y уровня ног игрока с положением y врага, чтобы определить, находится ли игрок сверху врага. Если да, то враг получит урон; в противном случае получит урон сам игрок.

Запустите уровень еще раз и попробуйте прыгнуть на врага, чтобы убедиться, что все работает как ожидается.

Скрипт игрока
Вы внесли несколько дополнений в скрипт игрока. Вот как теперь должен выглядеть полный скрипт:

```gdscript

extends CharacterBody2D
signal life_changed
signal died
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
var life = 3: set = set_life
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
            velocity.y = -200
            velocity.x = -100 * sign(velocity.x)
            life -= 1
            await get_tree().create_timer(0.5).timeout
            change_state(IDLE)
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            died.emit()
            hide()
func get_input():
    if state == HURT:
        return
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")
    # movement occurs in all states
    velocity.x = 0
    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false
    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true
    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed
    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)
    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)
    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()
    if state == HURT:
        return
    for i in get_slide_collision_count():
        var collision = get_slide_collision(i)
        if collision.get_collider().is_in_group("danger"):
            hurt()
        if collision.get_collider().is_in_group("enemies"):
            if position.y <
            collision.get_collider().position.y:
                collision.get_collider().take_damage()
                velocity.y = -200
            else:
                hurt()
    if state == JUMP and is_on_floor():
        change_state(IDLE)
    if state == JUMP and velocity.y > 0:
        $AnimationPlayer.play("jump_down")
func reset(_position):
    position = _position
    show()
    change_state(IDLE)
    life = 3
func set_life(value):
    life = value
    life_changed.emit(life)
    if life <= 0:
        change_state(DEAD)
func hurt():
    if state != HURT:
        change_state(HURT)

```

Если у вас возникли трудности с кодом игрока, попробуйте размышлить о том, какая часть может быть проблемой. Это движение? Обнаружение столкновений при встрече с врагом? Если вы можете узкое место проблемы, это поможет вам определить, на какой части скрипта вам следует сосредоточиться.

Убедитесь, что вы удовлетворены поведением игрока, прежде чем переходить к следующему разделу.

# Интерфейс игры

Как и в предыдущих проектах, нам понадобится элемент управления (HUD), чтобы отображать информацию во время игры. Сбор предметов будет увеличивать счет игрока, поэтому этот показатель также должен отображаться, а также оставшееся количество жизней игрока, которое будет представлено в виде серии сердец.

Настройка сцены
Создайте новую сцену с корневым узлом **MarginContainer** и именем HUD. Сохраните ее в новой папке с именем ui. Установите макет (Layout) в Top Wide, а в разделе Theme Overrides/Constants в инспекторе установите правые и левые поля на 50, а верхние/нижние поля на 20.

Добавьте узел HBoxContainer для выравнивания элементов и добавьте два дочерних узла, **Label** и **HBoxContainer**, с именами Score и LifeCounter, соответственно.

Для метки Score установите свойство **Text** в **100**. В инспекторе, в разделе **Layout/Container Sizing**, отметьте флажок Expand. В настройках Label добавьте новый объект настройки для настройки шрифта. Перетащите res://assets/Kenney Thick.ttf в свойство Font и установите размер шрифта (Size) в 48. В разделе Outline установите Size на 16, а Color на черный. Вы должны увидеть число 100, отображенное белым цветом с черным контуром.

Для LifeCounter добавьте дочерний узел **TextureRect** и назовите его L1. Перетащите res://assets/heart.png в область Texture и установите Stretch Mode в Keep Aspect Centered. Выберите L1 и продублируйте (Ctrl + D) его четыре раза, чтобы у вас был ряд из пяти сердец:


![HUD ](/img/jungle-jump/B19289_04_22.jpg)

Когда вы закончите, ваш HUD должен выглядеть примерно так:

![HUD preview](/img/jungle-jump/B19289_04_23.jpg)

Следующим шагом будет добавление скрипта, чтобы HUD мог обновляться во время игры.

# Скрипт для HUD
Этот скрипт требует две функции, которые могут быть вызваны для обновления двух отображаемых значений:

```gdscript
extends MarginContainer
@onready var life_counter = $HBoxContainer/LifeCounter.get_children()
func update_life(value):
    for heart in life_counter.size():
        life_counter[heart].visible = value > heart
func update_score(value):
    $HBoxContainer/Score.text = str(value)
```

Обратите внимание, что в функции update_life() вы рассчитываете количество сердец для отображения, устанавливая visible в false, если номер этого сердца меньше количества жизней.


# Добавляем HUD
Откройте level_base.tscn (основную сцену уровня, а не вашу сцену Level01) и добавьте CanvasLayer. Добавьте экземпляр HUD в качестве дочернего элемента этого CanvasLayer.

Выберите экземпляр Player уровня и подключите его сигнал life_changed к методу update_life HUD:


![Подкл сигнал](/img/jungle-jump/B19289_04_24.jpg)

Сделайте то же самое с сигналом **score_changed узла Level**, подключив его к методу **update_score()** HUD.

Обратите внимание, что если вы не хотите использовать дерево сцен для подключения сигналов, или если вы считаете, что окно подключения сигналов запутано или труднопонимаемо, вы можете выполнить тоже самое в своем скрипте, добавив эти строки в функцию _ready() в level.gd:

```gdscript
$Player.life_changed.connect($CanvasLayer/HUD.update_life)
score_changed.connect($CanvasLayer/HUD.update_score)
```

Запустите игру и убедитесь, что вы видите HUD и он обновляется правильно. Убедитесь, что вы собираете предметы и позволяете врагу вас ударить. Увеличивается ли ваш счет? При ударе лишаетесь одной жизни? После проверки этого вы можете перейти к следующему разделу и создать экран заголовка.

# Экран заголовка

Экран заголовка - это то, что игрок увидит первым, и игра вернется на этот экран, когда игрок умрет и игра закончится.

# Настройка сцены

Начните с узла Control и установите макет (Layout) на Full Rect. Добавьте узел TextureRect, используя изображение back.png. Установите макет (Layout) на Full Rect и режим растяжения (Stretch Mode) на Keep Aspect Covered.

Добавьте еще один TextureRect, на этот раз используя middle.png и установив режим растяжения (Stretch Mode) на Tile. Растяните ширину прямоугольника до тех пор, пока он не будет шире экрана, и расположите его так, чтобы он покрывал нижнюю половину.

Добавьте два узла Label с именами Title и Message и установите их свойства Text соответственно на Jungle Jump и Press Space to Play. Добавьте шрифт к каждому, как вы уже делали ранее, установив размер 72 для заголовка и размер 48 для сообщения. Установите макет (layout) для заголовка на Centered, а для сообщения - на Center Bottom.

Когда закончите, сцена должна выглядеть примерно так:
![Экран заголовка](/img/jungle-jump/B19289_04_25.jpg)


Для того чтобы сделать экран заголовка более интересным, добавьте к нему узел AnimationPlayer. Создайте новую анимацию с именем intro и установите ее на автовоспроизведение. В этой анимации вы можете анимировать элементы экрана, чтобы они двигались, появлялись, затухали и т. д.

Например, добавьте ключевую точку для текущей позиции заголовка (Title) в момент времени 0.5. Затем, в момент времени 0, перетащите заголовок за верхний край экрана и добавьте еще одну ключевую точку. Теперь, при воспроизведении сцены, заголовок упадет на экран.

Не стесняйтесь добавлять дорожки, анимирующие свойства других узлов. Например, вот анимация, которая опускает заголовок вниз, затем затухает две текстуры, а затем появляется сообщение:

![Экран заголовка анимация](/img/jungle-jump/B19289_04_26.jpg)

Экран заголовка был оставлен простым, но вы можете добавить к нему что-то по своему вкусу. Вы можете показать пример каких-то платформ, добавить анимацию персонажа, бегущего по экрану, или какое-то другое игровое искусство. Но что произойдет, когда игрок нажмет "старт"? Для этого вам нужно загрузить первый уровень в основной сцене.

# Настройка основной сцены
Вы создали несколько сцен уровней, но, в конечном итоге, вам захочется создать больше одного. Как игра узнает, какой уровень загрузить? За это будет отвечать ваша основная сцена.

Удалите все дополнительные узлы, которые вы добавили в main.tscn, когда тестировали движение игрока. Теперь эта сцена будет отвечать за загрузку текущего уровня. Однако, прежде чем она сможет это сделать, вам нужен способ отслеживать текущий уровень. Вы не можете отслеживать эту переменную в сцене уровня, потому что она будет заменена новым загруженным уровнем, когда он завершится. Для отслеживания данных, которые необходимо передавать из сцены в сцену, вы можете использовать автозагрузку.

# Об автозагрузке

В Godot вы можете настроить сценарий или сцену как автозагрузку. Это означает, что движок будет автоматически загружать ее всегда. Даже если вы измените текущую сцену в SceneTree, автозагруженный узел останется. Вы также можете обращаться к этой автозагруженной сцене по имени из любого другого узла в вашей игре.

В редакторе сценариев создайте новый сценарий с именем game_state.gd и добавьте следующий код:
```gdscript
extends Node
var num_levels = 2
var current_level = 0
var game_scene = "res://main.tscn"
var title_screen = "res://ui/title.tscn"
func restart():
    current_level = 0
    get_tree().change_scene_to_file(title_screen)
func next_level():
    current_level += 1
    if current_level <= num_levels:
        get_tree().change_scene_to_file(game_scene)
```


Вы должны установить значение num_levels равным количеству уровней, которые вы создали в папке levels. Убедитесь, что вы даете им согласованные имена, такие как level_01.tscn, level_02.tscn и так далее, чтобы их можно было легко найти.

Чтобы добавить этот сценарий как автозагрузку, откройте Настройки проекта и найдите вкладку Autoload. Нажмите на значок папки, чтобы выбрать game_state.gd, а затем нажмите кнопку Add.

Затем добавьте этот сценарий в вашу основную Main сцену:

```gdscript
extends Node
func _ready():
    var level_num = str(GameState.current_level).pad_zeros(2)
    var path = "res://levels/level_%s.tscn" % level_num
    var level = load(path).instantiate()
    add_child(level)
```


Теперь, когда основная сцена загружается, она будет включать сцену уровня, соответствующую текущему уровню.

Этот скрипт должен быть присоединен к узлу Title, чтобы экран заголовка мог переходить к игровой сцене:

```gdscript
extends Control

func _input(event):
    if event.is_action_pressed("ui_select"):
        GameState.next_level()
```

Наконец, чтобы вызвать функцию restart() при смерти игрока, добавьте ее в level.gd. В сцене Level подключите сигнал died экземпляра Player:

```gdscript
func _on_player_died():
    GameState.restart()
```

Теперь вы должны быть в состоянии полностью пройти игру. Убедитесь, что title.tscn установлена как основная сцена игры (то есть та, которая запускается первой). Если ранее была установлена другая сцена как "основная" сцена, вы можете изменить это в Настройках проекта в разделе Приложение/Запуск:

![Cмена основной сцены](/img/jungle-jump/B19289_04_27.jpg)


# Transitioning between levels
Теперь у ваших уровней должен быть способ перехода от одного к другому. В спрайт-листе res://assets/environment/props.png есть изображение двери, которое вы можете использовать для выхода из уровня. Нахождение и прохождение через дверь перенесет игрока на следующий уровень.

# Сцена двери
Создайте новую сцену с узлом Area2D и именем Door, сохраните ее в папке items. Добавьте узел Sprite2D и используйте изображение props.png в качестве текстуры. В разделе Region нажмите Enabled, а затем кнопку Edit Region, чтобы выбрать изображение двери из спрайт-листа. Затем в Offset/Offset установите y в -8. Это обеспечит правильное положение двери при размещении ее в месте тайла.

Добавьте узел CollisionShape2D и дайте ему прямоугольную форму, которая охватывает дверь. Поместите дверь на слой items и установите ее маску так, чтобы она сканировала только слой игрока.

Для этой сцены не нужен сценарий, потому что вы собираетесь использовать ее сигнал body_entered в сценарии уровня.

Чтобы разместить дверь в уровне, вы можете использовать объект door из тайлсета tiles_items, который вы используете в своей карты тайлов Items для размещения вишен и драгоценных камней. Разместите дверь в вашем уровне и откройте level.gd.

В начале level.gd определите сцену двери:
```gdscript
var door_scene = load("res://items/door.tscn")
```
Затем обновите функцию spawn_items(), чтобы она также создавала двери:

```gdscript
func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        if type == "door":
            var door = door_scene.instantiate()
            add_child(door)
            door.position = $Items.map_to_local(cell)
            door.body_entered.connect(_on_door_entered)
        else:
            var item = item_scene.instantiate()
            add_child(item)
            item.init(type, $Items.map_to_local(cell))
            item.picked_up.connect(self._on_item_picked_up)
```


Добавьте функцию, которая будет вызываться, когда игрок касается двери:

```gdscript
func _on_door_entered(body):
    GameState.next_level()
```

Запустите игру и попробуйте пройти в дверь. Если вы установили в game_state.gd переменную `num_levels` равной числу больше 1, игра попытается загрузить level_02.tscn, когда вы коснетесь двери.

# Настройки экрана
Напомним, что в начале этой главы вы установили режим растяжения (Stretch/Mode) и соотношение сторон (Aspect) в Настройках проекта на canvas_items и expand, соответственно. Запустите игру и попробуйте изменить размер окна игры. Обратите внимание, что, если вы расширите окно, вы сможете видеть больше мира игры слева/справа от игрока. Это то, что делает значение expand.

Если вы хотите предотвратить это, вы можете установить его в значение keep, которое всегда будет показывать одинаковое количество мира игры, что видно камерой. Однако это также означает, что если вы измените форму окна на что-то отличное от формы игры, появятся черные полосы, чтобы заполнить дополнительное пространство.

В качестве альтернативы, установка значения ignore не будет отображать черные полосы, но содержимое игры будет растянуто для заполнения пространства, и это может исказить изображение.

Потратьте некоторое время на эксперименты с различными настройками и решите, какие вам больше нравятся.
# Финишная прямая
Хотя вы завершили основную структуру игры и, вероятно, создали несколько уровней для игрока, можно рассмотреть возможность добавления некоторых элементов для улучшения геймплея. В этом разделе вы найдете еще несколько предложенных функций - добавьте их как есть или настройте под свой вкус.


# Звуковые эффекты
Как и в предыдущих проектах, вы можете добавить звуковые эффекты и музыку для улучшения опыта игры. В папке res://assets/audio/ вы найдете аудиофайлы, которые вы можете использовать для различных событий в игре, таких как прыжок игрока, удар по врагу и подбор предмета. Также есть два файлы музыки: Intro Theme для экрана заголовка и Grasslands Theme для сцены уровня.

Добавление их в игру остается за вами, но вот несколько советов:

- Вам может быть полезно настроить громкость отдельных звуков. Это можно сделать с помощью свойства Volume dB. Установка отрицательного значения уменьшит громкость звука.
- Вы можете присоединить музыку к сцене master level.tscn; эта музыка будет использоваться для всех уровней. Вы также можете присоединить отдельную музыку к индивидуальным уровням, если хотите создать определенное настроение.
- Ваше первое предположение, возможно, будет заключаться в том, чтобы разместить AudioStreamPlayer на сцене Item для воспроизведения звука подбора. Однако, поскольку предмет удаляется, когда игрок его касается, это не сработает хорошо. Вместо этого поместите аудиоплеер в сцену Level, так как именно там обрабатывается результат подбора (увеличение счета).


Двойные прыжки - популярная функция в платформерах. Игрок получает второй, обычно меньший, всплеск вверх, если они нажимают клавишу прыжка второй раз, находясь в воздухе. Для реализации этой функции вам нужно добавить несколько вещей в сценарий игрока.

В первую очередь, вам понадобятся переменные для отслеживания количества прыжков и определения того, насколько велик будет второй всплеск:

```gdscript
@export var max_jumps = 2
@export var double_jump_factor = 1.5
var jump_count = 0
```

При входе в состояние JUMP сбросьте количество прыжков:

```gdscript
JUMP:
    $AnimationPlayer.play("jump_up")
    jump_count = 1
```

В функции get_input() разрешите прыжок, если выполнены определенные условия. Разместите это перед оператором if, где вы проверяете, находится ли игрок на полу:

```gdscript
if jump and state == JUMP and jump_count < max_jumps and jump_count > 0:
    $JumpSound.play()
    $AnimationPlayer.play("jump_up")
    velocity.y = jump_speed / double_jump_factor
    jump_count += 1
```

В _physics_process(), когда вы приземляетесь на землю, сбросьте количество прыжков:

```gdscript
if state == JUMP and is_on_floor():
    change_state(IDLE)
    jump_count = 0
```

Запустите вашу игру и попробуйте двойные прыжки. Обратите внимание, что этот код делает второй прыжок 2/3 от высоты вверх от начального прыжка. Вы можете настроить это в соответствии с вашими предпочтениями.


**Частицы пыли**

Создание эффекта вылетающих частиц пыли у ног персонажа - это простой, но заметный прием, который может добавить характера движениям вашего игрока. В этом разделе вы добавите небольшое облако пыли к ногам игрока, которое появляется каждый раз, когда они приземляются на землю. Это придаст ощущение веса и удара прыжкам игрока.

Добавьте узел CPUParticles2D к сцене Player и назовите его Dust. Установите следующие свойства:

**Свойство** | **Значение**
--- | ---
**Amount** | 20
**Lifetime** | 0.45
**One Shot** | On
**Speed Scale** | 2
**Explosiveness** | 0.7
**Emission Shape** | Rectangle
**Rect Extents** | 1, 6
**Initial Velocity Max** | 10
**Scale Amount Max** | 3
**Position** | -2, 0
**Rotation** | -90

Цвет частиц по умолчанию - белый, но эффект пыли будет выглядеть лучше в бежевом оттенке. Он также должен исчезнуть, чтобы казаться рассеивающимся. Это можно сделать с помощью Gradient. В разделе Color/Color Ramp выберите New Gradient.

Gradient имеет два цвета: начальный цвет слева и конечный цвет справа. Их можно выбрать, используя маленькие прямоугольники на обоих концах градиента. Нажав на большой квадрат справа, вы можете установить цвет для выбранного прямоугольника:

![Градиент](/img/jungle-jump/B19289_04_27.jpg)

Установите начальный цвет в бежевый оттенок и установите для конечного того же цвета, но с установленным значением альфа-канала равным 0. Вы должны увидеть непрерывный эффект дыма. В инспекторе установите One Shot в положение on. Теперь частицы будут испускаться только один раз, каждый раз, когда вы устанавливаете флажок Emitting.

Не стесняйтесь изменять предоставленные здесь свойства. Эксперименты с частицами могут быть увлекательными, и часто вы случайно обнаруживаете очень красивый эффект, просто поколдовав.

Когда вы будете удовлетворены его внешним видом, добавьте следующий код в _physics_process() игрока:

```gdscript
if state == JUMP and is_on_floor():
    change_state(IDLE)
    $Dust.emitting = true
```

Запустите игру и наблюдайте облако пыли каждый раз, когда ваш персонаж приземляется на землю.


# Лестницы

В анимационной карте спрайта игрока есть кадры для анимации взбирания, а в тайлсете есть изображения лестниц. В настоящее время тайлы лестниц ничего не делают - в TileSet для них не назначена форма столкновения. Это нормально, потому что вы не хотите, чтобы игрок сталкивался с лестницами - вы хотите, чтобы он мог двигаться вверх и вниз по ним.

# Код игрока

Начнем с выбора узла AnimationPlayer игрока и добавления новой анимации с именем climb. Ее длина должна быть 0.4, и ей следует установить цикл. Значения кадров для Sprite2D: 0 -> 1 -> 0 -> 2.

Перейдите в player.gd и добавьте новое состояние CLIMB в перечисление состояний. Кроме того, добавьте два новых объявления переменных в верхней части сценария:

```gdscript
@export var climb_speed = 50
var is_on_ladder = false
```

Используйте переменную `is_on_ladder`, чтобы отслеживать, находится ли игрок на лестнице или нет. Используя эту переменную, вы можете решить, должны ли действия вверх и вниз иметь какой-либо эффект.

В методе `change_state()` добавьте условие для нового состояния:

```gdscript
CLIMB:
    $AnimationPlayer.play("climb")
```

В методе `get_input()` вам нужно проверить входные действия, а затем определить, изменяют ли они состояние:

```gdscript
var up = Input.is_action_pressed("climb")
var down = Input.is_action_pressed("crouch")
if up and state != CLIMB and is_on_ladder:
    change_state(CLIMB)
if state == CLIMB:
    if up:
        velocity.y = -climb_speed
        $AnimationPlayer.play("climb")
    elif down:
        velocity.y = climb_speed
        $AnimationPlayer.play("climb")
    else:
        velocity.y = 0
        $AnimationPlayer.stop()
if state == CLIMB and not is_on_ladder:
    change_state(IDLE)
```

Здесь у вас три новых условия для проверки. Во-первых, если игрок не находится в состоянии CLIMB, но находится на лестнице, то нажатие вверх должно заставить игрока начать карабкаться. Во-вторых, если игрок в настоящее время карабкается, то ввод вверх и вниз должен заставить их двигаться вверх и вниз по лестнице, но остановить воспроизведение анимации, если ни одно действие не нажато. Наконец, если игрок покидает лестницу во время восхождения, он выходит из состояния CLIMB.

Также вам нужно убедиться, что гравитация не тянет игрока вниз, когда он находится на лестнице. Добавьте условие в код гравитации в `_physics_process()`:

```gdscript
if state != CLIMB:
    velocity.y += gravity * delta

```


Добавьте узел Area2D с именем Ladders в сцену уровня, но пока не добавляйте ему форму столкновения. Подключите его сигналы body_entered и body_exited и установите его слой столкновения на items и маску на player. Это гарантирует, что только игрок может взаимодействовать с лестницей. Эти сигналы - это способ сообщить игроку, находится он на лестнице или нет:

```gdscript
func _on_ladders_body_entered(body):
    body.is_on_ladder = true

func _on_ladders_body_exited(body):
    body.is_on_ladder = false
```

Теперь уровню нужно искать любые плитки лестницы и добавлять формы столкновения к узлу Ladders при их обнаружении. Добавьте следующую функцию в level.gd и вызовите ее в _ready():

```gdscript
func create_ladders():
    var cells = $World.get_used_cells(0)
    for cell in cells:
        var data = $World.get_cell_tile_data(0, cell)
        if data.get_custom_data("special") == "ladder":
            var c = CollisionShape2D.new()
            $Ladders.add_child(c)
            c.position = $World.map_to_local(cell)
            var s = RectangleShape2D.new()
            s.size = Vector2(8, 16)
            c.shape = s
```

Обратите внимание, что добавляемые вами формы столкновения имеют ширину всего 8 пикселей. Если сделать форму полной ширины плитки лестницы, то игрок будет выглядеть так, будто он карабкается, даже когда он свисает с боковой стороны, что выглядит немного странно.

Попробуйте это – перейдите в одну из ваших сцен уровня и разместите плитки лестницы в любом месте вашей карты мира. Запустите сцену и попробуйте подняться по лестницам.

Обратите внимание, что если вы находитесь в верхней части лестницы и на нее вступаете, вы упадете вниз, а не будете подниматься вниз (хотя нажатие вверх, падая, заставит вас зацепить лестницу). Если вы предпочитаете автоматический переход в состояние взбирания при падении, вы можете добавить дополнительную проверку на падение в _physics_process():

Подвижные платформы
Подвижные платформы – это интересное дополнение к вашему инструментарию для создания уровней. В этом разделе вы создадите подвижную платформу, которую можно разместить в любом месте вашего уровня и настроить её движение и скорость.

Начните с создания новой сцены с узлом Node2D и назовите её MovingPlatform. Сохраните сцену и добавьте к ней дочерний узел TileMap. Поскольку все изображения для вашей платформы находятся в спрайт-листах и уже были разделены на тайлы с добавленными коллизиями, это упростит процесс рисования платформы. Добавьте tiles_world.tres в качестве тайлсета. Также необходимо отметить флажок Collision Animatable, чтобы убедиться, что коллизии будут корректно работать даже во время движения.

Нарисуйте несколько тайлов в TileMap, но убедитесь, что начинаете с начала координат (0, 0), чтобы всё выглядело аккуратно. Эти тайлы отлично подходят для плавающей платформы:


![Плавающая платформа](/img/jungle-jump/B19289_04_28.jpg)


Добавьте скрипт к корневому узлу и начните с этими переменными:

```gdscript
@export var offset = Vector2(320, 0)
@export var duration = 10.0
```

Эти переменные позволят вам задать величину и скорость движения. offset относится к начальной точке, и поскольку это узел Vector2, вы можете создавать платформы, двигающиеся горизонтально, вертикально или по диагонали. duration измеряется в секундах и представляет собой время полного цикла.

Платформа всегда будет находиться в движении, поэтому вы можете начать анимацию в _ready(). Она будет использовать метод tween для анимации позиции в два этапа: от начальной позиции до позиции offset и обратно:

```gdscript
func _ready():
    var tween = create_tween().set_process_mode(
        Tween.TWEEN_PROCESS_PHYSICS)
    tween.set_loops().set_parallel(false)
    tween.tween_property($TileMap, "position", offset,
        duration / 2.0).from_current()
    tween.tween_property($TileMap, "position",
        Vector2.ZERO, duration / 2.0)
```

Вот несколько замечаний об использовании tween:

- Необходимо установить режим процесса, чтобы движение синхронизировалось с физикой, и игрок мог корректно взаимодействовать с платформой (то есть, стоять на ней).
- set_loops() сообщает tween, что нужно повторить анимацию после завершения.
- set_parallel(false) говорит tween выполнить две анимации свойств последовательно, а не одновременно.
- Вы также можете экспериментировать с другими кривыми анимации. Например, добавление tween.set_trans(Tween.TRANS_SINE) заставит платформу замедляться в конце движения для более естественного вида. Попробуйте поэкспериментировать с другими типами переходов.

Теперь вы можете добавить экземпляры MovingPlatform в сцену уровня. Чтобы убедиться, что все правильно выравнивается, убедитесь, что включена привязка к сетке:

![Включение привязки к сетке](/img/jungle-jump/B19289_04_30.jpg)

Значение по умолчанию - (8, 8), но вы можете изменить его, нажав три точки рядом с значком и выбрав "Configure Snap".

Когда вы запустите игру, у вас будет намного больше элементов для взаимодействия. Лестницы и подвижные платформы предоставляют вам множество возможностей для создания уровней. Но это еще не все! Учитывая все, что вы сделали в этой главе, существует множество других функций, которые вы можете добавить. У анимации игрока есть анимация "приседания" - а если бы враги могли бросать вещи в игрока, которые можно было бы уклониться? Многие игры платформера включают дополнительные механики движения, такие как скольжение по наклонным поверхностям, прыжки от стен, изменение гравитации и многое другое. Выберите одну из них и посмотрите, сможете ли вы ее добавить.


# Итог 
В этой главе вы узнали, как использовать узел CharacterBody2D для создания физики в стиле аркады для движения игрока. Этот мощный узел можно использовать для создания широкого спектра игровых объектов - не только персонажей на платформах.

Вы изучили узел TileMap для дизайна уровней - мощного инструмента с еще большими возможностями, чем вы использовали в этом проекте. Можно было бы написать целую главу о том, что можно сделать с этим узлом. Дополнительную информацию можно найти на странице Using TileMaps на сайте документации Godot: https://docs.godotengine.org/en/latest/tutorials/2d/using_tilemaps.html.

Camera2D и ParallaxBackground также являются ключевыми инструментами для любой игры, в которой вы хотите перемещаться по миру, который больше размера экрана. Узел камеры, в частности, будет узлом, который вы будете использовать в большинстве проектов 2D.

Вы также широко использовали знания, полученные в предыдущих проектах, чтобы связать все вместе. Надеюсь, на этом этапе у вас есть хорошее представление о системе сцен и о том, как устроен проект Godot.

Еще раз, прежде чем двигаться дальше, уделите несколько моментов, чтобы поиграть в свою игру, просмотреть ее различные сцены и скрипты, чтобы рассмотреть, как вы ее создали. Пересмотрите любые разделы этой главы, которые вы нашли особенно сложными. И, самое главное, прежде чем двигаться дальше, попробуйте внести некоторые изменения в проект.

В следующей главе вы перейдете к 3D!