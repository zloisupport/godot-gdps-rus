
# Jungle Jump – Бег и Прыжки в 2D Платформере

В этой главе вы создадите игру в жанре платформера в духе классических произведений, таких как Super Mario Bros. Платформеры являются очень популярным жанром, и понимание их работы может помочь вам создавать различные стили игр. Если вы никогда не пробовали создавать подобные игры ранее, движение игрока в платформерах может оказаться удивительно сложным для реализации, и вы увидите, как узлы CharacterBody2D в Godot предоставляют функции, которые помогут вам в этом процессе.

В этом проекте вы узнаете о следующем:

::list
- Использование узла CharacterBody2D
- Использование узла Camera2D
- Сочетание анимаций и ввода пользователя для создания сложного поведения персонажа
- Проектирование уровней с использованием TileMap
- Создание бесконечно прокручиваемого фона с использованием ParallaxLayer
- Переход между сценами
- Организация вашего проекта и планирование для будущего расширения
::
Вот скриншот завершенной игры:

![ Completed game screenshot](/img/jungle-jump/1.png)


## Настройка проекта

Для создания нового проекта начнем с открытия настроек проекта, чтобы настроить параметры по умолчанию, которые вам понадобятся.

Графические ресурсы для этой игры используют стиль пиксельного искусства, что означает, что они выглядят лучше, когда изображения не сглаживаются, что является настройкой по умолчанию в Godot для фильтрации текстур:

![Фильтрация текстур](/img/jungle-jump/2.png)

Хотя можно установить это для каждого Sprite2D, более удобно указать значение по умолчанию. Нажмите на переключатель Advanced в верхнем правом углу и найдите раздел Rendering/Textures слева. В списке настроек прокрутите вниз и найдите настройку Canvas Textures/Default Texture Filter. Измените ее с Linear на Nearest.

Затем, в разделе Display/Window, измените Stretch/Mode на canvas items и Aspect на expand. Эти настройки позволят пользователю изменять размер игрового окна, сохраняя при этом качество изображения. Когда проект будет завершен, вы сможете увидеть эффекты этой настройки.

Затем можно настроить слои столкновения. Поскольку в этой игре будет несколько различных типов объектов столкновения, которые должны взаимодействовать разными способами, вы будете использовать систему слоев столкновения Godot для их удобной организации. Слои будут более удобными в использовании, если им будут присвоены имена. Перейдите в раздел Layer Names | 2D Physics и назовите первые четыре слоя так (напечатайте непосредственно в поле рядом с номером слоя):
![Фильтрация текстур](/img/jungle-jump/3.png)

Наконец, добавьте следующие действия для управления игроком в раздел Input Map:



| Клавиши  | Действия  |
|----------|-----------|
| right    | D, →      |
| left     | A, ←      |
| jump     | Space     |
| up       | S,  ↑     |
| down     | W, ↓      |
| -------- | --------- |

Убедитесь, что вы используете точные названия для действий ввода, поскольку вы будете ссылаться на них в коде позже.

Это все, что вам нужно настроить в **Project Settings**. Но перед тем как приступить к созданию сцены игрока, вам нужно узнать о другом типе узла физики.

## Введение в кинематические тела
Для платформера требуется гравитация, столкновения, прыжки и другие физические поведения, поэтому вы могли бы подумать, что RigidBody2D был бы идеальным выбором для реализации движения персонажа. На практике вы обнаружите, что более реалистичная физика твердого тела не является желательной для платформенного персонажа. Для игрока реализм менее важен, чем отзывчивое управление и ощущение действия. Таким образом, как разработчик, вам хочется иметь точный контроль над движениями персонажа и его реакцией на столкновения. По этой причине кинематический стиль физики обычно является более предпочтительным выбором для платформенного персонажа.

Узел CharacterBody2D предназначен для реализации физических тел, которые могут быть управляемы напрямую через код. Эти узлы обнаруживают столкновения с другими телами при движении, но не подвержены глобальным свойствам физики, таким как гравитация или трение. Это не означает, что они не могут быть подвержены гравитации и другим силам - просто вы должны рассчитывать эти силы и их воздействие в коде; физический движок не будет автоматически перемещать узел CharacterBody2D.

При перемещении узла CharacterBody2D, так же как и с RigidBody2D, вы не должны устанавливать его свойство position напрямую. Вместо этого вы должны использовать методы move_and_collide() или move_and_slide(), предоставленные узлом. Эти методы перемещают тело вдоль заданного вектора и мгновенно останавливают его, если обнаружено столкновение с другим телом. Затем вам придется решить, как реагировать на столкновение.

Реакция на столкновение
После столкновения вы, возможно, захотите, чтобы тело отскакивало, скользило вдоль стены или изменяло свойства объекта, с которым оно столкнулось. Способ обработки реакции на столкновение зависит от того, какой метод вы используете для перемещения тела:

## move_and_collide()

При использовании этого метода функция возвращает объект KinematicCollision2D при столкновении. Этот объект содержит информацию о столкновении и теле, с которым произошло столкновение. Вы можете использовать эту информацию для определения реакции. Обратите внимание, что функция возвращает null, когда перемещение завершается успешно без столкновения.

Например, если вы хотите, чтобы тело отскакивало от столкнувшегося объекта, вы можете использовать следующий скрипт:

```gdscript
extends CharacterBody2D

var velocity = Vector2(250, 250)

func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.bounce(collision.get_normal())
```

## move_and_slide()
Скольжение - очень распространенный вариант реакции на столкновение. Представьте себе игрока, движущегося вдоль стены в игре сверху вниз или бегущего по земле в платформере. Возможно реализовать реакцию самостоятельно после использования move_and_collide(), но move_and_slide() предоставляет удобный способ реализации скользящего движения. При использовании этого метода тело автоматически будет скользить вдоль поверхности столкновения. Кроме того, скользящие столкновения позволят вам определить ориентацию поверхности с использованием методов, таких как is_on_floor().

Поскольку в этом проекте вам нужно будет разрешить игровому персонажу двигаться по земле и вдоль наклонов вверх и вниз, move_and_slide() будет играть важную роль в движении вашего персонажа.

Теперь, когда у вас есть представление о том, что такое кинематические тела, вы будете использовать одно из них для создания персонажа для этой игры.


## Создание сцены игрока
Узел Godot, реализующий кинематическое движение и столкновение, называется CharacterBody2D. Откройте новую сцену и добавьте узел CharacterBody2D с именем Player в качестве корневого и сохраните сцену. Не забудьте нажать кнопку "Group Selected Node(s)". При сохранении сцены Player вы также должны создать новую папку для её содержимого. Это поможет поддерживать порядок в папке проекта по мере добавления новых сцен и скриптов.

Ознакомьтесь со свойствами CharacterBody2D в инспекторе. Обратите внимание на значения по умолчанию для режима движения (Motion Mode) и направления вверх (Up Direction). Режим "Grounded" означает, что тело будет рассматривать одно направление столкновения как "пол", противоположную стену как "потолок", а любые другие как "стены" – какое именно определяется направлением вверх (Up Direction).

Как и в предыдущих проектах, вы включите все узлы, необходимые для функционирования персонажа-игрока, в сцену Player. Для этой игры это означает обработку столкновений с различными игровыми объектами, такими как платформы, враги и предметы для сбора; отображение анимаций для действий, таких как бег или прыжок; и прикрепление камеры для слежения за игроком по уровню.

Сценарии для различных анимаций могут быстро стать неуправляемыми, поэтому вам нужно будет использовать конечный автомат (FSM) для управления и отслеживания состояний игрока. Ознакомьтесь с главой 3, чтобы вспомнить, как можно создать упрощенный FSM. Вы будете следовать подобному паттерну и для этого проекта.

## Слои столкновений и маски
Свойство Collision/Layer тела определяет на каком (на каких) слое(ах) в физическом мире находится тело. Игроку необходимо быть присвоенным слою "player" (который вы назвали в настройках проекта). Точно так же, свойство Collision/Mask определяет, с какими слоями тело может "видеть" или взаимодействовать. Если объект находится на слое, отсутствующем в маске игрока, то игрок не взаимодействует с ним вообще.
Установите слой игрока на "player" и маску на "environment", "enemies" и "items". Нажмите на три точки справа, чтобы открыть список флажков, отображающих имена, которые вы присвоили слоям:

![Свойство Collision/Layer](/img/jungle-jump/4.jpg)
Это гарантирует, что игрок находится на слое "player", что позволяет настраивать другие объекты на обнаружение или игнорирование игрока. Установка значения маски для всех трех слоев означает, что игрок сможет взаимодействовать с объектами на любом из этих слоев.

## О AnimationPlayer
Ранее в этой книге вы использовали AnimatedSprite2D для отображения анимаций на основе кадров ваших персонажей. Это отличный инструмент, но он полезен только для анимации визуальной текстуры узла. Что если вы также хотите анимировать любые другие свойства узла?

В этом случае пригодится AnimationPlayer. Этот узел является очень мощным инструментом для создания анимаций, которые могут влиять на несколько узлов одновременно; вы можете изменять любые из их свойств.

## Animations
Для настройки анимаций персонажа выполните следующие шаги:

Добавьте узел Sprite2D к узлу Player. Перетащите файл res://assets/player_sheet.png из панели FileSystem и отпустите его в свойство Texture. Анимация игрока будет сохранена в виде спрайт-листа:

![Спрайт-лист](/img/jungle-jump/B19289_04_05.jpg)

Вы будете использовать AnimationPlayer для управления анимациями. В свойствах анимации узла Sprite2D установите HFrames равным 19. Затем установите Frame равным 7, чтобы увидеть стоящего игрока. Наконец, поднимите Sprite2D вверх, пока его ноги не будут стоять на земле, установив свойство Position равным (0, -16). Это упростит написание кода для взаимодействия с игроком, так как вы будете знать, что свойство позиции игрока представляет собой местоположение его ног.

Добавьте узел AnimationPlayer в сцену. Вы будете использовать этот узел для изменения свойства Frame узла Sprite2D на соответствующие значения для каждой анимации. Прежде чем начать, ознакомьтесь с различными частями панели анимации:

![Панель анимации](/img/jungle-jump/B19289_04_06.jpg)


Нажмите кнопку Animation и выберите New. Назовите новую анимацию idle.
Установите ее продолжительность равной 0,4 секунды. Нажмите на иконку Loop, чтобы сделать анимацию цикличной, и установите режим обновления трека в Continuous.
Измените свойство Frame узла Sprite2D на 7, что является первым кадром анимации покоя, и щелкните на иконку ключевого кадра рядом со свойством, чтобы добавить трек анимации с новым ключевым кадром:

![Добавление ключевого кадра](/img/jungle-jump/B19289_04_07.jpg)

Переместите ползунок воспроизведения на 0,3 (вы можете отрегулировать регулятор масштаба в правом нижнем углу, чтобы упростить поиск). Добавьте ключевой кадр для кадра 10, который является последним кадром покоя.
Нажмите кнопку Play, чтобы посмотреть анимацию. Если она выглядит неправильно, вернитесь к предыдущему пункту и убедитесь, что вы точно следовали всем шагам, особенно тому факту, что начинаете с кадра 7 и заканчиваете на кадре 10.
Теперь повторите этот процесс для других анимаций. Смотрите таблицу ниже для списка их настроек:

| Имя       | Продолжительность | Кадры        | Цикличность |
|-----------|-------------------|--------------|-------------|
| idle      | 0.4 сек           | 7 → 10       | Вкл         |
| run       | 0.5 сек           | 13 → 18      | Вкл         |
| hurt      | 0.2 сек           | 5 → 6        | Вкл         |
| jump_up   | 0.1 сек           | 11           | Выкл        |
| jump_down | 0.1 сек           | 12           | Выкл        |

Также есть анимации для приседания и лазания в спрайт-листе, но вы можете добавить их позже, когда базовое движение будет завершено.

## Collision shape

Как и с другими телами, CharacterBody2D требуется форма, назначенная для определения его границ столкновения. Добавьте узел CollisionShape2D и создайте внутри него новую форму RectangleShape2D. При размерировании формы вы хотите, чтобы она достигала до нижней части изображения (ноги игрока), но была немного уже, чем изображение самого игрока. В целом, сделать форму немного меньше, чем изображение, приведет к лучшему ощущению во время игры, избегая впечатления о столкновении с чем-то, что, казалось бы, не должно вызывать столкновение.

Вам также нужно сместить форму немного, чтобы она подходила. Установка свойства Position узла CollisionShape2D в (0, -10) хорошо подходит. Когда вы закончите, это должно выглядеть примерно так:

![Форма столкновения игрока](/img/jungle-jump/B19289_04_08.jpg)

## Несколько форм

В некоторых случаях, в зависимости от сложности вашего персонажа и его взаимодействий с другими объектами, вы можете захотеть добавить несколько форм к одному и тому же объекту. Вы можете иметь одну форму у ног игрока для обнаружения столкновений с землей, другую на его теле для обнаружения урона и еще одну, покрывающую переднюю часть игрока для обнаружения столкновений со стенами.

## Завершение сцены игрока
Добавьте узел Camera2D в сцену Player. Этот узел будет центрировать игровое окно на игроке по мере его перемещения по уровню. Вы также можете использовать его для увеличения изображения игрока, так как пиксель-арт относительно мал по сравнению с размером игрового окна. Помните, что, поскольку вы установили опцию фильтрации в Настройках проекта, текстура игрока останется пиксельной и блочной при увеличении масштаба.

Чтобы включить камеру, установите свойство Enabled в On, а затем установите Zoom в (2.5, 2.5). Значения меньше 1 уменьшают масштаб камеры, а большие значения увеличивают его.

Вы увидите розовато-пурпурный прямоугольник вокруг игрока. Это экранная область камеры и показывает, что увидит камера. Вы можете регулировать свойство Zoom, чтобы увеличивать или уменьшать ее размер и видеть больше или меньше мира вокруг игрока.

## Состояния игрока
У игрового персонажа есть разнообразное поведение, такое как прыжки, бег и приседания. Программирование таких поведений может стать очень сложным и трудным в управлении. Один из способов решения этой проблемы - использовать булевы переменные (например, is_jumping или is_running), но это может привести к возможно запутанным состояниям (что, если и is_crouching, и is_jumping одновременно true?) и быстро привести к _spaghetti_ коду.

Лучшим решением этой проблемы является использование конечного автомата для управления текущим состоянием игрока и управления переходом к другим состояниям. Этот концепт был представлен в главе 3, и вы будете расширять его в этом проекте.

![Вот диаграмма состояний игрока](/img/jungle-jump/B19289_04_09.jpg)

Как видно, диаграммы состояний могут стать достаточно сложными, даже с относительно небольшим количеством состояний.

## Другие состояния

Обратите внимание, что, хотя в спрайт-листе содержатся анимации для них, состояния CROUCH и CLIMB здесь не включены. Это сделано для упрощения управления количеством состояний в начале проекта. Позднее у вас будет возможность добавить их.

## Скрипт игрока
Присоедините новый скрипт к узлу Player. Обратите внимание, что в диалоге отображается свойство Template с примером кода Basic Movement для этого типа узла в Godot. Отключите флажок Template - вам не понадобится этот пример кода для этого проекта.

Добавьте следующий код для начала настройки конечного автомата игрока. Как и в игре Space Rocks, вы можете использовать тип enum для определения допустимых состояний для системы. Когда вы захотите изменить состояние игрока, вы можете вызвать change_state():

```gdscript
extends CharacterBody2D
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            hide()
```

На данный момент скрипт только изменяет воспроизводимую анимацию, но позже вы добавите больше функциональности состояния.

## Движение игрока
Игроку нужны три управления: влево, вправо и прыжок. Сравнение текущего состояния с тем, какие клавиши нажаты, вызовет изменение состояния, если переход разрешен правилами диаграммы состояний. Добавьте функцию get_input() для обработки ввода и определения результата. Каждое условие if представляет один из переходов в диаграмме состояний:

```gdscript
func get_input():
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")

    # movement occurs in all states
    velocity.x = 0

    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false

    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true

    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed

    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)

    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)

    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)

```

Обратите внимание, что проверка прыжка использует is_action_just_pressed() вместо is_action_pressed(). В то время как последнее возвращает true, пока клавиша удерживается, первое будет true только в том кадре, в котором клавиша была нажата. Это означает, что игрок должен нажимать клавишу прыжка каждый раз, когда они хотят прыгнуть.

Вызывайте эту функцию из _physics_process(), добавляйте гравитацию к скорости игрока и вызывайте метод move_and_slide() для перемещения:

```gdscript
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()
```

Помните, что поскольку свойство Up Direction установлено на (0, -1), любое столкновение под ногами игрока будет считаться "полом", и is_on_floor() будет установлено в true методом move_and_slide(). Вы можете использовать это для определения окончания прыжка, добавив это сразу после move_and_slide():

```gdscript
if state == JUMP and is_on_floor():
    change_state(IDLE)
```

Прыжок будет выглядеть лучше, если анимация переключится с jump_up на jump_down при падении:

```gdscript
if state == JUMP and velocity.y > 0:
    $AnimationPlayer.play("jump_down")
```

Позже, после завершения уровня, игроку будет передано местоположение появления. Чтобы обработать это, добавьте эту функцию в скрипт:

```gdscript
func reset(_position):
    position = _position
    show()
    change_state(IDLE)
```

Таким образом, вы завершили добавление движения, и для каждой ситуации должна воспроизводиться правильная анимация. Это было бы хорошей точкой остановки и проверки игрока, чтобы убедиться, что все работает. Однако вы не можете просто запустить сцену, потому что игрок начнет падать без поверхности для стояния.


## Тестирование движения
Создайте новую сцену и добавьте объект Node с именем Main (позднее это станет вашей основной сценой). Добавьте экземпляр Player, затем добавьте узел StaticBody2D с прямоугольной формой столкновения. Растяните форму столкновения горизонтально так, чтобы она была достаточно широкой для движения туда и обратно, и разместите ее под персонажем:

![Тестовая сцена с платформой](/img/jungle-jump/B19289_04_10.jpg)

Поскольку у него нет узла Sprite2D, статическое тело будет невидимым при запуске игры. В меню выберите Debug > Visible Collision Shapes. Это полезная настройка отладки, которая будет рисовать формы столкновения во время выполнения игры. Вы можете включить ее в любое время, когда вам нужно тестировать или устранять проблемы с столкновениями.

Нажмите Play Scene; вы должны увидеть, что игрок перестает падать и начинает воспроизводить анимацию покоя, когда он касается статического тела.

Прежде чем перейти дальше, убедитесь, что все движения и анимации работают правильно. Бегите и прыгайте во всех направлениях и проверьте, что правильные анимации воспроизводятся, когда состояние изменяется. Если вы обнаружите какие-либо проблемы, просмотрите предыдущие разделы и убедитесь, что вы ничего не упустили.

## Здоровье игрока
В конечном итоге игрок столкнется с опасностью, поэтому вы должны добавить систему урона. Игрок начнет с тремя сердцами и потеряет одно каждый раз, когда ему наносят урон.

Добавьте следующее в верхнюю часть скрипта (сразу после строки extends):

```gdscript
signal life_changed
signal died
var life = 3 setget set_life
func set_life(value):
    life = value
    life_changed.emit(life)
    if life <= 0:
        change_state(DEAD)
```

Вы будете излучать сигнал life_changed каждый раз, когда значение life изменяется, уведомляя дисплей о необходимости обновления. died будет излучен, когда life достигнет 0.

Добавьте `life = 3` в функцию reset().

Есть два возможных способа, которыми игрок может получить урон: столкновение с объектом шипа в окружении или удар врага. В любом случае может быть вызвана следующая функция:


```gdscript
func hurt():
    if state != HURT:
        change_state(HURT)
```

Этот код относится к дружелюбному отношению к игроку: если он уже ранен, его нельзя ранить снова (по крайней мере, в течение короткого времени, пока анимация урона не завершится). Без этого легко застрять в цикле получения урона, что приведет к быстрой смерти.

Есть несколько вещей, которые нужно сделать, когда состояние изменяется на HURT в функции change_state(), которую вы ранее создали:

```gdscript
HURT:
    $AnimationPlayer.play("hurt")
    velocity.y = -200
    velocity.x = -100 * sign(velocity.x)
    life -= 1
    await get_tree().create_timer(0.5).timeout
    change_state(IDLE)
DEAD:
    died.emit()
    hide()
```

Когда игрок получает урон, не только он теряет одну жизнь, но и отбрасывается вверх и в сторону от повреждающего объекта. Через некоторое время состояние возвращается к IDLE.

Кроме того, ввод должен быть отключен во время состояния HURT. Добавьте это в начало функции get_input():

```gdscript
if state == HURT:
    return
```

Теперь игрок готов получать урон после того, как остальная часть игры будет настроена. Далее вы создадите объекты, которые игрок будет собирать в игре.

## Collectible items
Прежде чем приступить к созданию уровня, вам нужно создать несколько предметов, которые игрок сможет собирать, поскольку они также будут частью уровня. В папке assets/sprites содержатся спрайт-листы для двух типов собираемых предметов: вишен и самоцветов.

Вместо того чтобы создавать отдельную сцену для каждого типа предмета, вы можете использовать одну сцену и заменять свойство текстуры в скрипте. Оба объекта имеют одинаковое поведение: анимация на месте и исчезновение при сборе игроком. Вы также можете добавить эффект плавного перехода для сбора (см. главу 2).

## Настройка сцены
Начните новую сцену с Area2D и назовите ее Item. Сохраните сцену в новой папке items.

Область - хороший выбор для этих объектов, потому что вы хотите определить, когда с ними контактирует игрок, но вам не нужен ответ на столкновение от них. В инспекторе установите Collision/Layer на collectibles (слой 4) и Collision/Mask на player (слои 2). Это обеспечит возможность собирать их только игроку, в то время как враги будут проходить сквозь них.

Добавьте три дочерних узла: Sprite2D, CollisionShape2D и AnimationPlayer. Перетащите res://assets/sprites/cherry.png в текстуру узла Sprite2D. Установите HFrames в 5. Затем добавьте форму круга к CollisionShape2D и подгоните ее размер:

![Настройка сцены](/img/jungle-jump/B19289_04_11.jpg)


## Выбор размера столкновения

Как общее правило, вы должны размерировать формы столкновения так, чтобы они были выгодны для игрока. Это означает, что хитбоксы врагов должны быть немного меньше изображения, в то время как хитбоксы полезных предметов должны быть немного увеличены. Это снижает разочарование игрока и обеспечивает лучший игровой опыт.

Добавьте новую анимацию к AnimationPlayer (вам нужна только одна, поэтому вы можете назвать ее как угодно). Установите Length на 1,6 секунды, Snap на 0,2 секунды и Looping в положение on. Нажмите кнопку Autoplay on Load, чтобы анимация запускалась автоматически.

Установите свойство Frame узла Sprite2D на 0 и нажмите кнопку key, чтобы создать трек. Этот спрайт-лист содержит только половину анимации, поэтому анимация должна воспроизводить кадры в следующем порядке:

0 -> 1 -> 2 -> 3 -> 4 -> 3 -> 2 -> 1

Переместите ползунок к моменту времени 0,8 и установите ключевой кадр Frame на 4. Затем, установите ключевой кадр Frame 1 в момент времени 1,4. Установите Update Mode в Continuous и нажмите кнопку Play. У вас будет красиво анимированная вишня! Обратите внимание, что вы также можете перетащить изображение res://assets/sprites/coin.png в Texture, и это будет работать так же, поскольку у него такое же количество кадров. Это облегчит создание как вишен, так и самоцветов в вашей игре.


## Сценарий для собираемых предметов
Сценарий Item должен выполнять две задачи:

1. Устанавливать начальные условия (какую текстуру и позицию использовать).
2. Обнаруживать перекрытие с игроком.

Для первой части добавьте следующий код в ваш новый сценарий предмета:

```gd
extends Area2D
signal picked_up
var textures = {
    "cherry": "res://assets/sprites/cherry.png",
    "gem": "res://assets/sprites/gem.png"
}

func init(type, _position):
    $Sprite2D.texture = load(textures[type])
    position = _position
```

Вы будете вызывать сигнал picked_up, когда игрок соберет предмет. В словаре textures вы найдете список типов предметов и соответствующих файлов изображений. Обратите внимание, что вы можете быстро вставить эти пути в сценарий, перетащив файл из FileSystem и бросив его в редактор сценария.

Затем функция init() устанавливает текстуру и позицию. Сценарий вашего уровня будет использовать это для создания всех предметов, которые вы поместили на карту вашего уровня.

Наконец, подключите сигнал body_entered Item и добавьте этот код:

```gd
func _on_item_body_entered(body):
    picked_up.emit()
    queue_free()
```

Этот сигнал позволит основному сценарию игры реагировать на подбор предмета. Он может увеличивать счет, увеличивать здоровье игрока или применять любой другой эффект, который вы хотите применить к предмету.

Вы, возможно, заметили, что эти собираемые предметы устроены очень похоже на монеты из Coin Dash. Области очень полезны для любого типа предметов, где вам нужно знать, когда их касаются. В следующем разделе вы начнете создавать сцену уровня, чтобы размещать эти собираемые предметы.

## Дизайн уровня
Для большинства из вас этот раздел займет большую часть времени. Как только вы начнете проектировать уровень, вы обнаружите, что это весело – расставлять все элементы, создавать сложные прыжки, секретные пути и опасные встречи.

Сначала вы создадите общий сценарий Level, содержащий все узлы и код, общий для всех уровней. Затем вы можете создать любое количество сценариев Level, которые наследуются от этого основного уровня.

## Использование TileMap
Создайте новую сцену и добавьте узел Node2D с именем LevelBase. Сохраните сцену в новой папке с именем levels. Здесь вы будете сохранять все уровни, которые создадите, и все они будут наследовать функционал от этой сцены level_base.tscn. У них будет одна и та же иерархия узлов, только расположение будет разным.

TileMap - это распространенное средство для проектирования игровых окружений с использованием сетки тайлов. Они позволяют вам рисовать макет уровня, нанося тайлы на сетку, вместо того чтобы размещать много отдельных узлов поочередно. Они также более эффективны, потому что они объединяют все индивидуальные текстуры тайлов и формы столкновения в единый игровой объект.

Добавьте узел TileMap; внизу окна редактора появится новая панель TileMap. Обратите внимание, что там написано: "The edited TileMap has no TileSet resource" ("Редактируемый TileMap не имеет ресурса TileSet").

## О TileSet
Чтобы рисовать карту с использованием TileMap, ей должен быть назначен TileSet. Этот TileSet содержит все индивидуальные текстуры тайлов, а также любые формы столкновения, которые они могут иметь.

В зависимости от того, сколько у вас может быть тайлов, создание TileSet может потребовать много времени, особенно впервые. По этой причине в папке assets включены некоторые заранее сгенерированные тайлсеты. Вы можете использовать их, но прочитайте следующий раздел. В нем содержится полезная информация, чтобы вы поняли, как работает TileSet. Если вы предпочтете использовать предоставленные тайлсеты, перейдите к разделу Использование предоставленных TileSet.

## Создание TileSet
В Godot TileSet - это тип Ресурса. Примеры других ресурсов включают Текстуру, Анимацию и RectangleShape2D. Они не являются узлами; вместо этого они являются контейнерами, содержащими определенный тип данных и обычно сохраняются в файлах .tres.


Вот шаги для создания контейнера TileSet:

1. Нажмите "New TileSet" в области Tile Set TileMap. Теперь у вас появится доступная панель TileSet, которую вы можете выбрать внизу окна редактора. Вы можете нажать две стрелки вверх, чтобы сделать панель на весь экран редактора. Нажмите ее еще раз, чтобы уменьшить панель.

2. Вкладка Tiles слева в панели TileSet - это место, где вы можете поместить текстуры, которые вы хотите нарезать на тайлы. Перетащите res://assets/environment/tileset.png в это поле. Всплывет окно с запросом о том, хотите ли вы автоматически создать тайлы. Выберите "Yes". Вы увидите, что вокруг всех тайлов размером 16x16 пикселей на изображении нарисованы рамки:

   ![Добавление TileSet](/img/jungle-jump/B19289_04_13.jpg)

3. Попробуйте выбрать панель TileMap внизу, а затем выберите изображение блока с травой в верхнем левом углу тайлов. Затем щелкните в окне редактора, чтобы нарисовать несколько тайлов, нажимая левой кнопкой мыши. Вы можете щелкнуть правой кнопкой мыши по тайлу, чтобы его очистить:

   ![Рисование с использованием TileMaps](/img/jungle-jump/B19289_04_14.jpg)

4. Если все, что вам нужно, - это нарисовать фон, вы закончили. Однако вам также нужно добавить столкновения к этим тайлам, чтобы игрок мог стоять на них.

5. Откройте снова панель TileSet и в разделе Inspector найдите свойство PhysicsLayers и нажмите "Add Element":

   ![Добавление физического слоя в TileSet](/img/jungle-jump/B19289_04_15.jpg)

6. Поскольку эти тайлы будут в слое окружающей среды, вам не нужно изменять настройки слоя/маски.

7. Нажмите "Paint" в панели TileSet и в разделе "Paint Properties" выберите Physics Layer 0:

   ![Добавление столкновений к тайлам](/img/jungle-jump/B19289_04_16.jpg)

8. Начните щелкать по тайлам, чтобы добавить к ним стандартную квадратную форму столкновения. Если вы хотите отредактировать форму столкновения тайла, вы можете сделать это - щелкните по тайлу снова, чтобы применить изменения. Если вы застряли с формой, которая вам не нравится, нажмите три точки и выберите "Reset to default tile shape".

Вы также можете перетащить изображение props.png в список текстур для добавления декоративных элементов в ваш уровень.



Использование предоставленных наборов тайлов
В загруженных для этого проекта ресурсах уже предварительно настроенные наборы тайлов. Их три, и их нужно добавить к трем разным узлам TileMap:

- World – tiles_world.tres: Тайлы земли и платформ
- Items – tiles_items.tres: Маркеры для появления предметов
- Danger – tiles_spikes.tres: Предметы, которые наносят урон при столкновении
  Создайте TileMap-узлы Items и Danger и добавьте соответствующий набор тайлов к свойству Tile Set.

Добавьте экземпляр сцены Player и узел Marker2D с именем SpawnPoint. Вы можете использовать этот узел для обозначения места, где вы хотите, чтобы игрок начинал уровень.

Присоедините скрипт к узлу Level:

```gdscript
extends Node2D

func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
```

Позже вы будете сканировать карту Items, чтобы создавать предметы в указанных местах. Этот слой карты не должен быть виден, поэтому его можно скрыть в сцене. Тем не менее, легко забыть об этом, поэтому _ready() гарантирует, что он не будет виден во время игры.

Проектирование первого уровня
Теперь вы готовы начать рисовать уровень! Выберите Scene > New Inherited Scene и выберите level_base.tscn. Назовите корневой узел Level01 и сохраните его (в папку levels). Обратите внимание, что дочерние узлы окрашены в желтый цвет, что указывает на то, что они унаследованы от исходного уровня level_base.tscn. Если вы внесете изменения в этот исходный уровень, эти изменения также будут видны в этом уровне.

Начните с карты World и будьте творческими. Вам нравятся многочисленные прыжки, извилистые туннели для исследования? Длинные беги или осторожные восхождения вверх?

Прежде чем слишком углубляться в проектирование уровня, убедитесь, что вы экспериментируете с длиной прыжка. Вы можете изменить свойства движения игрока, такие как jump_speed, run_speed и gravity, чтобы изменить высоту и дальность прыжка. Настройте несколько разных размеров промежутков и запустите сцену, чтобы их опробовать. Не забудьте переместить узел SpawnPoint в то место, где вы хотите, чтобы игрок начал. Как вы настраиваете свойства движения игрока, сильно влияет на то, как должен быть оформлен ваш уровень. Удостоверьтесь, что вы довольны своими настройками, прежде чем тратить слишком много времени на полное проектирование..


Как только у вас будет готова карта World, используйте карту Items, чтобы отметить места, где вы хотели бы разместить вишни и драгоценные камни. Тайлы, отмечающие места появления, отрисованы с маджентовым фоном, чтобы выделяться. Помните, что они будут заменены во время выполнения, и сами тайлы не будут видны.

Как только ваш уровень будет готов, вы можете ограничить горизонтальную прокрутку камеры игрока, чтобы она соответствовала размеру карты (плюс небольшой буфер с каждого конца). Добавьте этот код в level_base.gd:

```gdscript
func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
    set_camera_limits()

func set_camera_limits():
    var map_size = $World.get_used_rect()
    var cell_size = $World.tile_set.tile_size
    $Player/Camera2D.limit_left = (map_size.position.x - 5) * cell_size.x
    $Player/Camera2D.limit_right = (map_size.end.x + 5) * cell_size.x
```

Сценарию также нужно просканировать карту Items и искать маркеры предметов. Сбор предметов добавит очки игроку, поэтому вы также можете добавить переменную для их отслеживания:

```gdscript
signal score_changed
var item_scene = load("res://items/item.tscn")
var score = 0: set = set_score

func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        var item = item_scene.instance()
        add_child(item)
        item.init(type, $Items.map_to_local(cell))
        item.picked_up.connect(self._on_item_picked_up)

func _on_item_picked_up():
    score += 1

func set_score(value):
    score = value
    score_changed.emit(score)
```

Функция spawn_items() использует get_used_cells(), чтобы получить список ячеек в TileMap, которые не являются пустыми. Эти ячейки находятся в _координатах карты_, а не в пиксельных координатах. Позднее, когда вы создадите предмет, вы сможете использовать map_to_local(), чтобы преобразовать значения.

Маркерные тайлы имеют слой пользовательских данных, прикрепленный к ним (аналогично слою физики, который вы добавили к тайлам мира), который указывает, какого они типа: gem (драгоценный камень) или cherry (вишня). Это затем используется для определения новому экземпляру, каким типом предмета он должен быть.

Переменная score предназначена для отслеживания количества предметов, собранных игроком. Вы можете использовать это для завершения уровня, предоставления бонусов и так далее.

Добавьте spawn_items() в _ready() и попробуйте запустить уровень. Вы должны увидеть, что гемы и вишни появляются в тех местах, где вы их разместили. Также проверьте, что они исчезают, когда вы их собираете.

## Слой опасности (Danger)
Слой опасности (Danger) на карте предназначен для размещения объектов в виде шипов, которые нанесут урон игроку при соприкосновении. Любой тайл на этой TileMap вызовет урон игроку! Попробуйте разместить несколько из них там, где вы сможете легко их протестировать.

Во вкладке Node добавьте TileMap опасности в группу с названием "danger", чтобы вы могли легко идентифицировать ее при столкновении. Это также позволит вам создавать другие опасные объекты, добавляя их в ту же группу.

## О коллизиях со скольжением

Когда узел CharacterBody2D перемещается с помощью move_and_slide(), он может столкнуться с более чем одним объектом в том же движении кадра. Например, при столкновении с углом тело может одновременно удариться о стену и пол. Вы можете использовать функцию get_slide_collision_count() для определения количества коллизий; затем вы можете получить информацию о каждой коллизии с помощью get_slide_collision().

В случае с игроком вы хотите обнаружить столкновение с TileMap опасности. Вы можете сделать это сразу после использования move_and_slide() в файле player.gd:

```gdscript
if state == HURT:
    return
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()
```

Обратите внимание, что перед проверкой столкновения с группой опасности вы можете сначала проверить, находится ли игрок уже в состоянии HURT. Если это так, вы можете пропустить проверку того, сталкивается ли он с опасным объектом.

Цикл for перебирает количество столкновений, заданное get_slide_collision_count(), чтобы проверить каждое из них на наличие объекта в группе опасности.

Воспроизведите вашу сцену и попробуйте столкнуться с одним из шипов. Вы должны увидеть, что игрок переходит в состояние HURT (воспроизводится анимация) на короткое время, прежде чем вернуться к состоянию IDLE. После трех ударов игрок войдет в состояние DEAD, которое в настоящее время просто скрывает игрока.

В папке res://assets/environment/ есть два фоновых изображения: back.png и middle.png для дальнего и ближнего фона соответственно. Разместив эти изображения за тайлмапом и прокручив их с разной скоростью относительно камеры, вы можете создать привлекательную иллюзию глубины в фоне:
::list
 - Добавьте узел ParallaxBackground к сцене LevelBase (чтобы он присутствовал во всех унаследованных уровнях). Этот узел взаимодействует с камерой, создавая эффект прокрутки. Перетащите этот узел в верхнюю часть дерева сцены, чтобы он рисовался за остальными узлами. Затем добавьте узел ParallaxLayer в качестве его дочернего элемента. У ParallaxBackground может быть любое количество дочерних узлов ParallaxLayer, что позволяет создавать несколько независимых прокручиваемых слоев.
 - Добавьте узел Sprite2D в качестве дочернего элемента ParallaxLayer и перетащите изображение back.png в его область Texture. Убедитесь, что свойство Offset/Centered не отмечено, чтобы изображение располагалось относительно начала экрана. Также увеличьте масштаб узла Sprite2D, установив Scale равным (1.5, 1.5).
 - На ParallaxLayer установите Motion/Scale в (0.2, 1) (вам придется щелкнуть значок ссылки, чтобы разрешить установку значений x и y отдельно). Эта настройка контролирует скорость прокрутки фона относительно движения камеры. Установив ее менее 1, изображение будет перемещаться незначительно при движении игрока влево и вправо.
 - Убедитесь, что изображение повторяется, если ваш уровень шире размера изображения, поэтому установите Motion/Mirroring в (576, 0). Это точно ширина изображения (384 умножить на 1.5), поэтому изображение будет повторяться, когда оно переместится на эту величину в пикселях.
 - Обратите внимание, что это изображение задумано для уровней, которые шире, чем высоки. Если вы прыгнете слишком высоко, вы увидите верхнюю часть изображения. Вы можете исправить это, установив верхний предел камеры. Если вы не переместили позицию фона, его верхний левый угол все равно будет в точке (0, 0), поэтому вы можете установить верхний предел камеры в 0. Если вы переместили ParallaxLayer или его узел Sprite2D, вы можете найти правильное значение, посмотрев на значение y позиции узла.
 - Попробуйте запустить уровень и перемещаться влево и вправо. Вы должны увидеть, что фон двигается незначительно по сравнению с тем, как далеко вы бежите.
 - Добавьте еще один узел ParallaxLayer (также в качестве дочернего для ParallaxBackground) и добавьте ему дочерний узел Sprite2D. На этот раз используйте изображение middle.png. Это изображение значительно уже, чем изображение неба, поэтому вам нужно настроить некоторые параметры для правильного повторения. Это связано с тем, что ParallaxBackground должен иметь изображения, по крайней мере, такие же большие, как область видимости.
 - Найдите свойство Texture/Repeat у узла Sprite2D в разделе CanvasItem и установите его значение на Mirror. Затем разверните раздел Region и убедитесь, что включена опция Enabled. В разделе Rect установите ширину и высоту равными (880, 368). 880 - это ширина изображения (176), умноженная на 5, поэтому теперь вы увидите пять повторений изображения, каждое зеркальное предыдущему.
 - Переместите узел Sprite2D так, чтобы изображение перекрывалось нижней половиной изображения океана/неба: !()[/img/jungle-jump/B19289_04_17.jpg] 
 - Установите параметр Motion/Scale второго узла ParallaxLayer на (0.6, 1), а параметр Motion/Mirroring на (880, 0). Использование более высокого коэффициента масштабирования означает, что этот слой будет прокручиваться немного быстрее слоя облаков за ним. Воспроизведите сцену, чтобы протестировать эффект.
::

Дерево узлов вашей сцены уровня теперь должно выглядеть следующим образом:
![Фильтрация текстур](/img/jungle-jump/B19289_04_18.jpg)

Ваша сцена уровня теперь имеет все необходимые элементы для создания дизайна уровня. Хотите, чтобы ваш игрок должен был делать очень точные прыжки (уровень паркура), пробегать через серию извилистых проходов, пытаясь найти все предметы (уровень лабиринта) или какое-то сочетание обоих? Это ваш шанс попробовать некоторые креативные идеи, но убедитесь, что вы оставляете место для следующего объекта, который вы создадите: врагов.

## Добавление врагов
Есть много различных поведений, которые можно добавить для врага. В этой игре враг будет идти по платформе в прямой линии и изменять направление при столкновении с препятствием.

## Настройка сцены
Как и раньше, вам нужно создать новую сцену для представления врага:


::list
  -  Начните с узла CharacterBody2D с именем Enemy и добавьте три дочерних узла: Sprite2D, CollisionShape2D и AnimationPlayer.
  -  Сохраните сцену в папку с именем enemies. Если вы решите добавить больше типов врагов в игру, вы можете сохранить их все здесь.
  -  Установите слой столкновения тела врага на enemies, а Маску на environment, player и enemies. Как и в случае с игроком, это определяет с какими типами объектов враг будет сталкиваться.
  -  Также полезно группировать врагов вместе, поэтому перейдите во вкладку Node и добавьте тело в группу с именем enemies.
  -  Добавьте res://assets/sprites/opossum.png в текстуру и установите Animation/Hframes в 6.
  -  Добавьте прямоугольную форму столкновения, которая покрывает большую часть (но не всю) изображения, убедившись, что нижняя часть формы столкновения выровнена с нижней частью ног опоссума:![опоссум](/img/jungle-jump/B19289_04_19.jpg)
  - Добавьте новую анимацию в AnimationPlayer с именем walk. Установите Длительность на 0,6 секунды и включите Петля и Автовоспроизведение при загрузке. 
  - У анимации walk должно быть две дорожки: одна, которая устанавливает свойство Texture узла Sprite2D, и другая, которая изменяет свойство Frame. Нажмите на значок ключа рядом с Texture, чтобы добавить первую дорожку, затем добавьте ключевые кадры для Frame 0 в момент времени 0 и Frame 5 в момент времени 0,5. Не забудьте изменить Режим обновления на Continue.
::

По завершении ваша анимация должна выглядеть так:

![Aнимация](/img/jungle-jump/B19289_04_20.jpg)

