# Создание сцены

Для первой сцены добавьте узел Node3D с именем "Hole" и сохраните сцену. Как вы делали в Jungle Jump, вы создадите общую сцену, содержащую все узлы и код, которые будут нужны для любой лункы, а затем унаследуетесь от этой сцены, чтобы создать столько индивидуальных лунок, сколько вам понадобится для игры.

Далее добавьте узел GridMap в сцену.

## Понимание GridMap
GridMap - это трехмерный аналог узла TileMap, который вы использовали ранее в книге. Он позволяет использовать коллекцию сеток (содержащихся в коллекции MeshLibrary - аналогично TileSet) и размещать их в сетке. Поскольку он работает в 3D, вы можете складывать сетки в любом направлении, хотя для этого проекта вы ограничитесь одной плоскостью.

### Создание коллекции MeshLibrary
В папке res://assets/ вы найдете предварительно созданную функцию MeshLibrary под названием golf_tiles.tres, содержащую все необходимые части поля вместе с их формами столкновений.

Чтобы создать свою собственную коллекцию MeshLibrary, вы создадите трехмерную сцену, содержащую отдельные меши, которые вы хотите использовать, добавите к ним коллизии, а затем экспортируете эту сцену в коллекцию MeshLibrary. Если вы откроете golf_tiles.tscn, вы увидите исходную сцену, которая использовалась для создания golf_tiles.tres.

В этой сцене вы увидите все отдельные меши дорожек для мини-гольфа, так как они были импортированы из Blender, где они изначально моделировались. Чтобы добавить формы столкновений к каждому из них, Godot имеет удобную функцию: выберите меш и вы увидите меню Mesh в панели инструментов в верхней части видового окна:

![Меню Mesh](/img/mini-golf/12.jpg)

Выберите "Create Trimesh Static Body", и Godot добавит узел StaticBody3D вместе с узлом CollisionShape3D, используя данные меша.

Когда все коллизии добавлены, вы можете выбрать Сцена -> Экспортировать как -> Библиотека Мешей, чтобы преобразовать сцену в Ресурс, который может использовать GridMap.

## Чертим первую лунку

Перетащите файл библиотеки мешей в свойство **Mesh Library** узла GridMap. Вы увидите список доступных тайлов появится справа от видового окна редактора.

Чтобы соответствовать размеру тайлов, установите **Cell/Size** в (1, 1, 1).

Чтобы убедиться, что столкновения с мячом будут выглядеть хорошо, найдите **Physics Material**  и установите его параметр **Rough** в On и **Bounce** в 0.5:

![Работа с физическим материалом](/img/mini-golf/13.jpg)

Попробуйте нарисовать, выбрав кусок плитки из списка и поместив его на сцену, щелкнув левой кнопкой мыши. Вы можете вращать кусок вокруг оси **y**, нажимая **S**. Чтобы удалить плитку, щелкните правой кнопкой мыши на ней. Пока придерживайтесь простого макета. Вы сможете придумать что-то более замысловатое позже, когда всё будет работать:

![Пример макета](/img/mini-golf/14.jpg)

Вы можете оценить, как это будет выглядеть, когда игра будет запущена. Добавьте функцию Camera3D на сцену и переместите её в позицию, с которой она сможет смотреть на поле сверху. Помните, что вы можете нажать "Предварительный просмотр", чтобы проверить, что видит камера.

Запустите сцену. Вы заметите, что всё очень тёмное, в отличие от того, как это выглядит в окне редактора. По умолчанию в трехмерной сцене не настроены окружающая среда или освещение.

Окружение и освещение
Освещение - это сложная тема сама по себе. Выбор местоположения и настройка освещения могут радикально изменить внешний вид сцены.

Godot предоставляет три узла освещения в 3D:
- OmniLight3D: для света, который излучается во всех направлениях, например, от лампочки
- DirectionalLight3D: свет от дальнего источника, например, солнечного света
- SpotLight3D: конусообразный свет, излучаемый из точки, аналогичный фонарику или фонарю

Помимо размещения отдельных источников света, вы также можете настроить окружающий свет - свет, создаваемый окружающей средой - с помощью узла WorldEnvironment.

Вместо того чтобы начинать с нуля, Godot позволяет вам начать с настройки освещения по умолчанию, которую вы видите в окне редактора, с помощью кнопок на панели инструментов:

![ Настройки освещения и окружения](/img/mini-golf/15.jpg)


Первые две кнопки позволяют включить или выключить предварительный просмотр солнца (направленного света) и окружения. Обратите внимание, что окружение влияет не только на освещение, но и генерирует текстуру неба.

Если вы нажмете на три точки, вы увидите настройки по умолчанию для них. Нажмите кнопку "Добавить", чтобы добавить их в качестве узлов в вашу сцену. Теперь у вас будет узел **WorldEnvironment** и узел **DirectionalLight3D** в вашей сцене.

Если вы увеличите масштаб меша, вы можете заметить, что тени выглядят не очень хорошо. Настройки теней по умолчанию нужно скорректировать, поэтому выберите узел **DirectionalLight3D** и измените максимальное расстояние с 100 на 40.

# Добавление лунки
Теперь, когда у вас есть размеченное поле, вам нужен способ обнаружить, когда мяч попадает в лунку.

Добавьте узел **Area3D** с именем "Hole". Этот узел работает точно так же, как его версия 2D - он может сигнализировать, когда тело входит в его определенную форму. Добавьте дочерний узел CollisionShape3D к области. В свойстве Shape выберите New CylinderShape3D и установите его высоту на 0.25, а радиус на 0.08.

Разместите "Hole" там, где вы разместили плитку лунки на вашем поле. Убедитесь, что цилиндрическая форма не выступает за верх лунки, иначе мяч будет считаться **in(внутри)**, когда он на самом деле еще не упал в нее. Вам может быть полезно использовать кнопку **Perspective (Перспектива)** и переключиться в режим **Top view (Вид сверху)**, чтобы убедиться, что вы правильно центрировали узел:


![Позиционирование лунки](/img/mini-golf/16.jpg)

Также вам нужно отметить стартовую позицию для мяча, поэтому добавьте узел Marker3D с именем "Tee" на сцену. Разместите его там, где вы хотите, чтобы мяч начинал движение. Убедитесь, что вы размещаете его над поверхностью, чтобы мяч не появлялся внутри земли.

С этим завершено создание первого курса. Посмотрите вокруг на несколько минут, чтобы убедиться, что вы довольны макетом. Помните, что это не должен быть сложный или вызывающий сложности макет. Он предназначен для знакомства игрока с игрой, и вы будете использовать его для проверки того, что всё работает правильно позже. Для этого следующим шагом будет создание гольф-мяча.

# Создание мяча
Поскольку мячу нужна физика - гравитация, трение, столкновение с стенами и так далее - *RigidBody3D* будет лучшим выбором узла. Твердые тела работают аналогично в 3D, как вам уже известно из 2D, и вы будете использовать те же методы для взаимодействия с ними, такие как `_integrate_forces()` и `apply_impulse()`.

Создайте новую сцену с узлом **RigidBody3D** под названием **Ball** и сохраните её.

Так как вам нужна простая сфера, а Godot включает примитивные фигуры, здесь нет необходимости в сложной 3D-модели.

Добавьте дочерний узел **MeshInstance3D** и выберите **New Sphere Mesh** для свойства **Mesh** в инспекторе.

Размер по умолчанию слишком велик, поэтому нажмите на свойство **Mesh**, чтобы развернуть его, и установите **Radius** на *0.05*, а **Height** на *0.1*.

Добавьте узел **CollisionShape3D** и укажите ему **SphereShape3D**. Установите для его параметра **Radius** значение 0.05, чтобы он соответствовал мешу.


## Тестирование мяча

Добавьте экземпляр сцены **Ball** на ваш уровень. Разместите его над одной из плиток и запустите сцену. Вы должны увидеть, как мяч падает и приземляется на землю.

Вы также можете временно придать мячу некоторое движение, установив свойство **Linear/Velocity**. Попробуйте установить для него разные значения и запустить сцену. Помните, что ось Y направлена вверх. Не забудьте установить его обратно на *(0, 0, 0)* прежде чем продолжить.

## Улучшение столкновений мяча

Возможно, вы заметили при настройке скорости, что мяч иногда проходит сквозь стену и/или странно отскакивает, особенно если вы выбираете высокое значение скорости. Есть несколько вещей, которые вы можете сделать, чтобы улучшить поведение мяча.

Во-первых, вы можете использовать непрерывное обнаружение столкновений (continuous collision detection-CCD). Использование CCD изменяет способ, которым физический движок рассчитывает столкновения. Обычно движок сначала перемещает объект, а затем проверяет и разрешает столкновения. Это быстрый способ, который подходит для большинства ситуаций. При использовании CCD движок проецирует движение объекта по его траектории и пытается предсказать, где может произойти столкновение. Это медленнее (с точки зрения вычислений), чем поведение по умолчанию, особенно при моделировании большого количества объектов, но оно намного точнее. Поскольку у вас всего один мяч в очень маленькой среде, CCD является хорошим вариантом, поскольку он не приведет к заметному снижению производительности. Вы можете найти его в инспекторе как **Continuous CD**: 

![Переключатель CCD](/img/mini-golf/5.17.jpg)

Рисунок 5.17: Переключатель CCD

Чтобы мяч немного отскакивал, в свойствах **Physics Material** (Материал физики) выберите **New** (Новый) и установите значение **Bounce** (Прыгучесть) на 0.25. Этот параметр определяет, насколько упругим будет столкновение. Значение может варьироваться от 0 (никакого отскока) до 1.0 (максимальный отскок).

![Настройки отскока материала физики](/img/mini-golf/5.18.jpg)

Рисунок 5.18: Настройки отскока материала физики

Вы также могли заметить, что мячу требуется много времени, чтобы полностью остановиться. Установите для свойств **Linear/Damp** (Линейное/Затухание) значение 0.5 и **Angular/Damp** (Угловое/Затухание) значение 1. Эти значения можно рассматривать как аналогичные сопротивлению воздуха, заставляющие объект замедляться независимо от взаимодействия с поверхностью. Увеличение этих значений означает, что игроку не придется долго ждать, пока мяч перестанет двигаться, и он не будет казаться вращающимся на месте после остановки качения.

Вы закончили настройку мяча, но это еще одно хорошее место, чтобы остановиться и убедиться, что все так, как вы хотите, прежде чем двигаться дальше. Отскакивает ли мяч и катится правдоподобно? Когда он ударяется о стену, он отскакивает слишком сильно или слишком слабо?  

После того, как вы отрегулировали поведение мяча по своему вкусу, перейдите к следующему разделу, где вы узнаете, как запускать мяч.


## Добавление интерфейса

Теперь, когда мяч находится на поле, вам нужен способ прицелиться и ударить по нему. Существует множество возможных схем управления для игр такого типа. В этом проекте вы будете использовать двухэтапный процесс:

1. **Aim**(Прицеливание): Появляется стрелка, качающаяся вперед-назад. Щелчок мышью устанавливает направление прицеливания.
2. **Shoot**(Удар): Силовая шкала движется вверх и вниз. Щелчок мышью устанавливает силу удара и запускает мяч.

## Прицеливание стрелкой

Рисовать объект в 3D не так просто, как в 2D. Во многих случаях вам придется переключиться на 3D-редактор, например **Blender**, чтобы создавать объекты игры. Однако в данном случае примитивов Godot будет достаточно. Чтобы сделать стрелку, вам нужны две сетки: длинный тонкий прямоугольник и треугольная призма.

## Создание собственной модели

Если вам удобно использовать отдельную программу 3D-моделирования, такую ​​как Blender, вы можете использовать ее для создания сетки стрелки вместо того, чтобы следовать следующей процедуре. Просто переместите экспортированную модель в папку вашего проекта Godot и загрузите ее с помощью узла **MeshInstance3D**. Подробности импорта моделей непосредственно из Blender см. в последней главе.

Создайте новую сцену, добавив узел **Node3D** под названием **Arrow** (Стрелка).Добавьте к узлу **Arrow** дочерний узел **MeshInstance3D**. Назначьте для свойства **Mesh** этого узла функцию **BoxMesh** (Коробка). Установите для параметра **Size** (Размер) сетки значение (0.5, 0.2, 2).Это будет тело стрелки. 

Однако есть проблема. Если вы повернете родительский узел, сетка будет вращаться вокруг своего центра. Нам нужно, чтобы она вращалась вокруг своего конца.

Для этого измените параметр **Position** (Позиция) узла **MeshInstance3D** на (0, 0, -1). Помните, что это свойство измеряется относительно родительского узла, поэтому данное значение смещает сетку относительно узла **Node3D**.

Значение (0, 0, -1) смещает сетку на одну единицу по оси Z в отрицательном направлении, фактически размещая ее в "конце" **Node3D** относительно его локальной системы координат.

Это гарантирует, что при вращении **Node3D** сетка (выступающая в роли тела стрелки) будет вращаться вокруг своего нижнего конца, создавая желаемый эффект прицеливания.


![ Смещение основания](/img/mini-golf/5.19.jpg)

Рисунок 5.19: Смещение основания

Попробуйте повернуть корневой узел (Arrow) с помощью gizmo (манипулятор), чтобы убедиться, что фигура теперь смещена правильно.

В игре стрелка должна быть полупрозрачной. Вы также можете придать ей цвет, чтобы она выделялась. Чтобы изменить визуальные свойства сетки, вам нужно использовать **Material** (Материал).

Под свойствами сетки (где вы устанавливаете размер) вы увидите свойство **Material**, которое сейчас пустое. Щелкните стрелку, чтобы создать в этом поле новый узел **StandardMaterial3D**:


![Смещение основания](/img/mini-golf/5.20.jpg)

Рисунок 5.20: Смещение основания

Щелкните **New StandardMaterial3D** (новый объект материала), чтобы развернуть его. Вы увидите длинный список новых свойств. Не волнуйтесь, вам нужно изменить только два из них.

Сначала разверните раздел Transparency (Прозрачность) и установите для параметра **Transparency** значение **Alpha**. Это свойство сообщает движку рендеринга, что этот объект может пропускать свет.

Цвет объекта устанавливается в разделе **Albedo** . Щелкните свойство **Color** (Цвет) и выберите желтоватый цвет. 
Обязательно установите для параметра **Alpha** значение примерно посередине, например 128. 

Теперь, чтобы создать острый конец стрелки, добавьте еще один узел **MeshInstance3D** и на этот раз выберите сетку **PrismMesh**.

Установите для параметра **Size** значение (1.5, 1.5, 0.2), чтобы получить плоскую треугольную форму.

Чтобы разместить его на конце прямоугольника, измените его параметр **Position** (Позиция) на (0, 0, -2.75) и параметр **Rotation** (Вращение) на (-90, 0, 0).

Наконец, уменьшите всю стрелку, установив для параметра **Scale** (Масштаб) корневого узла значение (0.25, 0.25, 0.25).

Вам также нужно установить материал призмы так же, как вы это сделали с другой частью. Чтобы сделать это быстро, выберите прямоугольную форму и снова найдите ее свойство материала. В раскрывающемся списке материала выберите **Copy** (Копировать). Затем вы можете перейти к призме и применить тот же материал к ней. Обратите внимание, что поскольку у них одинаковый материал, любое изменение, которое вы внесете в одну фигуру, будет применяться к обеим фигурам.

![ Размещение стрелки](/img/mini-golf/5.21.jpg)

Рисунок 5.21: Размещение стрелки

На этом создание прицельной стрелки завершено. Сохраните сцену и добавьте ее экземпляр в сцену **Hole**.


## Отображение интерфейса

Создайте новую сцену с использованием слоя **CanvasLayer** под названием **UI**. В этой сцене вы будете показывать индикатор силы удара, а также количество сделанных бросков для подсчета очков игрока. 

Так же, как это было в **2D**, этот узел будет рисовать свое содержимое поверх основной игровой 3D-сцены.

Добавьте в сцену узел Label. Этот узел будет использоваться для отображения количества бросков. Добавьте узел **MarginContainer** в качестве дочернего элемента к **CanvasLayer**. Этот узел помогает организовать и расположить другие элементы интерфейса с полями вокруг них.

Внутри **MarginContainer** добавьте узел **VBoxContainer**. Этот контейнер вертикально размещает свои дочерние элементы один под другим.

Внутри **VBoxContainer** добавьте два узла Label. Один будет отображать текст "Количество бросков", а другой - фактическое значение количества бросков.

Наконец, добавьте в **VBoxContainer** узел **TextureProgressBar**.  Этот узел будет представлять собой индикатор силы удара, который заполняется по мере того, как игрок заряжает бросок.

![ Разметка узла интерфейса](/img/mini-golf/5.22.jpg)


Рисунок 5.22: Разметка узла интерфейса


В разделе **MarginContainer** установите **Theme Overrides/Constants** (Темы/Переопределения/Константы) на 20. Добавьте шрифт** Xolonium-Regular.ttf** к обоим узлам **Label** и установите их размер шрифта на 30. Установите значение **Text** (Текст) для **Shots** (Броски) на Shots: 0 (Броски: 0) и для PowerLabel (Сила) на Power (Сила).

Добавьте шрифт для метки сообщения, используя больший размер шрифта - 80, и установите его текст на **Get Ready!**(Приготовься!).

Выберите **Center** (По центру) из меню **Anchor Presets**(Якорные предустановки), затем нажмите на значок глаза рядом с сообщением, чтобы скрыть его.

Перетащите одну из цветных текстур полосы из `res://assets` в раздел **Texture/Progress** (Текстура/Прогресс) PowerBar (Индикатор силы).

По умолчанию **TextureProgressBar** заполняется слева направо, поэтому для вертикальной ориентации измените Fill Mode (Режим заполнения) на Bottom to Top (Снизу вверх). Измените значение **Value** (Значение) на несколько разных значений, чтобы увидеть результат.

Завершенная разметка интерфейса должна выглядеть следующим образом (на рисунке 5.23).

![Предварительный просмотр интерфейса](/img/mini-golf/5.23.jpg)

Рисунок 5.23: Предварительный просмотр интерфейса


Добавьте экземпляр **UI** в сцену **Hole**.Поскольку UI использует **CanvasLayer**, он будет отрисован поверх 3D-вида камеры.

Теперь, когда вы закончили отрисовку поля и добавили интерфейс, у вас есть все визуальные элементы, которые игрок будет видеть во время игры. Ваша следующая задача - заставить эти части работать вместе, добавив немного кода.