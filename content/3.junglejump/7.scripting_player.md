# Код игрока

Начнем с выбора узла AnimationPlayer игрока и добавления новой анимации с именем climb. Ее длина должна быть 0.4, и ей следует установить цикл. Значения кадров для Sprite2D: 0 -> 1 -> 0 -> 2.

Перейдите в player.gd и добавьте новое состояние CLIMB в перечисление состояний. Кроме того, добавьте два новых объявления переменных в верхней части сценария:

```gdscript
@export var climb_speed = 50
var is_on_ladder = false
```

Используйте переменную `is_on_ladder`, чтобы отслеживать, находится ли игрок на лестнице или нет. Используя эту переменную, вы можете решить, должны ли действия вверх и вниз иметь какой-либо эффект.

В методе `change_state()` добавьте условие для нового состояния:

```gdscript
CLIMB:
    $AnimationPlayer.play("climb")
```

В методе `get_input()` вам нужно проверить входные действия, а затем определить, изменяют ли они состояние:

```gdscript
var up = Input.is_action_pressed("climb")
var down = Input.is_action_pressed("crouch")
if up and state != CLIMB and is_on_ladder:
    change_state(CLIMB)
if state == CLIMB:
    if up:
        velocity.y = -climb_speed
        $AnimationPlayer.play("climb")
    elif down:
        velocity.y = climb_speed
        $AnimationPlayer.play("climb")
    else:
        velocity.y = 0
        $AnimationPlayer.stop()
if state == CLIMB and not is_on_ladder:
    change_state(IDLE)
```

Здесь у вас три новых условия для проверки. Во-первых, если игрок не находится в состоянии CLIMB, но находится на лестнице, то нажатие вверх должно заставить игрока начать карабкаться. Во-вторых, если игрок в настоящее время карабкается, то ввод вверх и вниз должен заставить их двигаться вверх и вниз по лестнице, но остановить воспроизведение анимации, если ни одно действие не нажато. Наконец, если игрок покидает лестницу во время восхождения, он выходит из состояния CLIMB.

Также вам нужно убедиться, что гравитация не тянет игрока вниз, когда он находится на лестнице. Добавьте условие в код гравитации в `_physics_process()`:

```gdscript
if state != CLIMB:
    velocity.y += gravity * delta

```


Добавьте узел Area2D с именем Ladders в сцену уровня, но пока не добавляйте ему форму столкновения. Подключите его сигналы body_entered и body_exited и установите его слой столкновения на items и маску на player. Это гарантирует, что только игрок может взаимодействовать с лестницей. Эти сигналы - это способ сообщить игроку, находится он на лестнице или нет:

```gdscript
func _on_ladders_body_entered(body):
    body.is_on_ladder = true

func _on_ladders_body_exited(body):
    body.is_on_ladder = false
```

Теперь уровню нужно искать любые плитки лестницы и добавлять формы столкновения к узлу Ladders при их обнаружении. Добавьте следующую функцию в level.gd и вызовите ее в _ready():

```gdscript
func create_ladders():
    var cells = $World.get_used_cells(0)
    for cell in cells:
        var data = $World.get_cell_tile_data(0, cell)
        if data.get_custom_data("special") == "ladder":
            var c = CollisionShape2D.new()
            $Ladders.add_child(c)
            c.position = $World.map_to_local(cell)
            var s = RectangleShape2D.new()
            s.size = Vector2(8, 16)
            c.shape = s
```

Обратите внимание, что добавляемые вами формы столкновения имеют ширину всего 8 пикселей. Если сделать форму полной ширины плитки лестницы, то игрок будет выглядеть так, будто он карабкается, даже когда он свисает с боковой стороны, что выглядит немного странно.

Попробуйте это – перейдите в одну из ваших сцен уровня и разместите плитки лестницы в любом месте вашей карты мира. Запустите сцену и попробуйте подняться по лестницам.

Обратите внимание, что если вы находитесь в верхней части лестницы и на нее вступаете, вы упадете вниз, а не будете подниматься вниз (хотя нажатие вверх, падая, заставит вас зацепить лестницу). Если вы предпочитаете автоматический переход в состояние взбирания при падении, вы можете добавить дополнительную проверку на падение в _physics_process():

Подвижные платформы
Подвижные платформы – это интересное дополнение к вашему инструментарию для создания уровней. В этом разделе вы создадите подвижную платформу, которую можно разместить в любом месте вашего уровня и настроить её движение и скорость.

Начните с создания новой сцены с узлом Node2D и назовите её MovingPlatform. Сохраните сцену и добавьте к ней дочерний узел TileMap. Поскольку все изображения для вашей платформы находятся в спрайт-листах и уже были разделены на тайлы с добавленными коллизиями, это упростит процесс рисования платформы. Добавьте tiles_world.tres в качестве тайлсета. Также необходимо отметить флажок Collision Animatable, чтобы убедиться, что коллизии будут корректно работать даже во время движения.

Нарисуйте несколько тайлов в TileMap, но убедитесь, что начинаете с начала координат (0, 0), чтобы всё выглядело аккуратно. Эти тайлы отлично подходят для плавающей платформы:


![Плавающая платформа](/img/jungle-jump/B19289_04_28.jpg)


Добавьте скрипт к корневому узлу и начните с этими переменными:

```gdscript
@export var offset = Vector2(320, 0)
@export var duration = 10.0
```

Эти переменные позволят вам задать величину и скорость движения. offset относится к начальной точке, и поскольку это узел Vector2, вы можете создавать платформы, двигающиеся горизонтально, вертикально или по диагонали. duration измеряется в секундах и представляет собой время полного цикла.

Платформа всегда будет находиться в движении, поэтому вы можете начать анимацию в _ready(). Она будет использовать метод tween для анимации позиции в два этапа: от начальной позиции до позиции offset и обратно:

```gdscript
func _ready():
    var tween = create_tween().set_process_mode(
        Tween.TWEEN_PROCESS_PHYSICS)
    tween.set_loops().set_parallel(false)
    tween.tween_property($TileMap, "position", offset,
        duration / 2.0).from_current()
    tween.tween_property($TileMap, "position",
        Vector2.ZERO, duration / 2.0)
```

Вот несколько замечаний об использовании tween:

- Необходимо установить режим процесса, чтобы движение синхронизировалось с физикой, и игрок мог корректно взаимодействовать с платформой (то есть, стоять на ней).
- set_loops() сообщает tween, что нужно повторить анимацию после завершения.
- set_parallel(false) говорит tween выполнить две анимации свойств последовательно, а не одновременно.
- Вы также можете экспериментировать с другими кривыми анимации. Например, добавление tween.set_trans(Tween.TRANS_SINE) заставит платформу замедляться в конце движения для более естественного вида. Попробуйте поэкспериментировать с другими типами переходов.

Теперь вы можете добавить экземпляры MovingPlatform в сцену уровня. Чтобы убедиться, что все правильно выравнивается, убедитесь, что включена привязка к сетке:

![Включение привязки к сетке](/img/jungle-jump/B19289_04_30.jpg)

Значение по умолчанию - (8, 8), но вы можете изменить его, нажав три точки рядом с значком и выбрав "Configure Snap".

Когда вы запустите игру, у вас будет намного больше элементов для взаимодействия. Лестницы и подвижные платформы предоставляют вам множество возможностей для создания уровней. Но это еще не все! Учитывая все, что вы сделали в этой главе, существует множество других функций, которые вы можете добавить. У анимации игрока есть анимация "приседания" - а если бы враги могли бросать вещи в игрока, которые можно было бы уклониться? Многие игры платформера включают дополнительные механики движения, такие как скольжение по наклонным поверхностям, прыжки от стен, изменение гравитации и многое другое. Выберите одну из них и посмотрите, сможете ли вы ее добавить.