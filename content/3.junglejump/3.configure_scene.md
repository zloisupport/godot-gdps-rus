# Настройка сцены
Начните новую сцену с Area2D и назовите ее Item. Сохраните сцену в новой папке items.

Область - хороший выбор для этих объектов, потому что вы хотите определить, когда с ними контактирует игрок, но вам не нужен ответ на столкновение от них. В инспекторе установите Collision/Layer на collectibles (слой 4) и Collision/Mask на player (слои 2). Это обеспечит возможность собирать их только игроку, в то время как враги будут проходить сквозь них.

Добавьте три дочерних узла: Sprite2D, CollisionShape2D и AnimationPlayer. Перетащите res://assets/sprites/cherry.png в текстуру узла Sprite2D. Установите HFrames в 5. Затем добавьте форму круга к CollisionShape2D и подгоните ее размер:

![Настройка сцены](/img/jungle-jump/B19289_04_11.jpg)


## Выбор размера столкновения

Как общее правило, вы должны размерировать формы столкновения так, чтобы они были выгодны для игрока. Это означает, что хитбоксы врагов должны быть немного меньше изображения, в то время как хитбоксы полезных предметов должны быть немного увеличены. Это снижает разочарование игрока и обеспечивает лучший игровой опыт.

Добавьте новую анимацию к AnimationPlayer (вам нужна только одна, поэтому вы можете назвать ее как угодно). Установите Length на 1,6 секунды, Snap на 0,2 секунды и Looping в положение on. Нажмите кнопку Autoplay on Load, чтобы анимация запускалась автоматически.

Установите свойство Frame узла Sprite2D на 0 и нажмите кнопку key, чтобы создать трек. Этот спрайт-лист содержит только половину анимации, поэтому анимация должна воспроизводить кадры в следующем порядке:

0 -> 1 -> 2 -> 3 -> 4 -> 3 -> 2 -> 1

Переместите ползунок к моменту времени 0,8 и установите ключевой кадр Frame на 4. Затем, установите ключевой кадр Frame 1 в момент времени 1,4. Установите Update Mode в Continuous и нажмите кнопку Play. У вас будет красиво анимированная вишня! Обратите внимание, что вы также можете перетащить изображение res://assets/sprites/coin.png в Texture, и это будет работать так же, поскольку у него такое же количество кадров. Это облегчит создание как вишен, так и самоцветов в вашей игре.


## Сценарий для собираемых предметов
Сценарий Item должен выполнять две задачи:

1. Устанавливать начальные условия (какую текстуру и позицию использовать).
2. Обнаруживать перекрытие с игроком.

Для первой части добавьте следующий код в ваш новый сценарий предмета:

```gd
extends Area2D
signal picked_up
var textures = {
    "cherry": "res://assets/sprites/cherry.png",
    "gem": "res://assets/sprites/gem.png"
}

func init(type, _position):
    $Sprite2D.texture = load(textures[type])
    position = _position
```

Вы будете вызывать сигнал picked_up, когда игрок соберет предмет. В словаре textures вы найдете список типов предметов и соответствующих файлов изображений. Обратите внимание, что вы можете быстро вставить эти пути в сценарий, перетащив файл из FileSystem и бросив его в редактор сценария.

Затем функция init() устанавливает текстуру и позицию. Сценарий вашего уровня будет использовать это для создания всех предметов, которые вы поместили на карту вашего уровня.

Наконец, подключите сигнал body_entered Item и добавьте этот код:

```gd
func _on_item_body_entered(body):
    picked_up.emit()
    queue_free()
```

Этот сигнал позволит основному сценарию игры реагировать на подбор предмета. Он может увеличивать счет, увеличивать здоровье игрока или применять любой другой эффект, который вы хотите применить к предмету.

Вы, возможно, заметили, что эти собираемые предметы устроены очень похоже на монеты из Coin Dash. Области очень полезны для любого типа предметов, где вам нужно знать, когда их касаются. В следующем разделе вы начнете создавать сцену уровня, чтобы размещать эти собираемые предметы.

## Дизайн уровня
Для большинства из вас этот раздел займет большую часть времени. Как только вы начнете проектировать уровень, вы обнаружите, что это весело – расставлять все элементы, создавать сложные прыжки, секретные пути и опасные встречи.

Сначала вы создадите общий сценарий Level, содержащий все узлы и код, общий для всех уровней. Затем вы можете создать любое количество сценариев Level, которые наследуются от этого основного уровня.

## Использование TileMap
Создайте новую сцену и добавьте узел Node2D с именем LevelBase. Сохраните сцену в новой папке с именем levels. Здесь вы будете сохранять все уровни, которые создадите, и все они будут наследовать функционал от этой сцены level_base.tscn. У них будет одна и та же иерархия узлов, только расположение будет разным.

TileMap - это распространенное средство для проектирования игровых окружений с использованием сетки тайлов. Они позволяют вам рисовать макет уровня, нанося тайлы на сетку, вместо того чтобы размещать много отдельных узлов поочередно. Они также более эффективны, потому что они объединяют все индивидуальные текстуры тайлов и формы столкновения в единый игровой объект.

Добавьте узел TileMap; внизу окна редактора появится новая панель TileMap. Обратите внимание, что там написано: "The edited TileMap has no TileSet resource" ("Редактируемый TileMap не имеет ресурса TileSet").

## О TileSet
Чтобы рисовать карту с использованием TileMap, ей должен быть назначен TileSet. Этот TileSet содержит все индивидуальные текстуры тайлов, а также любые формы столкновения, которые они могут иметь.

В зависимости от того, сколько у вас может быть тайлов, создание TileSet может потребовать много времени, особенно впервые. По этой причине в папке assets включены некоторые заранее сгенерированные тайлсеты. Вы можете использовать их, но прочитайте следующий раздел. В нем содержится полезная информация, чтобы вы поняли, как работает TileSet. Если вы предпочтете использовать предоставленные тайлсеты, перейдите к разделу Использование предоставленных TileSet.

## Создание TileSet
В Godot TileSet - это тип Ресурса. Примеры других ресурсов включают Текстуру, Анимацию и RectangleShape2D. Они не являются узлами; вместо этого они являются контейнерами, содержащими определенный тип данных и обычно сохраняются в файлах .tres.


Вот шаги для создания контейнера TileSet:

1. Нажмите "New TileSet" в области Tile Set TileMap. Теперь у вас появится доступная панель TileSet, которую вы можете выбрать внизу окна редактора. Вы можете нажать две стрелки вверх, чтобы сделать панель на весь экран редактора. Нажмите ее еще раз, чтобы уменьшить панель.

2. Вкладка Tiles слева в панели TileSet - это место, где вы можете поместить текстуры, которые вы хотите нарезать на тайлы. Перетащите res://assets/environment/tileset.png в это поле. Всплывет окно с запросом о том, хотите ли вы автоматически создать тайлы. Выберите "Yes". Вы увидите, что вокруг всех тайлов размером 16x16 пикселей на изображении нарисованы рамки:

   ![Добавление TileSet](/img/jungle-jump/B19289_04_13.jpg)

3. Попробуйте выбрать панель TileMap внизу, а затем выберите изображение блока с травой в верхнем левом углу тайлов. Затем щелкните в окне редактора, чтобы нарисовать несколько тайлов, нажимая левой кнопкой мыши. Вы можете щелкнуть правой кнопкой мыши по тайлу, чтобы его очистить:

   ![Рисование с использованием TileMaps](/img/jungle-jump/B19289_04_14.jpg)

4. Если все, что вам нужно, - это нарисовать фон, вы закончили. Однако вам также нужно добавить столкновения к этим тайлам, чтобы игрок мог стоять на них.

5. Откройте снова панель TileSet и в разделе Inspector найдите свойство PhysicsLayers и нажмите "Add Element":

   ![Добавление физического слоя в TileSet](/img/jungle-jump/B19289_04_15.jpg)

6. Поскольку эти тайлы будут в слое окружающей среды, вам не нужно изменять настройки слоя/маски.

7. Нажмите "Paint" в панели TileSet и в разделе "Paint Properties" выберите Physics Layer 0:

   ![Добавление столкновений к тайлам](/img/jungle-jump/B19289_04_16.jpg)

8. Начните щелкать по тайлам, чтобы добавить к ним стандартную квадратную форму столкновения. Если вы хотите отредактировать форму столкновения тайла, вы можете сделать это - щелкните по тайлу снова, чтобы применить изменения. Если вы застряли с формой, которая вам не нравится, нажмите три точки и выберите "Reset to default tile shape".

Вы также можете перетащить изображение props.png в список текстур для добавления декоративных элементов в ваш уровень.



Использование предоставленных наборов тайлов
В загруженных для этого проекта ресурсах уже предварительно настроенные наборы тайлов. Их три, и их нужно добавить к трем разным узлам TileMap:

- World – tiles_world.tres: Тайлы земли и платформ
- Items – tiles_items.tres: Маркеры для появления предметов
- Danger – tiles_spikes.tres: Предметы, которые наносят урон при столкновении
  Создайте TileMap-узлы Items и Danger и добавьте соответствующий набор тайлов к свойству Tile Set.

Добавьте экземпляр сцены Player и узел Marker2D с именем SpawnPoint. Вы можете использовать этот узел для обозначения места, где вы хотите, чтобы игрок начинал уровень.

Присоедините скрипт к узлу Level:

```gdscript
extends Node2D

func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
```

Позже вы будете сканировать карту Items, чтобы создавать предметы в указанных местах. Этот слой карты не должен быть виден, поэтому его можно скрыть в сцене. Тем не менее, легко забыть об этом, поэтому _ready() гарантирует, что он не будет виден во время игры.

Проектирование первого уровня
Теперь вы готовы начать рисовать уровень! Выберите Scene > New Inherited Scene и выберите level_base.tscn. Назовите корневой узел Level01 и сохраните его (в папку levels). Обратите внимание, что дочерние узлы окрашены в желтый цвет, что указывает на то, что они унаследованы от исходного уровня level_base.tscn. Если вы внесете изменения в этот исходный уровень, эти изменения также будут видны в этом уровне.

Начните с карты World и будьте творческими. Вам нравятся многочисленные прыжки, извилистые туннели для исследования? Длинные беги или осторожные восхождения вверх?

Прежде чем слишком углубляться в проектирование уровня, убедитесь, что вы экспериментируете с длиной прыжка. Вы можете изменить свойства движения игрока, такие как jump_speed, run_speed и gravity, чтобы изменить высоту и дальность прыжка. Настройте несколько разных размеров промежутков и запустите сцену, чтобы их опробовать. Не забудьте переместить узел SpawnPoint в то место, где вы хотите, чтобы игрок начал. Как вы настраиваете свойства движения игрока, сильно влияет на то, как должен быть оформлен ваш уровень. Удостоверьтесь, что вы довольны своими настройками, прежде чем тратить слишком много времени на полное проектирование..


Как только у вас будет готова карта World, используйте карту Items, чтобы отметить места, где вы хотели бы разместить вишни и драгоценные камни. Тайлы, отмечающие места появления, отрисованы с маджентовым фоном, чтобы выделяться. Помните, что они будут заменены во время выполнения, и сами тайлы не будут видны.

Как только ваш уровень будет готов, вы можете ограничить горизонтальную прокрутку камеры игрока, чтобы она соответствовала размеру карты (плюс небольшой буфер с каждого конца). Добавьте этот код в level_base.gd:

```gdscript
func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
    set_camera_limits()

func set_camera_limits():
    var map_size = $World.get_used_rect()
    var cell_size = $World.tile_set.tile_size
    $Player/Camera2D.limit_left = (map_size.position.x - 5) * cell_size.x
    $Player/Camera2D.limit_right = (map_size.end.x + 5) * cell_size.x
```

Сценарию также нужно просканировать карту Items и искать маркеры предметов. Сбор предметов добавит очки игроку, поэтому вы также можете добавить переменную для их отслеживания:

```gdscript
signal score_changed
var item_scene = load("res://items/item.tscn")
var score = 0: set = set_score

func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        var item = item_scene.instance()
        add_child(item)
        item.init(type, $Items.map_to_local(cell))
        item.picked_up.connect(self._on_item_picked_up)

func _on_item_picked_up():
    score += 1

func set_score(value):
    score = value
    score_changed.emit(score)
```

Функция spawn_items() использует get_used_cells(), чтобы получить список ячеек в TileMap, которые не являются пустыми. Эти ячейки находятся в _координатах карты_, а не в пиксельных координатах. Позднее, когда вы создадите предмет, вы сможете использовать map_to_local(), чтобы преобразовать значения.

Маркерные тайлы имеют слой пользовательских данных, прикрепленный к ним (аналогично слою физики, который вы добавили к тайлам мира), который указывает, какого они типа: gem (драгоценный камень) или cherry (вишня). Это затем используется для определения новому экземпляру, каким типом предмета он должен быть.

Переменная score предназначена для отслеживания количества предметов, собранных игроком. Вы можете использовать это для завершения уровня, предоставления бонусов и так далее.

Добавьте spawn_items() в _ready() и попробуйте запустить уровень. Вы должны увидеть, что гемы и вишни появляются в тех местах, где вы их разместили. Также проверьте, что они исчезают, когда вы их собираете.



## Слой опасности (Danger)
Слой опасности (Danger) на карте предназначен для размещения объектов в виде шипов, которые нанесут урон игроку при соприкосновении. Любой тайл на этой TileMap вызовет урон игроку! Попробуйте разместить несколько из них там, где вы сможете легко их протестировать.

Во вкладке Node добавьте TileMap опасности в группу с названием "danger", чтобы вы могли легко идентифицировать ее при столкновении. Это также позволит вам создавать другие опасные объекты, добавляя их в ту же группу.

## О коллизиях со скольжением

Когда узел CharacterBody2D перемещается с помощью move_and_slide(), он может столкнуться с более чем одним объектом в том же движении кадра. Например, при столкновении с углом тело может одновременно удариться о стену и пол. Вы можете использовать функцию get_slide_collision_count() для определения количества коллизий; затем вы можете получить информацию о каждой коллизии с помощью get_slide_collision().

В случае с игроком вы хотите обнаружить столкновение с TileMap опасности. Вы можете сделать это сразу после использования move_and_slide() в файле player.gd:

```gdscript
if state == HURT:
    return
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()
```

Обратите внимание, что перед проверкой столкновения с группой опасности вы можете сначала проверить, находится ли игрок уже в состоянии HURT. Если это так, вы можете пропустить проверку того, сталкивается ли он с опасным объектом.

Цикл for перебирает количество столкновений, заданное get_slide_collision_count(), чтобы проверить каждое из них на наличие объекта в группе опасности.

Воспроизведите вашу сцену и попробуйте столкнуться с одним из шипов. Вы должны увидеть, что игрок переходит в состояние HURT (воспроизводится анимация) на короткое время, прежде чем вернуться к состоянию IDLE. После трех ударов игрок войдет в состояние DEAD, которое в настоящее время просто скрывает игрока.

В папке res://assets/environment/ есть два фоновых изображения: back.png и middle.png для дальнего и ближнего фона соответственно. Разместив эти изображения за тайлмапом и прокручив их с разной скоростью относительно камеры, вы можете создать привлекательную иллюзию глубины в фоне:
::list
 - Добавьте узел ParallaxBackground к сцене LevelBase (чтобы он присутствовал во всех унаследованных уровнях). Этот узел взаимодействует с камерой, создавая эффект прокрутки. Перетащите этот узел в верхнюю часть дерева сцены, чтобы он рисовался за остальными узлами. Затем добавьте узел ParallaxLayer в качестве его дочернего элемента. У ParallaxBackground может быть любое количество дочерних узлов ParallaxLayer, что позволяет создавать несколько независимых прокручиваемых слоев.
 - Добавьте узел Sprite2D в качестве дочернего элемента ParallaxLayer и перетащите изображение back.png в его область Texture. Убедитесь, что свойство Offset/Centered не отмечено, чтобы изображение располагалось относительно начала экрана. Также увеличьте масштаб узла Sprite2D, установив Scale равным (1.5, 1.5).
 - На ParallaxLayer установите Motion/Scale в (0.2, 1) (вам придется щелкнуть значок ссылки, чтобы разрешить установку значений x и y отдельно). Эта настройка контролирует скорость прокрутки фона относительно движения камеры. Установив ее менее 1, изображение будет перемещаться незначительно при движении игрока влево и вправо.
 - Убедитесь, что изображение повторяется, если ваш уровень шире размера изображения, поэтому установите Motion/Mirroring в (576, 0). Это точно ширина изображения (384 умножить на 1.5), поэтому изображение будет повторяться, когда оно переместится на эту величину в пикселях.
 - Обратите внимание, что это изображение задумано для уровней, которые шире, чем высоки. Если вы прыгнете слишком высоко, вы увидите верхнюю часть изображения. Вы можете исправить это, установив верхний предел камеры. Если вы не переместили позицию фона, его верхний левый угол все равно будет в точке (0, 0), поэтому вы можете установить верхний предел камеры в 0. Если вы переместили ParallaxLayer или его узел Sprite2D, вы можете найти правильное значение, посмотрев на значение y позиции узла.
 - Попробуйте запустить уровень и перемещаться влево и вправо. Вы должны увидеть, что фон двигается незначительно по сравнению с тем, как далеко вы бежите.
 - Добавьте еще один узел ParallaxLayer (также в качестве дочернего для ParallaxBackground) и добавьте ему дочерний узел Sprite2D. На этот раз используйте изображение middle.png. Это изображение значительно уже, чем изображение неба, поэтому вам нужно настроить некоторые параметры для правильного повторения. Это связано с тем, что ParallaxBackground должен иметь изображения, по крайней мере, такие же большие, как область видимости.
 - Найдите свойство Texture/Repeat у узла Sprite2D в разделе CanvasItem и установите его значение на Mirror. Затем разверните раздел Region и убедитесь, что включена опция Enabled. В разделе Rect установите ширину и высоту равными (880, 368). 880 - это ширина изображения (176), умноженная на 5, поэтому теперь вы увидите пять повторений изображения, каждое зеркальное предыдущему.
 - Переместите узел Sprite2D так, чтобы изображение перекрывалось нижней половиной изображения океана/неба: !()[/img/jungle-jump/B19289_04_17.jpg] 
 - Установите параметр Motion/Scale второго узла ParallaxLayer на (0.6, 1), а параметр Motion/Mirroring на (880, 0). Использование более высокого коэффициента масштабирования означает, что этот слой будет прокручиваться немного быстрее слоя облаков за ним. Воспроизведите сцену, чтобы протестировать эффект.
::

Дерево узлов вашей сцены уровня теперь должно выглядеть следующим образом:
![Фильтрация текстур](/img/jungle-jump/B19289_04_18.jpg)

Ваша сцена уровня теперь имеет все необходимые элементы для создания дизайна уровня. Хотите, чтобы ваш игрок должен был делать очень точные прыжки (уровень паркура), пробегать через серию извилистых проходов, пытаясь найти все предметы (уровень лабиринта) или какое-то сочетание обоих? Это ваш шанс попробовать некоторые креативные идеи, но убедитесь, что вы оставляете место для следующего объекта, который вы создадите: врагов.
