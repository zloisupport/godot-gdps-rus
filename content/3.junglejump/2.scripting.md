# Скрипт игрока
Присоедините новый скрипт к узлу Player. Обратите внимание, что в диалоге отображается свойство Template с примером кода Basic Movement для этого типа узла в Godot. Отключите флажок Template - вам не понадобится этот пример кода для этого проекта.

Добавьте следующий код для начала настройки конечного автомата игрока. Как и в игре Space Rocks, вы можете использовать тип enum для определения допустимых состояний для системы. Когда вы захотите изменить состояние игрока, вы можете вызвать change_state():

```gdscript
extends CharacterBody2D
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            hide()
```

На данный момент скрипт только изменяет воспроизводимую анимацию, но позже вы добавите больше функциональности состояния.

## Движение игрока
Игроку нужны три управления: влево, вправо и прыжок. Сравнение текущего состояния с тем, какие клавиши нажаты, вызовет изменение состояния, если переход разрешен правилами диаграммы состояний. Добавьте функцию get_input() для обработки ввода и определения результата. Каждое условие if представляет один из переходов в диаграмме состояний:

```gdscript
func get_input():
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")

    # movement occurs in all states
    velocity.x = 0

    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false

    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true

    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed

    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)

    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)

    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)

```

Обратите внимание, что проверка прыжка использует is_action_just_pressed() вместо is_action_pressed(). В то время как последнее возвращает true, пока клавиша удерживается, первое будет true только в том кадре, в котором клавиша была нажата. Это означает, что игрок должен нажимать клавишу прыжка каждый раз, когда они хотят прыгнуть.

Вызывайте эту функцию из _physics_process(), добавляйте гравитацию к скорости игрока и вызывайте метод move_and_slide() для перемещения:

```gdscript
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()
```

Помните, что поскольку свойство Up Direction установлено на (0, -1), любое столкновение под ногами игрока будет считаться "полом", и is_on_floor() будет установлено в true методом move_and_slide(). Вы можете использовать это для определения окончания прыжка, добавив это сразу после move_and_slide():

```gdscript
if state == JUMP and is_on_floor():
    change_state(IDLE)
```

Прыжок будет выглядеть лучше, если анимация переключится с jump_up на jump_down при падении:

```gdscript
if state == JUMP and velocity.y > 0:
    $AnimationPlayer.play("jump_down")
```

Позже, после завершения уровня, игроку будет передано местоположение появления. Чтобы обработать это, добавьте эту функцию в скрипт:

```gdscript
func reset(_position):
    position = _position
    show()
    change_state(IDLE)
```

Таким образом, вы завершили добавление движения, и для каждой ситуации должна воспроизводиться правильная анимация. Это было бы хорошей точкой остановки и проверки игрока, чтобы убедиться, что все работает. Однако вы не можете просто запустить сцену, потому что игрок начнет падать без поверхности для стояния.


## Тестирование движения
Создайте новую сцену и добавьте объект Node с именем Main (позднее это станет вашей основной сценой). Добавьте экземпляр Player, затем добавьте узел StaticBody2D с прямоугольной формой столкновения. Растяните форму столкновения горизонтально так, чтобы она была достаточно широкой для движения туда и обратно, и разместите ее под персонажем:

![Тестовая сцена с платформой](/img/jungle-jump/B19289_04_10.jpg)

Поскольку у него нет узла Sprite2D, статическое тело будет невидимым при запуске игры. В меню выберите Debug > Visible Collision Shapes. Это полезная настройка отладки, которая будет рисовать формы столкновения во время выполнения игры. Вы можете включить ее в любое время, когда вам нужно тестировать или устранять проблемы с столкновениями.

Нажмите Play Scene; вы должны увидеть, что игрок перестает падать и начинает воспроизводить анимацию покоя, когда он касается статического тела.

Прежде чем перейти дальше, убедитесь, что все движения и анимации работают правильно. Бегите и прыгайте во всех направлениях и проверьте, что правильные анимации воспроизводятся, когда состояние изменяется. Если вы обнаружите какие-либо проблемы, просмотрите предыдущие разделы и убедитесь, что вы ничего не упустили.

## Здоровье игрока
В конечном итоге игрок столкнется с опасностью, поэтому вы должны добавить систему урона. Игрок начнет с тремя сердцами и потеряет одно каждый раз, когда ему наносят урон.

Добавьте следующее в верхнюю часть скрипта (сразу после строки extends):

```gdscript
signal life_changed
signal died
var life = 3 setget set_life
func set_life(value):
    life = value
    life_changed.emit(life)
    if life <= 0:
        change_state(DEAD)
```

Вы будете излучать сигнал life_changed каждый раз, когда значение life изменяется, уведомляя дисплей о необходимости обновления. died будет излучен, когда life достигнет 0.

Добавьте `life = 3` в функцию reset().

Есть два возможных способа, которыми игрок может получить урон: столкновение с объектом шипа в окружении или удар врага. В любом случае может быть вызвана следующая функция:


```gdscript
func hurt():
    if state != HURT:
        change_state(HURT)
```

Этот код относится к дружелюбному отношению к игроку: если он уже ранен, его нельзя ранить снова (по крайней мере, в течение короткого времени, пока анимация урона не завершится). Без этого легко застрять в цикле получения урона, что приведет к быстрой смерти.

Есть несколько вещей, которые нужно сделать, когда состояние изменяется на HURT в функции change_state(), которую вы ранее создали:

```gdscript
HURT:
    $AnimationPlayer.play("hurt")
    velocity.y = -200
    velocity.x = -100 * sign(velocity.x)
    life -= 1
    await get_tree().create_timer(0.5).timeout
    change_state(IDLE)
DEAD:
    died.emit()
    hide()
```

Когда игрок получает урон, не только он теряет одну жизнь, но и отбрасывается вверх и в сторону от повреждающего объекта. Через некоторое время состояние возвращается к IDLE.

Кроме того, ввод должен быть отключен во время состояния HURT. Добавьте это в начало функции get_input():

```gdscript
if state == HURT:
    return
```

Теперь игрок готов получать урон после того, как остальная часть игры будет настроена. Далее вы создадите объекты, которые игрок будет собирать в игре.

## Collectible items
Прежде чем приступить к созданию уровня, вам нужно создать несколько предметов, которые игрок сможет собирать, поскольку они также будут частью уровня. В папке assets/sprites содержатся спрайт-листы для двух типов собираемых предметов: вишен и самоцветов.

Вместо того чтобы создавать отдельную сцену для каждого типа предмета, вы можете использовать одну сцену и заменять свойство текстуры в скрипте. Оба объекта имеют одинаковое поведение: анимация на месте и исчезновение при сборе игроком. Вы также можете добавить эффект плавного перехода для сбора (см. главу 2).