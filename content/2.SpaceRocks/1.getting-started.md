# Space Rocks: Build a 2D Arcade Classic with Physics

В этой главе вы освоили основы Godot Engine, создав небольшую 2D-игру. Вы настроили проект, создали несколько сцен, работали со спрайтами и анимациями, обработали ввод пользователя, использовали сигналы для общения между узлами и создали пользовательский интерфейс. Все эти навыки являются важными для работы в любом проекте на Godot.

Перед переходом к следующей главе пройдитесь по проекту. Знаете ли вы, что делает каждый узел? Есть ли куски кода, которые вы не понимаете? Если таковы, вернитесь и пересмотрите соответствующий раздел главы.

Также не стесняйтесь экспериментировать с игрой и изменять её. Одним из лучших способов понять, как работают различные части игры, является их изменение и наблюдение за результатами.

Помните совет из главы 1? Если вы действительно хотите быстро развивать свои навыки, закройте эту книгу, создайте новый проект в Godot и попробуйте создать Coin Dash снова, не подсматривая. Если вам придется посмотреть в книгу, это нормально, но старайтесь заглядывать только после того, как попробуете сами разобраться.

В следующей главе вы изучите более сложные возможности Godot и узнаете, как использовать различные типы узлов, создав более сложную игру.


![HUD](/img/2-space/1.png)

Вы узнаете о следующих ключевых темах в этом проекте:
::list 
    - Использование пользовательских входных действий
    - Физика с использованием RigidBody2D
    - Организация игровой логики с помощью конечных автоматов
    - Создание динамичного, масштабируемого пользовательского интерфейса (UI)
    - Звук и музыка
    - Эффекты частиц
::

## Технические требования

Загрузите игровые ресурсы по следующей ссылке ниже и разархивируйте их в новую папку проекта:


[**GitHub**](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)

Вы также можете найти полный код этой главы на GitHub по адресу:
You can also find the complete code for this chapter on GitHub at:


[**GitHub**](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks)


Создайте новый проект и загрузите ресурсы проекта по следующему URL. [**GitHub**](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)

Для этого проекта вы настроите пользовательские действия ввода в Input Map. Используя эту функцию, вы можете определить пользовательские входные события и назначить им разные клавиши, события мыши или другие вводы. Это обеспечивает большую гибкость в проектировании вашей игры, так как ваш код может быть написан так, чтобы реагировать на ввод "прыжок", например, не зная точно, какую клавишу и/или кнопку пользователь нажал, чтобы это событие произошло. Это позволяет сделать одинаковый код, работающий на разных устройствах, даже если они имеют разные аппаратные характеристики. Кроме того, поскольку многие геймеры ожидают возможности настроить ввод в игре, это также позволяет предоставить эту опцию пользователю.

Чтобы настроить вводы для этой игры, откройте Project | Project Settings и выберите вкладку Input Map.

Вам нужно создать четыре новых действия ввода: rotate_left, rotate_right, thrust и shoot. Введите название каждого действия в поле "Add New Action" и нажмите Enter или кнопку Add. Убедитесь, что вы вводите имена точно так, как показано, поскольку они будут использоваться в коде позже.

Затем для каждого действия нажмите кнопку + справа от него. Во всплывающем окне вы можете вручную выбрать конкретный тип ввода, или вы можете нажать физическую кнопку, и Godot ее обнаружит. Вы можете добавить несколько вводов к каждому действию. Например, чтобы позволить игрокам использовать как стрелочные клавиши, так и клавиши WASD, настройка будет выглядеть следующим образом:

![HUD](/img/2-space/2.png)

Если у вас подключен геймпад или другой контроллер к вашему компьютеру, вы также можете добавить его входы к действиям тем же способом.
Примечание: 
На данном этапе мы рассматриваем только входы в стиле кнопок, поэтому, хотя вы сможете использовать D-pad для этого проекта, использование аналогового джойстика потребует изменений в коде проекта.


## Физика твердого тела

В разработке игр часто необходимо знать, когда два объекта в игровом пространстве пересекаются или вступают в контакт. Это известно как обнаружение столкновений. Когда столкновение обнаружено, обычно вы хотите, чтобы что-то произошло. Это называется обработка столкновений.

Godot предлагает три вида физических тел, сгруппированных под типом узла PhysicsBody2D:
::list
  -  StaticBody2D: Статическое тело – это тело, которое не перемещается физическим движком. Он участвует в обнаружении столкновений, но не перемещается в ответ. Этот тип тела чаще всего используется для объектов, являющихся частью окружения или не требующих динамического поведения, таких как стены или земля.

  -  RigidBody2D: Это тело физики, которое обеспечивает имитацию физики. Это означает, что вы не управляете положением тела физики RigidBody2D напрямую. Вместо этого вы применяете к нему силы (гравитацию, импульсы и так далее), а встроенный физический движок Godot вычисляет результативное движение, включая столкновения, отскок, вращение и другие эффекты.

  -  CharacterBody2D: Этот тип тела предоставляет обнаружение столкновений, но не имеет физики. Весь движение должно быть реализовано в коде, и ответ на столкновение также требуется реализовать самостоятельно. Кинематические тела чаще всего используются для игровых персонажей или других объектов, требующих аркадной физики, а не реалистичного моделирования, или когда требуется более точное управление тем, как двигается тело.
::


Понимание, когда использовать определенный тип физического тела, является важной частью создания вашей игры. Использование правильного типа может упростить разработку, в то время как попытка заставить неподходящий узел выполнять эту задачу может привести к разочарованию и плохим результатам. Работая с каждым типом тела, вы узнаете их преимущества и недостатки, и поймете, когда они могут быть полезны для создания нужного вам функционала.

В этом проекте вы будете использовать узел RigidBody2D для корабля и самих камней. Вы также узнаете о других типах тел в последующих главах.

У индивидуальных узлов RigidBody2D есть множество свойств, которые можно использовать для настройки их поведения, таких как Масса, Трение или Отскок. Эти свойства можно установить в инспекторе.

Rigid bodies также подвержены воздействию глобальных свойств, которые можно установить в настройках проекта( Project Settings) в разделе Физика|2D( Physics | 2D). Эти настройки применяются ко всем телам в мире.

![HUD](/img/2-space/3.png)

В большинстве случаев вам не потребуется изменять эти настройки. Однако обратите внимание, что по умолчанию гравитация имеет значение 980 и направлена вниз (0, 1). Если вы хотите изменить гравитацию мира, вы можете сделать это здесь.
Если вы щелкнете переключатель Расширенные настройки в верхнем правом углу окна Настроек проекта, вы увидите много продвинутых значений конфигурации для физического движка. Вам следует обратить внимание на два из них: Default Linear Damp и Default Angular Damp. Эти свойства контролируют, насколько быстро тело теряет скорость движения вперед и скорость вращения соответственно. Установка их на более низкие значения создаст ощущение отсутствия трения, в то время как более высокие значения будут создавать впечатление, что ваши объекты двигаются через густую жидкость. Это может быть отличным способом применения различных стилей движения для различных игровых объектов и сред.

Переопределение физики области
Узлы Area2D также могут влиять на физику тел с жесткими связями, используя свойство Space Override. Пользовательские значения гравитации и затухания затем будут применяться ко всем телам, которые входят в область.
Поскольку игра будет происходить в открытом космосе, гравитация не понадобится, поэтому установите Default Gravity на 0. Остальные настройки можно оставить без изменений.
Это завершает задачи настройки проекта. Это хорошая идея просмотреть этот раздел и убедиться, что вы ничего не упустили, поскольку внесенные здесь изменения повлияют на поведение многих игровых объектов. Вы увидите это в следующем разделе, где вы создадите космический корабль игрока.

## Космический корабль игрока

Корабль игрока является сердцем этой игры. Большая часть кода, который вы напишете для этого проекта, будет связан с работой корабля. Он будет управляться в классическом стиле "Астероидов" - вращение влево/вправо и тяга вперед. Игрок также сможет стрелять лазером и уничтожать плавающие камни.

![HUD](/img/2-space/4.png)


## Настройка тела и физики

Создайте новую сцену и добавьте в нее RigidBody2D с именем Player в качестве корневого узла, а также с дочерними узлами Sprite2D и CollisionShape2D. Добавьте изображение res://assets/player_ship.png в свойство Texture у Sprite2D. Изображение корабля довольно крупное, поэтому установите свойство Scale у Sprite2D в (0.5, 0.5) и Rotation в 90.


![HUD](/img/2-space/5.png)

## Ориентация спрайта

Изображение для корабля нарисовано, указывая вверх. В Godot поворот на 0 градусов указывает вправо (вдоль оси x). Это означает, что вам нужно повернуть спрайт так, чтобы он соответствовал направлению тела. Если вы используете изображение, нарисованное в правильной ориентации, вы можете избежать этого шага. Однако очень часто можно встретить изображения, нарисованные с ориентацией вверх, поэтому вам следует знать, что делать.

В свойстве Shape объекта CollisionShape2D добавьте CircleShape2D и масштабируйте его так, чтобы он как можно ближе соответствовал изображению.

![HUD](/img/2-space/6.png)


Изображение корабля игрока выполнено в стиле пиксельного искусства, но если вы увеличите его, вы, возможно, заметите, что оно выглядит размытым и "сглаженным". По умолчанию в Godot используется техника сглаживания при отображении текстур, что выглядит хорошо с некоторыми изображениями, но не желательно для пиксельного искусства. Вы можете устанавливать сглаживание индивидуально для каждого спрайта (в разделе *CanvasItem*), либо установить его глобально в настройках проекта.
Откройте настройки проекта ( Project Settings) и включите переключатель Advanced Settings, а затем найдите раздел *rendering/textures*. Внизу вы увидите две настройки для Canvas Textures. Установите *Default Texture Filter* в значение *Nearest*.

![Default Texture Filter settings ](/img/2-space/7.png)


Сохраните сцену. При работе над проектами большего масштаба рекомендуется организовывать ваши сцены и скрипты в папки на основе каждого игрового объекта, а не сохранять их все в корневой папке проекта. Например, если вы создадите папку "player" (игрок), вы можете сохранить все файлы, связанные с игроком, там. Это упрощает поиск и изменение различных игровых объектов. Хотя этот проект относительно небольшой - у вас будет всего несколько сцен - это хорошая привычка, которую стоит принять, по мере того как ваши проекты растут по размеру и сложности.

## Машины состояний

Корабль игрока может находиться в различных состояниях во время игры. Например, когда он жив, корабль виден и может быть управляем игроком, но при этом уязвим для столкновения с камнями. С другой стороны, когда он находится в режиме неуязвимости, корабль должен быть полупрозрачным и быть невосприимчивым к урону.
Один из способов, которым программисты часто обрабатывают подобные ситуации, - это добавление булевых переменных или флагов в код. Например, флаг неуязвимости устанавливается в true, когда игрок впервые появляется, или alive устанавливается в false, когда игрок мертв. Однако это может привести к ошибкам и странным ситуациям, когда по какой-то причине оба alive и неуязвимость установлены в false одновременно. Что произойдет, если камень столкнется с игроком в этой ситуации? Было бы лучше, если бы корабль мог находиться только в одном четко определенном состоянии в каждый момент времени.
Решением этой проблемы является использование конечного автомата (finite state machine-FSM). При использовании FSM сущность может находиться только в одном состоянии в определенный момент времени. При проектировании FSM вы определяете несколько состояний и то, какие события или действия могут вызвать переход из одного состояния в другое.
На следующей диаграмме изображен FSM для корабля игрока:

![State machine diagram ](/img/2-space/8.png)

Существует четыре состояния, изображенных овалами, и стрелки указывают, какие переходы могут происходить между состояниями, а также что вызывает переход. Проверяя текущее состояние, вы можете решить, что разрешено игроку. Например, в состоянии DEAD (мертв), не разрешать ввод, или в состоянии INVULNERABLE (неуязвим), разрешать движение, но не разрешать стрельбу.

Реализации продвинутых конечных автоматов могут стать довольно сложными, и детали выходят за рамки данной книги (см. Приложение для дополнительного чтения). В чистом смысле, здесь вы не будете создавать настоящий конечный автомат, но в рамках этого проекта будет достаточно проиллюстрировать концепцию и предотвратить проблемы с булевыми флагами.

Добавьте скрипт к узлу Player и начните с создания скелета реализации конечного автомата (FSM):


::godot
    extends RigidBody2D
    enum {INIT, ALIVE, INVULNERABLE, DEAD}
    var state = INIT 
::

Перечисление (сокращенно от "enumeration") - удобный способ создать набор констант. Оператор enum в предыдущем коде эквивалентен написанию следующего кода:

::godot
    const INIT = 0
    const ALIVE = 1
    const INVULNERABLE = 2
    const DEAD = 3 
::

Далее создайте функцию change_state() для обработки переходов между состояниями:

::godot 
    func _ready():
        change_state(ALIVE)
    func change_state(new_state):
        match new_state:
            INIT:
                $CollisionShape2D.set_deferred("disabled",true)
            ALIVE:
                $CollisionShape2D.set_deferred("disabled",false)
            INVULNERABLE: 
                $CollisionShape2D.set_deferred("disabled",true)
            DEAD:
                $CollisionShape2D.set_deferred("disabled",  true)
        state = new_state 
::


Всякий раз, когда вам нужно изменить состояние игрока, вы вызовете функцию change_state() и передадите ей значение нового состояния. Затем, используя оператор match, вы можете выполнить код, который должен сопровождать переход к новому состоянию, или запретить его, если вы не хотите, чтобы этот переход произошел. В данном случае узел CollisionShape2D включается/выключается в зависимости от нового состояния. В _ready() мы устанавливаем ALIVE в качестве начального состояния - это для тестирования, но мы заменим его на INIT позже.

## Добавление управления игроком

Добавьте следующие переменные в верхней части скрипта:

::godot 

    @export var engine_power = 500
    @export var spin_power = 8000
    var thrust = Vector2.ZERO
    var rotation_dir = 0 

::
engine_power и spin_power контролируют, насколько быстро корабль может ускоряться и поворачиваться. thrust представляет собой силу, приложенную двигателем: либо (0, 0), когда корабль движется инерционно, либо вектор, направленный вперед, когда двигатель включен. rotation_dir указывает, в каком направлении поворачивается корабль, чтобы вы могли применить к нему крутящий момент или вращательную силу.

Как мы видели ранее в настройках проекта(Project Settings), физический движок предоставляет некоторое затухание, которое уменьшает скорость и вращение тела. В космосе нет трения, поэтому для реализма не должно быть никакого затухания вообще. Однако для классического аркадного ощущения предпочтительно, чтобы корабль останавливался, когда вы отпускаете клавиши. В инспекторе установите Linear/Damp в 1 и Angular/Damp в 5. Вы можете отрегулировать их позже, чтобы изменить характеристики корабля.

Следующим шагом является обнаружение ввода и перемещение корабля:

::godot 
    func _process(delta):
        get_input()
    func get_input():
        thrust = Vector2.ZERO
        if state in [DEAD, INIT]:
            return
        if Input.is_action_pressed("thrust"):
            thrust = transform.x * engine_power
        rotation_dir = Input.get_axis("rotate_left",
            "rotate_right")
    func _physics_process(delta):
        constant_force = thrust
        constant_torque = rotation_dir * spin_power 

::

Функция get_input() захватывает клавишные действия и включает или выключает тягу корабля. Обратите внимание, что направление тяги зависит от transform.x тела, который всегда представляет собой "вперёд" тела (см. Приложение для обзора трансформаций).

Input.get_axis() возвращает значение на основе двух входов, представляя отрицательные и положительные значения. Таким образом, rotation_dir будет либо по часовой стрелке, либо против, либо ноль, в зависимости от состояния двух входных действий.

Наконец, при использовании физических тел и связанных с ними функций всегда следует вызывать в _physics_process(). Здесь можно применять силы, установленные вводами, чтобы фактически перемещать тело.

Запустите сцену, и вы должны сможете свободно летать вокруг.

