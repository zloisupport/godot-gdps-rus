# Space Rocks: Build a 2D Arcade Classic with Physics

В этой главе вы освоили основы Godot Engine, создав небольшую 2D-игру. Вы настроили проект, создали несколько сцен, работали со спрайтами и анимациями, обработали ввод пользователя, использовали сигналы для общения между узлами и создали пользовательский интерфейс. Все эти навыки являются важными для работы в любом проекте на Godot.

Перед переходом к следующей главе пройдитесь по проекту. Знаете ли вы, что делает каждый узел? Есть ли куски кода, которые вы не понимаете? Если таковы, вернитесь и пересмотрите соответствующий раздел главы.

Также не стесняйтесь экспериментировать с игрой и изменять её. Одним из лучших способов понять, как работают различные части игры, является их изменение и наблюдение за результатами.

Помните совет из главы 1? Если вы действительно хотите быстро развивать свои навыки, закройте эту книгу, создайте новый проект в Godot и попробуйте создать Coin Dash снова, не подсматривая. Если вам придется посмотреть в книгу, это нормально, но старайтесь заглядывать только после того, как попробуете сами разобраться.

В следующей главе вы изучите более сложные возможности Godot и узнаете, как использовать различные типы узлов, создав более сложную игру.


![HUD](/img/2-space/1.png)

Вы узнаете о следующих ключевых темах в этом проекте:
::list 
    - Использование пользовательских входных действий
    - Физика с использованием RigidBody2D
    - Организация игровой логики с помощью конечных автоматов
    - Создание динамичного, масштабируемого пользовательского интерфейса (UI)
    - Звук и музыка
    - Эффекты частиц
::

## Технические требования

Загрузите игровые ресурсы по следующей ссылке ниже и разархивируйте их в новую папку проекта:


[**GitHub**](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)

Вы также можете найти полный код этой главы на GitHub по адресу:
You can also find the complete code for this chapter on GitHub at:


[**GitHub**](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks)


Создайте новый проект и загрузите ресурсы проекта по следующему URL. [**GitHub**](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)

Для этого проекта вы настроите пользовательские действия ввода в Input Map. Используя эту функцию, вы можете определить пользовательские входные события и назначить им разные клавиши, события мыши или другие вводы. Это обеспечивает большую гибкость в проектировании вашей игры, так как ваш код может быть написан так, чтобы реагировать на ввод "прыжок", например, не зная точно, какую клавишу и/или кнопку пользователь нажал, чтобы это событие произошло. Это позволяет сделать одинаковый код, работающий на разных устройствах, даже если они имеют разные аппаратные характеристики. Кроме того, поскольку многие геймеры ожидают возможности настроить ввод в игре, это также позволяет предоставить эту опцию пользователю.

Чтобы настроить вводы для этой игры, откройте Project | Project Settings и выберите вкладку Input Map.

Вам нужно создать четыре новых действия ввода: rotate_left, rotate_right, thrust и shoot. Введите название каждого действия в поле "Add New Action" и нажмите Enter или кнопку Add. Убедитесь, что вы вводите имена точно так, как показано, поскольку они будут использоваться в коде позже.

Затем для каждого действия нажмите кнопку + справа от него. Во всплывающем окне вы можете вручную выбрать конкретный тип ввода, или вы можете нажать физическую кнопку, и Godot ее обнаружит. Вы можете добавить несколько вводов к каждому действию. Например, чтобы позволить игрокам использовать как стрелочные клавиши, так и клавиши WASD, настройка будет выглядеть следующим образом:

![HUD](/img/2-space/2.png)

Если у вас подключен геймпад или другой контроллер к вашему компьютеру, вы также можете добавить его входы к действиям тем же способом.
Примечание: 
На данном этапе мы рассматриваем только входы в стиле кнопок, поэтому, хотя вы сможете использовать D-pad для этого проекта, использование аналогового джойстика потребует изменений в коде проекта.


## Физика твердого тела

В разработке игр часто необходимо знать, когда два объекта в игровом пространстве пересекаются или вступают в контакт. Это известно как обнаружение столкновений. Когда столкновение обнаружено, обычно вы хотите, чтобы что-то произошло. Это называется обработка столкновений.

Godot предлагает три вида физических тел, сгруппированных под типом узла PhysicsBody2D:
::list
  -  StaticBody2D: Статическое тело – это тело, которое не перемещается физическим движком. Он участвует в обнаружении столкновений, но не перемещается в ответ. Этот тип тела чаще всего используется для объектов, являющихся частью окружения или не требующих динамического поведения, таких как стены или земля.

  -  RigidBody2D: Это тело физики, которое обеспечивает имитацию физики. Это означает, что вы не управляете положением тела физики RigidBody2D напрямую. Вместо этого вы применяете к нему силы (гравитацию, импульсы и так далее), а встроенный физический движок Godot вычисляет результативное движение, включая столкновения, отскок, вращение и другие эффекты.

  -  CharacterBody2D: Этот тип тела предоставляет обнаружение столкновений, но не имеет физики. Весь движение должно быть реализовано в коде, и ответ на столкновение также требуется реализовать самостоятельно. Кинематические тела чаще всего используются для игровых персонажей или других объектов, требующих аркадной физики, а не реалистичного моделирования, или когда требуется более точное управление тем, как двигается тело.
::


Понимание, когда использовать определенный тип физического тела, является важной частью создания вашей игры. Использование правильного типа может упростить разработку, в то время как попытка заставить неподходящий узел выполнять эту задачу может привести к разочарованию и плохим результатам. Работая с каждым типом тела, вы узнаете их преимущества и недостатки, и поймете, когда они могут быть полезны для создания нужного вам функционала.

В этом проекте вы будете использовать узел RigidBody2D для корабля и самих камней. Вы также узнаете о других типах тел в последующих главах.

У индивидуальных узлов RigidBody2D есть множество свойств, которые можно использовать для настройки их поведения, таких как Масса, Трение или Отскок. Эти свойства можно установить в инспекторе.

Rigid bodies также подвержены воздействию глобальных свойств, которые можно установить в настройках проекта( Project Settings) в разделе Физика|2D( Physics | 2D). Эти настройки применяются ко всем телам в мире.

![HUD](/img/2-space/3.png)

В большинстве случаев вам не потребуется изменять эти настройки. Однако обратите внимание, что по умолчанию гравитация имеет значение 980 и направлена вниз (0, 1). Если вы хотите изменить гравитацию мира, вы можете сделать это здесь.
Если вы щелкнете переключатель Расширенные настройки в верхнем правом углу окна Настроек проекта, вы увидите много продвинутых значений конфигурации для физического движка. Вам следует обратить внимание на два из них: Default Linear Damp и Default Angular Damp. Эти свойства контролируют, насколько быстро тело теряет скорость движения вперед и скорость вращения соответственно. Установка их на более низкие значения создаст ощущение отсутствия трения, в то время как более высокие значения будут создавать впечатление, что ваши объекты двигаются через густую жидкость. Это может быть отличным способом применения различных стилей движения для различных игровых объектов и сред.

Переопределение физики области
Узлы Area2D также могут влиять на физику тел с жесткими связями, используя свойство Space Override. Пользовательские значения гравитации и затухания затем будут применяться ко всем телам, которые входят в область.
Поскольку игра будет происходить в открытом космосе, гравитация не понадобится, поэтому установите Default Gravity на 0. Остальные настройки можно оставить без изменений.
Это завершает задачи настройки проекта. Это хорошая идея просмотреть этот раздел и убедиться, что вы ничего не упустили, поскольку внесенные здесь изменения повлияют на поведение многих игровых объектов. Вы увидите это в следующем разделе, где вы создадите космический корабль игрока.

## Космический корабль игрока

Корабль игрока является сердцем этой игры. Большая часть кода, который вы напишете для этого проекта, будет связан с работой корабля. Он будет управляться в классическом стиле "Астероидов" - вращение влево/вправо и тяга вперед. Игрок также сможет стрелять лазером и уничтожать плавающие камни.

![HUD](/img/2-space/4.png)


## Настройка тела и физики

Создайте новую сцену и добавьте в нее RigidBody2D с именем Player в качестве корневого узла, а также с дочерними узлами Sprite2D и CollisionShape2D. Добавьте изображение res://assets/player_ship.png в свойство Texture у Sprite2D. Изображение корабля довольно крупное, поэтому установите свойство Scale у Sprite2D в (0.5, 0.5) и Rotation в 90.


![HUD](/img/2-space/5.png)

## Ориентация спрайта

Изображение для корабля нарисовано, указывая вверх. В Godot поворот на 0 градусов указывает вправо (вдоль оси x). Это означает, что вам нужно повернуть спрайт так, чтобы он соответствовал направлению тела. Если вы используете изображение, нарисованное в правильной ориентации, вы можете избежать этого шага. Однако очень часто можно встретить изображения, нарисованные с ориентацией вверх, поэтому вам следует знать, что делать.

В свойстве Shape объекта CollisionShape2D добавьте CircleShape2D и масштабируйте его так, чтобы он как можно ближе соответствовал изображению.

![HUD](/img/2-space/6.png)


Изображение корабля игрока выполнено в стиле пиксельного искусства, но если вы увеличите его, вы, возможно, заметите, что оно выглядит размытым и "сглаженным". По умолчанию в Godot используется техника сглаживания при отображении текстур, что выглядит хорошо с некоторыми изображениями, но не желательно для пиксельного искусства. Вы можете устанавливать сглаживание индивидуально для каждого спрайта (в разделе *CanvasItem*), либо установить его глобально в настройках проекта.
Откройте настройки проекта ( Project Settings) и включите переключатель Advanced Settings, а затем найдите раздел *rendering/textures*. Внизу вы увидите две настройки для Canvas Textures. Установите *Default Texture Filter* в значение *Nearest*.

![Default Texture Filter settings ](/img/2-space/7.png)


Сохраните сцену. При работе над проектами большего масштаба рекомендуется организовывать ваши сцены и скрипты в папки на основе каждого игрового объекта, а не сохранять их все в корневой папке проекта. Например, если вы создадите папку "player" (игрок), вы можете сохранить все файлы, связанные с игроком, там. Это упрощает поиск и изменение различных игровых объектов. Хотя этот проект относительно небольшой - у вас будет всего несколько сцен - это хорошая привычка, которую стоит принять, по мере того как ваши проекты растут по размеру и сложности.

## Машины состояний

Корабль игрока может находиться в различных состояниях во время игры. Например, когда он жив, корабль виден и может быть управляем игроком, но при этом уязвим для столкновения с камнями. С другой стороны, когда он находится в режиме неуязвимости, корабль должен быть полупрозрачным и быть невосприимчивым к урону.
Один из способов, которым программисты часто обрабатывают подобные ситуации, - это добавление булевых переменных или флагов в код. Например, флаг неуязвимости устанавливается в true, когда игрок впервые появляется, или alive устанавливается в false, когда игрок мертв. Однако это может привести к ошибкам и странным ситуациям, когда по какой-то причине оба alive и неуязвимость установлены в false одновременно. Что произойдет, если камень столкнется с игроком в этой ситуации? Было бы лучше, если бы корабль мог находиться только в одном четко определенном состоянии в каждый момент времени.
Решением этой проблемы является использование конечного автомата (finite state machine-FSM). При использовании FSM сущность может находиться только в одном состоянии в определенный момент времени. При проектировании FSM вы определяете несколько состояний и то, какие события или действия могут вызвать переход из одного состояния в другое.
На следующей диаграмме изображен FSM для корабля игрока:

![State machine diagram ](/img/2-space/8.png)

Существует четыре состояния, изображенных овалами, и стрелки указывают, какие переходы могут происходить между состояниями, а также что вызывает переход. Проверяя текущее состояние, вы можете решить, что разрешено игроку. Например, в состоянии DEAD (мертв), не разрешать ввод, или в состоянии INVULNERABLE (неуязвим), разрешать движение, но не разрешать стрельбу.

Реализации продвинутых конечных автоматов могут стать довольно сложными, и детали выходят за рамки данной книги (см. Приложение для дополнительного чтения). В чистом смысле, здесь вы не будете создавать настоящий конечный автомат, но в рамках этого проекта будет достаточно проиллюстрировать концепцию и предотвратить проблемы с булевыми флагами.

Добавьте скрипт к узлу Player и начните с создания скелета реализации конечного автомата (FSM):


::godot
    extends RigidBody2D
    enum {INIT, ALIVE, INVULNERABLE, DEAD}
    var state = INIT 
::

Перечисление (сокращенно от "enumeration") - удобный способ создать набор констант. Оператор enum в предыдущем коде эквивалентен написанию следующего кода:

::godot
    const INIT = 0
    const ALIVE = 1
    const INVULNERABLE = 2
    const DEAD = 3 
::

Далее создайте функцию change_state() для обработки переходов между состояниями:

::godot 
    func _ready():
        change_state(ALIVE)
    func change_state(new_state):
        match new_state:
            INIT:
                $CollisionShape2D.set_deferred("disabled",true)
            ALIVE:
                $CollisionShape2D.set_deferred("disabled",false)
            INVULNERABLE: 
                $CollisionShape2D.set_deferred("disabled",true)
            DEAD:
                $CollisionShape2D.set_deferred("disabled",  true)
        state = new_state 
::


Всякий раз, когда вам нужно изменить состояние игрока, вы вызовете функцию change_state() и передадите ей значение нового состояния. Затем, используя оператор match, вы можете выполнить код, который должен сопровождать переход к новому состоянию, или запретить его, если вы не хотите, чтобы этот переход произошел. В данном случае узел CollisionShape2D включается/выключается в зависимости от нового состояния. В _ready() мы устанавливаем ALIVE в качестве начального состояния - это для тестирования, но мы заменим его на INIT позже.

## Добавление управления игроком

Добавьте следующие переменные в верхней части скрипта:

::godot 

    @export var engine_power = 500
    @export var spin_power = 8000
    var thrust = Vector2.ZERO
    var rotation_dir = 0 

::
engine_power и spin_power контролируют, насколько быстро корабль может ускоряться и поворачиваться. thrust представляет собой силу, приложенную двигателем: либо (0, 0), когда корабль движется инерционно, либо вектор, направленный вперед, когда двигатель включен. rotation_dir указывает, в каком направлении поворачивается корабль, чтобы вы могли применить к нему крутящий момент или вращательную силу.

Как мы видели ранее в настройках проекта(Project Settings), физический движок предоставляет некоторое затухание, которое уменьшает скорость и вращение тела. В космосе нет трения, поэтому для реализма не должно быть никакого затухания вообще. Однако для классического аркадного ощущения предпочтительно, чтобы корабль останавливался, когда вы отпускаете клавиши. В инспекторе установите Linear/Damp в 1 и Angular/Damp в 5. Вы можете отрегулировать их позже, чтобы изменить характеристики корабля.

Следующим шагом является обнаружение ввода и перемещение корабля:

::godot 
    func _process(delta):
        get_input()
    func get_input():
        thrust = Vector2.ZERO
        if state in [DEAD, INIT]:
            return
        if Input.is_action_pressed("thrust"):
            thrust = transform.x * engine_power
        rotation_dir = Input.get_axis("rotate_left",
            "rotate_right")
    func _physics_process(delta):
        constant_force = thrust
        constant_torque = rotation_dir * spin_power 

::

Функция get_input() захватывает клавишные действия и включает или выключает тягу корабля. Обратите внимание, что направление тяги зависит от transform.x тела, который всегда представляет собой "вперёд" тела (см. Приложение для обзора трансформаций).

Input.get_axis() возвращает значение на основе двух входов, представляя отрицательные и положительные значения. Таким образом, rotation_dir будет либо по часовой стрелке, либо против, либо ноль, в зависимости от состояния двух входных действий.

Наконец, при использовании физических тел и связанных с ними функций всегда следует вызывать в _physics_process(). Здесь можно применять силы, установленные вводами, чтобы фактически перемещать тело.

Запустите сцену, и вы должны сможете свободно летать вокруг.


## Перемотка экрана

Ещё одна характерная особенность классических 2D аркадных игр - это перемотка экрана. Если игрок уходит за одну сторону экрана, он появляется на противоположной. На практике вы телепортируете корабль на другую сторону, мгновенно изменяя его положение. Вам потребуется знать размер экрана, поэтому добавьте следующую переменную в верхнюю часть скрипта:

```
    var screensize = Vector.ZERO 
```

И добавьте следующий код в метод _ready():

```
    screensize = get_viewport_rect().size 
```
Позднее вы можете добавить обработку установки размера экрана для всех объектов игры в основной скрипт игры, но пока это позволит вам протестировать перемотку экрана только сцены игрока.

При первом подходе к этой проблеме вы можете подумать, что можно использовать свойство позиции тела и, если оно выходит за границы экрана, установить его на противоположной стороне. И если бы вы использовали любой другой тип узла, это бы сработало отлично; однако, при использовании RigidBody2D, вы не можете непосредственно устанавливать положение, потому что это противоречило бы движению, которое вычисляет физический движок. Распространенной ошибкой является попытка добавления чего-то подобного:

```
    func _physics_process(delta):
        if position.x > screensize.x:
            position.x = 0
        if position.x < 0:
            position.x = screensize.x
        if position.y > screensize.y:
            position.y = 0
        if position.y < 0:
            position.y = screensize.y 

```

И если вы хотите попробовать это с Area2D в Coin Dash, это сработает отлично. Здесь же это не сработает, запирая игрока на краю экрана и вызывая непредсказуемые глюки в углах. Так в чем же ответ?

Чтобы процитировать документацию RigidBody2D:
`Примечание: Вы не должны изменять положение или линейную скорость RigidBody2D каждый кадр или даже очень часто. Если вам нужно непосредственно влиять на состояние тела, используйте _integrate_forces, который позволяет вам напрямую взаимодействовать с физическим состоянием.`


В описании для _integrate_forces() : 
(Это) Позволяет вам читать и безопасно изменять состояние симуляции для объекта. Используйте это вместо _physics_process,
если вам нужно непосредственно изменить положение объекта или другие физические свойства. 
Таким образом, ответ заключается в использовании этой отдельной функции, когда вы хотите непосредственно влиять на положение жесткого тела. Использование
_integrate_forces() предоставляет доступ к PhysicsDirectBodyState2D объекту Godot – объекту,
содержащему множество полезной информации о текущем состоянии тела. Поскольку вы хотите изменить положение тела,
это означает, что вам нужно изменить его Transform2D . 
Трансформация(transform) - это матрица, представляющая одно или несколько преобразований в пространстве, таких как трансляция, вращение и/или
масштабирование. Информацию о трансляции (т. е. положении) можно получить, обратившись к свойству origin объекта Transform2D . 
Используя эту информацию, вы можете реализовать эффект обтекания, добавив следующий код:


```
func _integrate_forces(physics_state):
    var xform = physics_state.transform
    xform.origin.x = wrapf(xform.origin.x, 0, screensize.x)
    xform.origin.y = wrapf(xform.origin.y, 0, screensize.y)
    physics_state.transform = xform

 ```

## Стрельба

Теперь настало время вооружить ваш корабль. При нажатии на действие "стрелять" пуля/лазер должен появиться в передней части корабля и двигаться в прямой линии до тех пор, пока не выйдет за пределы экрана. Игроку не разрешено стрелять снова до тех пор, пока не пройдет небольшой интервал времени (также известный как перезарядка (cooldown)).

Сцена пули:

Это настройка узлов для пули:

- Area2D с именем Bullet
- Sprite2D
- CollisionShape2D
- VisibleOnScreenNotifier2D

Используйте res://assets/laser.png из папки assets в качестве свойства Texture для Sprite2D, а
CapsuleShape2D в качестве формы коллизии. Вам нужно установить вращение CollisionShape2D на 90, чтобы она
была правильно ориентирована. Также масштабируйте Sprite2D до примерно половины размера: (0.5, 0.5).
Добавьте следующий скрипт к узлу Bullet:


```
    extends Area2D
    @export var speed = 1000
    var velocity = Vector2.ZERO
    func start(_transform):
    transform = _transform
    velocity = transform.x * speed
    func _process(delta):
    position += velocity * delta 

```
Вы вызовете функцию `start()` каждый раз, когда создается новая пуля. Передавая ей трансформацию, вы можете установить правильное положение и вращение, обычно это будет положение орудия корабля (о чем будет рассказано позже).

VisibleOnScreenNotifier2D - это узел, который информирует вас (посредством сигнала), когда узел становится видимым или невидимым. Вы можете использовать это, чтобы автоматически удалить пулю, выходящую за пределы экрана. Подключите сигнал screen_exited узла и добавьте следующий код:


```
    func _on_visible_on_screen_notifier_2d_screen_exited():
        queue_free() 
        
```

## Выстрел из пуль:

Следующим шагом является создание экземпляров сцены Bullet, когда игрок нажимает действие "стрелять". Однако, если сделать пулю дочерним объектом игрока, то она будет двигаться и вращаться вместе с игроком вместо того, чтобы двигаться независимо. Вы могли бы добавить пулю в основную сцену с использованием get_parent().add_child(), поскольку при выполнении игры сценой-родителем игрока будет основная сцена. Однако это означало бы, что вы больше не сможете запускать и тестировать сцену игрока по отдельности. Или, если бы вы решили перестроить вашу основную сцену, сделав игрока дочерним объектом какого-то другого узла, пуля не была бы добавлена туда, где вы ожидаете.

В общем, это плохая идея писать код, предполагающий фиксированную структуру дерева. В частности, старайтесь избегать ситуаций, где используется get_parent(), если это возможно. Вам может быть сложно думать в этом направлении сначала, но это приведет к более модульному дизайну и предотвратит некоторые распространенные ошибки.

В любом случае, SceneTree всегда будет существовать, и для этой игры будет правильным сделать пулю дочерним объектом корня дерева, который представляет собой окно, содержащее игру.

Добавьте узел Marker2D к игроку и назовите его Muzzle. Это будет меткой дула пушки - местом, где пуля появится. Установите Position в (50, 0), чтобы разместить его непосредственно перед кораблем.
Затем добавьте узел Timer и назовите его GunCooldown. Это предоставит перезарядку для оружия, предотвращая выстрел новой пули, пока не пройдет определенное количество времени. Установите флажки One Shot и Autostart в "включено".
Добавьте эти новые переменные в скрипт игрока:

        
```

    @export var bullet_scene : PackedScene
    @export var fire_rate = 0.25
    var can_shoot = true 

```

Перетащите файл bullet.tscn на новое свойство Bullet в панели Inspector.
Добавьте следующую строку в _ready():

```
    $GunCooldown.wait_time = fire_rate 
```

И добавьте следующий код в функцию get_input()

```
    if Input.is_action_pressed("shoot") and can_shoot:
    shoot() 

```

Теперь создайте функцию `shoot()`, которая будет обрабатывать создание пули (пуль):

```
    func shoot():
        if state == INVULNERABLE:
            return
        can_shoot = false
        $GunCooldown.start()
        var b = bullet_scene.instantiate()
        get_tree().root.add_child(b)
        b.start($Muzzle.global_transform) 
```

При стрельбе сначала устанавливается `can_shoot` в значение `false`, чтобы действие больше не вызывало `shoot()`. Затем новая пуля добавляется как дочерний объект к тому узлу, который является корнем дерева сцены. Наконец, вызывается функция `start()` для пули и передается ей глобальное преобразование узла дула (`muzzle`). Обратите внимание, что если бы вы использовали `transform` здесь, вы передали бы ему позицию дула относительно игрока (которая равна (50, 0), помните?), и поэтому пуля появилась бы в совершенно неправильном месте. Это еще один пример того, насколько важно понимать различие между локальными и глобальными координатами.

Чтобы позволить оружию стрелять снова, подключите сигнал timeout от `GunCooldown`:

```
    func _on_gun_cooldown_timeout():
        can_shoot = true 

```

## Тестирование корабля игрока

Создайте новую сцену с использованием узла, названного Main, и добавьте дочерний объект Sprite2D с именем Background. В свойстве Texture используйте res:/assets/space_background.png. Добавьте экземпляр Player в сцену.
Запустите основную сцену и проверьте, можете ли вы летать и стрелять.
Теперь, когда ваш игровой корабль работает, это хорошее время для остановки и проверки вашего понимания. Работа с жесткими телами может быть сложной; уделите несколько минут экспериментам с некоторыми настройками и кодом из этого раздела. Просто убедитесь, что вы их восстановите перед переходом к следующему разделу, где вы добавите астероиды в игру.

## Добавление камней
Цель игры - уничтожать плавающие космические скалы, поэтому теперь, когда у вас есть возможность стрелять, настало время добавить их. Как и
корабль, скалы будут использовать RigidBody2D, что заставит их двигаться по прямой линии со стабильной скоростью, если только их не нарушат. Они также будут отскакивать друг от друга реалистичным образом. Чтобы сделать вещи более интересными, скалы будут начинаться
большими, и, когда вы попадете в них, разбиваться на несколько более мелких скал.

## Настройка сцены

Создайте новую сцену с узлом RigidBody2D, названным Rock, и добавьте дочерний объект Sprite2D с использованием текстуры res://assets/rock.png. Добавьте CollisionShape2D, но еще не устанавливайте его форму. Поскольку вы будете создавать астероиды разных размеров, форма столкновения должна быть установлена в коде и настроена на правильный размер.

Вы не хотите, чтобы астероиды замедлялись, поэтому им нужно игнорировать стандартное линейное и угловое затухание. Установите как Linear/Damp, так и Angular/Damp в 0, а Damp Mode для обоих установите на Replace. Астероиды также должны отскакивать от друг друга. Вы можете сделать это в свойстве Physics Material. Выберите New PhysicsMaterial, а затем щелкните по нему, чтобы развернуть. Установите отображаемое свойство Bounce на 1.

## Камни переменного размера
Прикрепите скрипт к узлу Rock и определите переменные класса (члены класса):

```
    extends RigidBody2D
    var screensize = Vector2.ZERO
    var size
    var radius
    var scale_factor = 0.2 

```

Главный скрипт будет отвечать за создание новых скал, как в начале уровня, так и за появление более мелких скал после взрыва крупной. Крупная скала будет иметь размер 3, разбиваться на скалы размером 2 и так далее. Множитель scale_factor умножается на размер для установки масштаба Sprite2D, радиуса коллизии и так далее. Вы можете позже отрегулировать это, чтобы изменить размер каждой категории скалы.

Все это будет установлено методом start():

```
    func start(_position, _velocity, _size):
        position = _position
        size = _size
        mass = 1.5 * size
        $Sprite2D.scale = Vector2.ONE * scale_factor * sizeradius = int($Sprite2D.texture.get_size().x / 2 * $Sprite2D.scale.x)
        var shape = CircleShape2D.new()
        shape.radius = radius
        $CollisionShape2d.shape = shape
        linear_velocity = _velocity
        angular_velocity = randf_range(-PI, PI) 

```
Это место, где вы вычисляете правильный размер коллизии на основе размера скалы. Обратите внимание, что поскольку переменные position и size уже используются как переменные класса, вы можете использовать подчеркивание для аргументов функции, чтобы предотвратить конфликт.
Также скалы должны обтекать экран, как и игрок, поэтому используйте тот же прием с _integrate_forces():

```
    func _integrate_forces(physics_state):
        var xform = physics_state.transform
        xform.origin.x = wrapf(xform.origin.x, 0 - radius,screensize.x + radius)
        xform.origin.y = wrapf(xform.origin.y, 0 - radius, screensize.y + radius)
        physics_state.transform = xform 

```

Единственное отличие здесь заключается в том, что включение радиуса астероида в расчет приводит к более плавному телепортации. Астероид будет казаться полностью покидает экран, прежде чем появится на противоположной стороне. Вы можете попробовать сделать то же самое с кораблем игрока. Попробуйте и посмотрите, что вам нравится больше.


## Создание экземпляров камней

При создании новых скал главная сцена должна выбирать случайное начальное местоположение. Для этого вы можете использовать математику для выбора случайной точки вдоль периметра экрана, но вместо этого вы можете воспользоваться другим типом узла Godot. Вы создадите путь вдоль края экрана, и скрипт выберет случайное местоположение вдоль этого пути.

В сцене Main добавьте узел Path2D и назовите его RockPath. Когда вы выберете узел, вы увидите появление новых кнопок в верхней части окна редактора:

![ Path drawing tools ](/img/2-space/9.png)


Выберите среднюю кнопку (Добавить точку -Add Point)  , чтобы нарисовать путь, кликая по точкам, показанным на следующем скриншоте. Чтобы сделать так, чтобы точки выравнивались, убедитесь, что включена опция Использовать привязку к сетке(Use Grid Snap). Эту опцию можно найти на панели инструментов в верхней части окна редактора:

![ Enabling grid snapping ](/img/2-space/10.png)

Нарисуйте точки в порядке, показанном на следующем снимке экрана. После щелчка четвертой точки нажмите кнопку Close Curve (обозначенную 5 на снимке экрана), и ваш путь будет завершен.

![Path drawing order](/img/2-space/11.png)

Не кликайте снова в окне редактора, если у вас выбран RockPath! Если вы это сделаете, то добавите дополнительные точки к кривой, и ваши скалы могут появляться не там, где вы этого хотите. Вы можете нажать Ctrl + Z, чтобы отменить любые дополнительные точки, которые вы могли добавить.

Теперь, когда путь определен, добавьте PathFollow2D в качестве дочернего элемента RockPath и назовите его RockSpawn. Цель этого узла - автоматическое перемещение вдоль своего родительского пути, используя свойство Progress, представляющее собой смещение вдоль пути. Чем выше смещение, тем дальше по пути он движется. Поскольку наш путь замкнут, он также будет зацикливаться, если значение смещения больше длины пути.

Добавьте следующий скрипт в main.gd:
```
    extends Node
    @export var rock_scene : PackedScene
    var screensize = Vector2.ZERO
    func _ready():
        screensize = get_viewport().get_visible_rect().size
        for i in 3:
            spawn_rock(3)
```
Вы начинаете с получения размеров экрана, чтобы передать их скалам при их появлении. Затем вы создаете три скалы размером 3. Не забудьте перетащить rock.tscn на свойство Rock.

Вот функция spawn_rock():

```
    func spawn_rock(size, pos=null, vel=null):
        if pos == null:
            $RockPath/RockSpawn.progress = randi()
            pos = $RockPath/RockSpawn.position
        if vel == null:
            vel = Vector2.RIGHT.rotated(randf_range(0, TAU)) *randf_range(50, 125)
        var r = rock_scene.instantiate()
        r.screensize = screensize
        r.start(pos, vel, size)
        call_deferred("add_child", r) 
```

Эта функция служит двум целям. Если вызывается только с параметром размера, она выбирает случайное положение вдоль RockPath и случайную скорость. Однако, если эти значения предоставлены, она будет использовать их вместо. Это позволит вам появлять более мелкие скалы в месте взрыва, указывая их свойства.

Запустите игру, и вы должны увидеть три скалы, плывущие вокруг, но ваши пули на них не воздействуют.

## Разрушение астероидов

Пуля проверяет наличие тел в группе rocks, поэтому в сцене Rock выберите вкладку Node и выберите Groups. Введите rocks и нажмите Add:

![ Adding a “rocks” group ](/img/2-space/12.png)


Теперь, если вы запустите игру и выстрелите в астероид, вы увидите сообщение об ошибке, потому что пуля пытается вызвать метод explode() у астероида, который вы еще не определили. Этот метод должен сделать три вещи:

::list
  -  Удалить астероид.

  -  Воспроизвести анимацию взрыва.

  -  Уведомить основную сцену о создании новых, более мелких астероидов.
::

## Сцена взрыва

Взрыв будет представлять собой отдельную сцену, которую вы сможете добавить к астероиду, а затем к игроку. Он будет содержать два узла:
::list
  -  Sprite2D с именем Explosion
  -  AnimationPlayer
::

Для свойства Texture узла Sprite2D используйте res://assets/explosion.png. Вы заметите, что это спрайт-лист - изображение, состоящее из 64 меньших изображений, расположенных в сетке. Эти изображения представляют собой отдельные кадры анимации. Вы часто будете встречать анимации в таком формате, и узел Sprite2D в Godot поддерживает их использование.

В разделе Animation настроек спрайта в Инспекторе установите Vframes и Hframes оба равными 8. Это разделит спрайт-лист на 64 отдельных изображения. Вы можете проверить это, изменяя значение свойства Frame на различные значения от 0 до 63. Убедитесь, что вы установили его обратно на 0, прежде чем продолжить.

![ Sprite Animation settings ](/img/2-space/13.png)


Узел AnimationPlayer может использоваться для анимации любого свойства любого узла. Вы будете использовать его для изменения свойства Frame со временем. Начнем с выбора узла, и вы увидите открывающуюся внизу панель Animation:

![ Animation panel](/img/2-space/14.png)

Нажмите кнопку Animation и выберите New. Дайте анимации имя explosion. Установите длину анимации (Animation Length) на 0.64 и Snap to 0.01. Выберите узел Sprite2D, и вы заметите, что у каждого свойства в Инспекторе теперь есть символ ключа рядом с ним. Нажатие на ключ создаст ключевую точку в текущей анимации.


![  Animation time settings](/img/2-space/15.png)


Кликните на ключ рядом со свойством Frame у узла Explosion и подтвердите, что вы хотите создать новый трек анимации. Снимите выделение с опции Create RESET Track(s). Теперь вы создали ключевую точку, указывающую AnimationPlayer, что при времени 0 вы хотите, чтобы значение свойства Frame спрайта было равно 0.

Переместите ползунок времени к моменту 0.64 (вы можете регулировать масштаб с помощью ползунка, если не видите его). Установите значение Frame в 63 и снова нажмите на ключ. Теперь анимация знает, что нужно использовать последнее изображение в конечный момент времени анимации. Однако вам также нужно сообщить AnimationPlayer, что вы хотите использовать все промежуточные значения между этими двумя точками. Справа от трека анимации находится выпадающий список Update Mode. В настоящее время он установлен на Discrete, и вам нужно изменить его на Continuous:

![ Setting Update Mode ](/img/2-space/16.png)

Нажмите кнопку Play в панели Animation, чтобы посмотреть анимацию. Теперь вы можете добавить взрыв к астероиду. В сцене Rock добавьте экземпляр Explosion и щелкните по иконке глаза рядом с узлом, чтобы скрыть его. Добавьте следующую строку в функцию start():

```gdscript
$Explosion.scale = Vector2.ONE * 0.75 * size
```

Это гарантирует, что взрыв масштабируется в соответствии с размером астероида.

Добавьте сигнал с именем `exploded` в верхней части скрипта, затем добавьте функцию `explode()`, которая будет вызвана, когда пуля попадает в астероид:

```gdscript 
    func explode():
        $CollisionShape2D.set_deferred("disabled", true)
        $Sprite2d.hide()
        $Explosion/AnimationPlayer.play("explosion")
        $Explosion.show()
        exploded.emit(size, radius, position, linear_velocity)
        linear_velocity = Vector2.ZERO
        angular_velocity = 0
        await $Explosion/AnimationPlayer.animation_finished
        queue_free() 

```

Здесь вы скрываете астероид и воспроизводите анимацию взрыва, ожидая ее завершения перед удалением астероида. Когда вы отправляете сигнал `exploded`, вы также включаете всю информацию об астероиде, чтобы функция `spawn_rock()` в Main смогла создать более мелкие астероиды в том же месте.

Протестируйте игру и убедитесь, что вы видите взрывы, когда стреляете в астероиды.


## Создание более мелких астероидов

Сцена Rock излучает сигнал, но Main еще не слушает его. Вы не можете подключить сигнал во вкладке Node, потому что астероиды создаются в коде. Они будут существовать только позже, когда игра будет запущена. Добавьте эту строку в конец функции `spawn_rock()`:

```gdscript 
    r.exploded.connect(self._on_rock_exploded) 
```

Это подключает сигнал астероида к функции в Main, которую вам также нужно создать:

```gdscript 

    func _on_rock_exploded(size, radius, pos, vel):
        if size <= 1:
            return
        for offset in [-1, 1]:
            var dir = $Player.position.direction_to(pos)
            .orthogonal() * offset
            var newpos = pos + dir * radius
            var newvel = dir * vel.length() * 1.1
            spawn_rock(size - 1, newpos, newvel) 

```

В этой функции вы создаете два новых астероида, если только что уничтоженный астероид не был размера 1 (самого маленького размера). Переменная цикла смещения (offset) гарантирует, что два новых астероида движутся в противоположных направлениях (то есть скорость одного будет отрицательной). Переменная dir находит вектор между игроком и астероидом, затем использует orthogonal(), чтобы получить вектор, перпендикулярный к нему. Это гарантирует, что новые астероиды не летят прямо на игрока.

![ Explosion diagram  ](/img/2-space/17.png)

Сыграйте в игру еще раз и проверьте, что все работает ожидаемым образом.

Это отличное место для остановки и обзора того, что вы уже сделали. Вы завершили все основные функции игры: игрок может перемещаться и стрелять; астероиды плавают, отскакивают и взрываются; и появляются новые астероиды. На данном этапе вы должны чувствовать себя более уверенно в использовании жестких тел. В следующем разделе вы начнете создавать интерфейс, позволяющий игроку начать игру и видеть важную информацию во время геймплея.


## Создание пользовательского интерфейса (UI)

Создание UI для вашей игры может быть очень сложным или, по крайней мере, затратным по времени. Точное расположение отдельных элементов и обеспечение их работоспособности на различных экранах и устройствах — наименее интересная часть разработки игр для многих программистов. Godot предоставляет разнообразные узлы Control, чтобы помочь в этом процессе. Изучение различных узлов Control поможет уменьшить трудности создания отполированного пользовательского интерфейса.

Для этой игры вам не нужен очень сложный пользовательский интерфейс. Игра должна предоставлять следующую информацию и взаимодействие:

::list
   - Кнопка "Старт"
   - Статусное сообщение (например, "Готовьтесь" или "Конец игры")
   - Счет
   - Счетчик жизней
::

Вот предварительный просмотр того, что вы сделаете:

![UI layout](/img/2-space/18.png)

Создайте новую сцену и добавьте узел CanvasLayer с именем HUD в качестве корневого узла. Вы будете строить пользовательский интерфейс на этом слое, используя функции компоновки узла Control.

## Слои (Layers)

Узлы Control в Godot включают в себя несколько специализированных контейнеров. Эти узлы могут быть вложены друг в друга для создания необходимого макета. Например, MarginContainer автоматически добавляет отступ вокруг своего содержимого, в то время как HBoxContainer и VBoxContainer организуют свое содержимое в строки или столбцы соответственно.
Следуйте этим шагам для создания макета:

    1.Начните с добавления дочерних узлов Timer и MarginContainer, которые будут содержать счетчики очков и жизней. В выпадающем меню Layout выберите опцию Top Wide.

![Top Wide control alignment ](/img/2-space/19.png)

::list
 -  В Инспекторе установите четыре поля (margins) в разделе Theme Overrides/Constants равными 20.

 -   Установите свойство One Shot для Timer в положение on, а Wait Time в 2.

 -   Как дочерний узел контейнера добавьте HBoxContainer, который будет располагать счетчик очков слева, а счетчик жизней справа. В этот контейнер добавьте Label (назовите его ScoreLabel) и еще один HBoxContainer (названный LivesCounter).

::
Установите для текста ScoreLabel значение 0, и в разделе Layout/Container Sizing/Horizontal установите флажок Expand. В настройках Label добавьте шрифт, как вы делали в Главе 2, используя res://assets/kenvector_future_thin.ttf и установив размер шрифта равным 64.


::list

  -  Выберите LivesCounter и установите Theme Overrides/Constants/Separation равным 20, затем добавьте дочерний узел TextureRect и назовите его L1. Перетащите res://assets/player_small.png в свойство Texture и установите режим Stretch Mode в Keep Aspect Centered. Убедитесь, что у вас выбран узел L1, и нажмите Ctrl + D дважды, чтобы создать L2 и L3 (они будут автоматически названы). Во время игры на HUD будут отображаться или скрываться эти три текстуры, указывая, сколько жизней осталось у игрока.

  -  В более крупном и сложном пользовательском интерфейсе вы, возможно, сохранили бы этот раздел как отдельную сцену и внедрили бы ее в другие разделы пользовательского интерфейса. Однако для этой игры достаточно объединить все элементы в одну сцену.

  -  Как дочерний узел HUD, добавьте VBoxContainer, а внутри него добавьте Label с именем Message и TextureButton с именем StartButton. Установите макет VBoxContainer в Center Wide и Theme Overrides/Constants/Separation в 100.

 -   В папке res://assets есть две текстуры для StartButton, одна нормальная (play_button.png) и одна, которая будет отображаться, когда указатель мыши наведен на нее ('play_button_h.png). Перетащите их в Textures/Normal и Textures/Hover в инспекторе. Установите Layout/Container Sizing/Horizontal кнопки в Shrink Center, чтобы она была центрирована по горизонтали.

 -   Установите текст Message в "Space Rocks!" и установите его шрифт с теми же параметрами, что и у ScoreLabel. Установите горизонтальное выравнивание в Center.

::

Когда закончите, ваша сцена должна выглядеть следующим образом в дереве сцен:

 ![ HUD node layout](/img/2-space/20.png)

## Скрипты для пользовательского интерфейса

Вы завершили макет пользовательского интерфейса, теперь добавьте сценарий для HUD. Поскольку узлы, к которым вам нужно обращаться, находятся под контейнерами, вы можете сохранить ссылки на них в переменных в начале. Поскольку это должно произойти после добавления узлов в дерево, вы можете использовать декоратор @onready, чтобы значение переменной устанавливалось в то же время, когда выполняется функция _ready().


```gdscript
    extends CanvasLayer
    signal start_game
    @onready var lives_counter = $MarginContainer/HBoxContainer/LivesCounter.get_children()
    @onready var score_label = $MarginContainer/HBoxContainer/ScoreLabel
    @onready var message = $VBoxContainer/Message
    @onready var start_button = $VBoxContainer/StartButton 

```

Вы будете генерировать сигнал start_game, когда игрок нажимает на кнопку StartButton. Переменная lives_counter - это массив, содержащий ссылки на три изображения счетчика жизни, чтобы их можно было скрывать/показывать по мере необходимости. 
Далее вам нужны функции для обновления отображаемой информации:

```gdscript

    func show_message(text):
        message.text = text
        message.show()
        $Timer.start()
    func update_score(value):
        score_label.text = str(value)
    func update_lives(value):
        for item in 3:
            lives_counter[item].visible = value > item 

```

Main будет вызывать эти функции каждый раз, когда соответствующее значение изменяется. Теперь добавьте функцию для обработки конца игры:

```gdscript
    func game_over():
        show_message("Game Over")
        await $Timer.timeout
        start_button.show() 
```

Подключите сигнал pressed кнопки StartButton и сигнал timeout таймера:

```gdscript

    func _on_start_button_pressed():
        start_button.hide()
        start_game.emit()
    func _on_timer_timeout():
        message.hide()
        message.text = "" 

 ```  

## Код пользовательского интерфейса сцены Main:

Добавьте экземпляр сцены HUD к сцене Main. Добавьте эти переменные в main.gd:

```gdscript 
    var level = 0
    var score = 0
    var playing = false 

```  

И функцию для запуска новой игры:

```gdscript 
    func new_game():
        # remove any old rocks from previous game
        get_tree().call_group("rocks", "queue_free")
        level = 0
        score = 0
        $HUD.update_score(score)
        $HUD.show_message("Get Ready!")
        $Player.reset()
        await $HUD/Timer.timeout
        playing = true 
 ```  

Обратите внимание на строку $Player.reset() - не волнуйтесь, вы добавите ее вскоре.
Когда игрок уничтожит все камни, они перейдут на следующий уровень:

```gdscript 

    func new_level():
        level += 1
        $HUD.show_message("Wave %s" % level)
        for i in level:
            spawn_rock(3) 

```

Вы будете вызывать эту функцию каждый раз, когда меняется уровень. Она объявляет номер уровня и создает соответствующее количество камней. Обратите внимание, что, поскольку вы инициализировали переменную уровня (level) нулем, она установится в 1 для первого уровня. Вам также следует удалить код, который создает камни в функции _ready() - вам это больше не нужно. 
Чтобы определить, когда уровень завершен, вам нужно проверить, сколько камней осталось:


```gdscript 

    func _process(delta):
        if not playing:
            return
        if get_tree().get_nodes_in_group("rocks").size() == 0:
            new_level()

```

Далее вам нужно подключить сигнал start_game из HUD к функции new_game() в Main. 
Выберите экземпляр HUD в Main и найдите его сигнал start_game во вкладке **Node**. Нажмите **Connect**, но во всплывающем окне нажмите кнопку **Pick** рядом с Receiver Method. Вы увидите список функций в Main, и вы можете выбрать функцию new_game():

 ![ Connecting a signal to an existing function ](/img/2-space/21.png)


Добавьте эту функцию, чтобы обрабатывать события, происходящие при завершении игры:

```gdscript 

    func game_over():
        playing = false
        $HUD.game_over()
        
```

## Код игрока 
Добавьте новые сигналы и новую переменную в player.gd:
```gdscript 

    signal lives_changed
    signal dead
    var reset_pos = false
    var lives = 0: set = set_lives
    func set_lives(value):
        lives = value
        lives_changed.emit(lives)
        if lives <= 0:
            change_state(DEAD)
        else:
            change_state(INVULNERABLE) 

```

Для переменной lives вы добавили так называемый сеттер. Это означает, что каждый раз, когда меняется значение переменной lives, будет вызвана функция set_lives(). Это позволяет вам автоматически генерировать сигнал, а также проверять, достигло ли значение 0.
Функция reset() вызывается Main при запуске новой игры:

```gdscript 

    func reset():
        reset_pos = true
        $Sprite2d.show()
        lives = 3
        change_state(ALIVE) 
        
```

Сброс игрока означает установку его позиции обратно в центр экрана. Как мы видели ранее, это нужно сделать в функции _integrate_forces(), чтобы это работало. Добавьте это в эту функцию:

```gdscript 
    if reset_pos:
        physics_state.transform.origin = screensize / 2
        reset_pos = false 

```

Вернитесь в сцену Main, выберите экземпляр Player и найдите его сигнал lives_changed во вкладке Node. Нажмите Connect и в разделе Connect to Script выберите узел HUD и введите update_lives в Receiver Method.

 ![  Connecting the player signal to HUD ](/img/2-space/22.png)


На протяжении этого раздела вы создали гораздо более сложный пользовательский интерфейс по сравнению с предыдущими проектами, включая некоторые новые узлы управления, такие как TextureProgressBar, и использовали сигналы для связи всего вместе. В следующем разделе вы займетесь завершением игры: что должно произойти, когда игрок умирает.


## Завершение игры

В этом разделе вы заставите игрока обнаруживать, когда его поражают камни, добавите функцию неуязвимости и завершите игру, когда у игрока закончатся жизни. Добавьте экземпляр сцены Explosion к сцене Player и снимите отметку с ее свойства Visibility. Также добавьте узел Timer с именем InvulnerabilityTimer и установите Wait Time равным 2, а One Shot - "on".

Вы будете генерировать сигнал dead, чтобы уведомить Main, что игра должна завершиться. Однако перед этим вам нужно обновить конечный автомат, чтобы добавить еще несколько действий для каждого состояния:

```gdscript 
    func change_state(new_state):
        match new_state:
        INIT:
            $CollisionShape2D.set_deferred("disabled",true)
            $Sprite2D.modulate.a = 0.5
        ALIVE:
            $CollisionShape2d.set_deferred("disabled",false)
            $Sprite2d.modulate.a = 1.0
        INVULNERABLE:
            $CollisionShape2d.set_deferred("disabled",true)
            $Sprite2d.modulate.a = 0.5
            $InvulnerabilityTimer.start()
        DEAD:
            $CollisionShape2d.set_deferred("disabled",true)
            $Sprite2d.hide()
            linear_velocity = Vector2.ZERO
            dead.emit()
            state = new_state 

```

Свойство modulate.a спрайта устанавливает его альфа-канал (прозрачность). Установка его в 0.5 делает его полупрозрачным, в то время как 1.0 - полностью непрозрачным.

После перехода в состояние INVULNERABLE, вы запускаете таймер. Подключите его сигнал timeout:

```gdscript 

    func _on_invulnerability_timer_timeout():
        change_state(ALIVE) 

```

## Обнаружение столкновений между твердыми телами

Когда вы летаете вокруг, корабль отскакивает от камней, потому что оба являются твердыми телами. Однако, если вы хотите, чтобы что-то произошло, когда два твердых тела сталкиваются, вам нужно включить мониторинг контактов. В сцене Player выберите узел Player и в инспекторе установите Contact Monitor в on. По умолчанию никакие контакты не отслеживаются, поэтому установите Max Contacts Reported равным 1. Теперь игрок будет испускать сигнал, когда он приходит в контакт с другим телом. Нажмите на вкладку Node и подключите сигнал body_entered:

```gdscript 

    func _on_body_entered(body):
        if body.is_in_group("rocks"):
            body.explode()
            lives -= 1
            explode()
    func explode():
        $Explosion.show()
        $Explosion/AnimationPlayer.play("explosion")
        await $Explosion/AnimationPlayer.animation_finished
        $Explosion.hide() 

```

Теперь перейдите в сцену Main и подключите сигнал dead экземпляра Player к методу game_over(). Запустите игру и попробуйте столкнуться с камнем. Ваш корабль должен взорваться, стать неуязвимым на две секунды и потерять одну жизнь. Также проверьте, что игра заканчивается, если вас ударят три раза.

В этом разделе вы узнали о столкновениях твердых тел и использовали их для обработки столкновения корабля с камнями. Полный цикл игры теперь завершен: начальный экран ведет к геймплею, который завершается экраном завершения игры. В оставшихся разделах главы вы добавите несколько дополнительных функций в игру, таких как функцию паузы.

## Приостановка игры
Многие игры требуют какого-то рода режима паузы, чтобы позволить игроку отдохнуть от действия. В Godot пауза - это функция SceneTree и может быть установлена с использованием свойства paused. Когда SceneTree находится в состоянии паузы, происходит три важных события:

`The physics thread stops running 
_process() and _physics_process() are no longer called on any nodes 
The _input() and _input_event() methods are also not called for inputs `

Когда режим паузы активируется, каждый узел в работающей игре реагирует соответственно, в зависимости от того, как вы его настроили. Это поведение устанавливается через свойство Process/Mode узла, которое вы найдете ближе к концу списка в инспекторе.
Режим паузы можно установить в следующие значения:

::list
    - Наследовать – Узел использует тот же режим, что и его родитель.
    - Пауза – Узел приостанавливается, когда дерево сцены находится в режиме паузы.
    - При паузе – Узел выполняется только в случае, если дерево находится в режиме паузы.
    - Всегда – Узел всегда выполняется, игнорируя состояние паузы дерева.
    - Отключено – Узел никогда не выполняется, игнорируя состояние паузы дерева.
::

Откройте вкладку "Input Map" и создайте новое действие ввода с названием "pause". Назначьте клавишу, которую вы хотите использовать для включения/выключения режима паузы. Клавиша P - хороший выбор.

Добавьте следующую функцию в Main.gd:


```gdscript 

    func _input(event):
        if event.is_action_pressed("pause"):
            if not playing:
                return
            get_tree().paused = not get_tree().paused
            var message = $HUD/VBoxContainer/Message
            if get_tree().paused:
                message.text = "Paused"
                message.show()
            else:
                message.text = ""
                message.hide() 

```

Этот код обнаруживает нажатие клавиши и переключает состояние паузы дерева в противоположное текущему состоянию. Он также отображает "Paused" на экране, чтобы игра не выглядела как зависшая.

Если вы запустите игру сейчас, возникнет проблема - все узлы приостановлены, включая Main. Это означает, что он больше не обрабатывает _input(), поэтому он не может обнаруживать ввод снова, чтобы возобновить игру! Чтобы исправить это, установите режим Process Mode для узла Main в Always.

Функция паузы - очень полезная вещь, которую стоит знать. Вы можете использовать этот метод в любой игре, так что внимательно изучите его, чтобы удостовериться, что понимаете, как он работает. Вы даже можете вернуться и добавить его в Coin Dash. В следующем разделе мы добавим врагов в игру.



## Враги

Космос наполнен не только скалами, но и другими опасностями. В этом разделе вы создадите вражеский космический корабль, который будет периодически появляться и стрелять в игрока.

## Следуя по пути

Когда враг появляется, он должен следовать по пути через экран. Это также будет выглядеть лучше, если он не будет двигаться только прямо. Чтобы избежать чрезмерной однообразности, вы можете создать несколько путей и случайным образом выбирать один из них, когда враг появляется.

Создайте новую сцену и добавьте узел Node. Назовите его EnemyPaths и сохраните. Чтобы нарисовать путь, добавьте узел Path2D. Как вы видели ранее, этот узел позволяет рисовать серию соединенных точек. Выбор этого узла отображает новую панель меню:

![Path drawing options  ](/img/2-space/23.png)

Эти кнопки позволяют вам рисовать и изменять точки пути. Нажмите на ту, где зеленый символ +, чтобы добавить точки. Кликните, чтобы начать путь где-то вне игрового окна, а затем добавьте еще несколько точек, чтобы создать кривую. Обратите внимание, что стрелки указывают направление пути. Пока не беспокойтесь о том, чтобы сделать его гладким:

![An example path ](/img/2-space/24.png)

Когда враг следует по пути, это не будет выглядеть очень гладко, когда он достигнет острых углов. Чтобы сгладить кривую, щелкните вторую кнопку на панели инструментов пути (в ее всплывающей подсказке написано "Выбрать точки управления"). Теперь, если вы щелкнете и перетащите любую из точек кривой, вы добавите точку управления, которая позволит вам изгибать линию в этой точке. Сглаживание линии приведет к чему-то вроде этого:

![ Using control points ](/img/2-space/25.png)

Добавьте два или три дополнительных узла Path2D в сцену и нарисуйте пути так, как вам нравится. Добавление петель и изгибов вместо прямых линий сделает врага более динамичным (и сделает его сложнее поразить). Помните, что первая точка, которую вы щелкаете, будет началом пути, поэтому убедитесь, что они начинаются с разных сторон экрана для разнообразия. Вот три примера путей:

![  Adding multiple paths ](/img/2-space/26.png)

Сохраните сцену. Вы добавите ее в сцену врага, чтобы предоставить ему пути, по которым он сможет двигаться.

## Вражеская сцена

Создайте новую сцену для врага, используя в качестве корневого узла Area2D. Добавьте дочерний узел Sprite2D и используйте res:/ assets/enemy_saucer.png в качестве свойства Texture. Установите Animation/HFrames на 3, чтобы вы могли выбирать между разноцветными тарелками:

::list
  -  Как и ранее, добавьте CollisionShape2D и предоставьте ему масштабированную CircleShape2D для покрытия изображения. Добавьте экземпляр сцены EnemyPaths и AnimationPlayer. В AnimationPlayer вы добавите анимацию для создания эффекта вспышки при попадании в тарелку.

  -  Добавьте анимацию с именем "flash". Установите Length на 0,25 и Snap на 0,01. Свойство, которое вы будете анимировать, - это Modulate Sprite2D (найденное в Visibility). Добавьте ключевые кадры для Modulate, чтобы создать трек, затем переместите скребок на 0,04 и измените цвет Modulate на красный. Переместитесь еще на 0,04 и измените цвет обратно на белый.

  -  Повторите этот процесс еще два раза, чтобы у вас было три вспышки в общей сложности.

  -  Добавьте экземпляр сцены Explosion и скройте его. Добавьте узел Timer с именем GunCooldown для управления тем, как часто враг будет стрелять. Установите Wait Time на 1,5 и Autostart в положение "on".

  -  Добавьте сценарий врага и подключите событие таймера. Пока не добавляйте ничего в эту функцию.

  -  В разделе Node в Area2D добавьте его в группу с именем "enemies". Как и с камнями, это даст вам способ идентификации объекта, даже если на экране будет несколько врагов одновременно.

::

## Перемещение врага

Для начала напишем код для выбора пути и движения врага по нему:

```gdscript 

    extends Area2D
    @export var bullet_scene : PackedScene
    @export var speed = 150
    @export var rotation_speed = 120
    @export var health = 3
    var follow = PathFollow2D.new()
    var target = null
    func _ready():
        $Sprite2D.frame = randi() % 3
        var path = $EnemyPaths.get_children()[randi() % $EnemyPaths.get_child_count()]
        path.add_child(follow)
        follow.loop = false 

```

Напоминаем, что узел PathFollow2D автоматически перемещается вдоль родительского узла Path2D. По умолчанию он зацикливается вокруг пути, когда достигает конца, поэтому вам нужно установить это значение в false, чтобы отключить его.
Следующим шагом является движение вдоль пути и удаление врага, когда он достигает конца пути.

```gdscript 

func _physics_process(delta):
    rotation += deg_to_rad(rotation_speed) * delta
    follow.progress += speed * delta
    position = follow.global_position
    if follow.progress_ratio >= 1:
        queue_free() 

```

Вы можете обнаружить конец пути, когда значение progress становится больше общей длины пути. Тем не менее более простым будет использование progress_ratio, который изменяется от нуля до единицы в течение всей длины пути, так что вам не нужно знать длину каждого пути.


## Генерация врагов


В сцене Main добавьте новый узел Timer с именем EnemyTimer. Установите его свойство One Shot в "on". Затем в main.gd добавьте переменную для ссылки на сцену врага:

```gdscript
@export var enemy_scene : PackedScene
```

Добавьте следующую строку в функцию new_level():

```gdscript
    $EnemyTimer.start(randf_range(5, 10))
```

Подключите сигнал timeout EnemyTimer:

```gdscript
func _on_enemy_timer_timeout():
    var e = enemy_scene.instantiate()
    add_child(e)
    e.target = $Player
    $EnemyTimer.start(randf_range(20, 40))
```

Этот код создает врага, когда таймер EnemyTimer завершает отсчет. Вы не хотите создавать нового врага сразу после этого, поэтому таймер перезапускается с более длительной задержкой.
Запустите игру, и вы должны увидеть тарелку, появляющуюся и летящую вдоль своего пути.

## Стрельба и столкновения

Просто переведи текст: Враг должен стрелять в игрока, а также реагировать на попадание игрока или пуль игрока. Пуля врага будет похожей на пулю игрока, но мы будем использовать другую текстуру. Вы можете создать ее заново с нуля или воспользоваться следующим процессом для повторного использования узла. Откройте сцену Bullet и выберите Сцена | Сохранить сцену как, чтобы сохранить ее как enemy_bullet.tscn (после этого не забудьте переименовать корневой узел). Удалите сценарий, нажав кнопку Отсоединить сценарий. Отключите соединения сигналов, выбрав вкладку Узел и выбрав Отсоединить. Вы можете увидеть, какие узлы имеют подключенные сигналы, обратив внимание на иконку ![ Node ](/img/2-space/icon_node_1.png) рядом с именем узла. Замените текстуру спрайта изображением laser_green.png и добавьте новый сценарий к корневому узлу. Сценарий для пули врага будет очень похож на обычную пулю. Подключите сигнал body_entered области и сигнал screen_exited VisibleOnScreenNotifier2D:

```gdscript

    extends Area2D
    @export var speed = 1000
    func start(_pos, _dir):
        position = _pos
        rotation = _dir.angle()
    func _process(delta):
        position += transform.x * speed * delta
    func _on_body_entered(body):
        queue_free()
    func _on_visible_on_screen_notifier_2d_screen_exited():
        queue_free() 

```

Обратите внимание, что вам нужно указать позицию и направление для пули. Это потому, что, в отличие от игрока, который всегда стреляет вперед, враг всегда будет стрелять в сторону игрока.

На данный момент пуля не будет наносить урон игроку. Вы добавите защитный щит игроку в следующем разделе, и тогда сможете добавить его.

Сохраните сцену и перетащите ее в свойство Bullet объекта Enemy.

В enemy.gd добавьте переменную для некоторого случайного разнообразия для пули и функцию shoot():

```gdscript

    @export var bullet_spread = 0.2
    func shoot():
        var dir = global_position.direction_to(target.global_position)
        dir = dir.rotated(randf_range(-bullet_spread,bullet_spread))
        var b = bullet_scene.instantiate()
        get_tree().root.add_child(b)
        b.start(global_position, dir) 

```

Сначала вы находите вектор, указывающий на позицию игрока, затем добавляете немного случайности, чтобы пуля могла "промахнуться".
Вызывайте функцию shoot() при каждом завершении времени GunCooldown:

```gdscript

    func _on_gun_cooldown_timeout():
        shoot() 

```

Для дополнительного вызова вы можете заставить врага стрелять импульсами или несколькими быстрыми выстрелами:

```gdscript

    func shoot_pulse(n, delay):
        for i in n:
            shoot()
            await get_tree().create_timer(delay).timeout 

```

Это будет выпускать заданное количество пуль, n, с интервалом в delay секунд между ними. Вы можете вызвать это вместо того, когда срабатывает откат:

```gdscript
func _on_gun_cooldown_timeout():
    shoot_pulse(3, 0.15)
```

Это вызовет импульс из 3 пуль с интервалом в 0.15 секунды между ними. Трудно уклониться!

Далее врагу необходимо получать урон, когда его поражает выстрел от игрока. Он будет мигать с использованием созданной вами анимации, а затем взорвется, когда его здоровье достигнет 0.

Добавьте эти функции в enemy.gd:

```gdscript
func take_damage(amount):
    health -= amount
    $AnimationPlayer.play("flash")
    if health <= 0:
        explode()

func explode():
    speed = 0
    $GunCooldown.stop()
    $CollisionShape2D.set_deferred("disabled", true)
    $Sprite2D.hide()
    $Explosion.show()
    $Explosion/AnimationPlayer.play("explosion")
    await $Explosion/AnimationPlayer.animation_finished
    queue_free()
```

Также подключите сигнал body_entered врага, чтобы враг взорвался, если игрок сталкивается с ним:

```gdscript
    func _on_body_entered(body):
        if body.is_in_group("rocks"):
            return
        explode() 
```

Опять же, вы ждете реализации щита игрока, прежде чем наносить урон игроку, поэтому на данный момент эта коллизия только разрушает врага.

В настоящее время пуля игрока обнаруживает только камни, потому что ее сигнал body_entered не срабатывает при столкновении с врагом, который является объектом Area2D. Чтобы обнаружить врага, перейдите в сцену Bullet и подключите сигнал area_entered:

```gdscript
func _on_area_entered(area):
    if area.is_in_group("enemies"):
        area.take_damage(1)
```

Попробуйте снова поиграть, и вы столкнетесь с агрессивным пришельцем-противником! Убедитесь, что все комбинации столкновений обрабатываются (за исключением того, что враг стреляет в игрока). Также обратите внимание, что пули врага могут быть заблокированы камнями - возможно, вы сможете спрятаться за ними!

Теперь, когда в игре есть враги, она стала намного сложнее. Если вы по-прежнему считаете ее слишком легкой, попробуйте увеличить характеристики врага: как часто он появляется, сколько урона он наносит и сколько выстрелов ему требуется, чтобы уничтожить его. Это нормально, если вы сделаете его слишком сложным, потому что в следующем разделе вы добавите игроку небольшую поддержку, добавив щит для поглощения урона.

## Щит игрока

В этом разделе вы добавите щит для игрока и элемент отображения в HUD, показывающий текущий уровень щита.

Сначала добавьте следующий код в верхнюю часть скрипта player.gd:

```gdscript
signal shield_changed
@export var max_shield = 100.0
@export var shield_regen = 5.0
var shield = 0: set = set_shield

func set_shield(value):
    value = min(value, max_shield)
    shield = value
    shield_changed.emit(shield / max_shield)
    if shield <= 0:
        lives -= 1
        explode()
```

Переменная `shield` работает аналогично `lives`, отправляя сигнал каждый раз, когда ее значение изменяется. Поскольку значение будет увеличиваться за счет регенерации щита, вам нужно убедиться, что оно не превышает значение `max_shield`. Затем, когда вы отправляете сигнал `shield_changed`, передавайте соотношение `shield / max_shield`, а не фактическое значение. Таким образом, отображение в HUD не должно знать ничего о том, насколько большим является щит, а только о его процентном содержании.

Также вы должны удалить строку `explode()` из `_on_body_entered()`, поскольку теперь вы не хотите, чтобы просто столкновение с камнем взрывало корабль - это произойдет только тогда, когда щит закончится.

Столкновение с камнем повредит щит, а более крупные камни должны наносить больше урона:

```gdscript
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        shield -= body.size * 25
        body.explode()
```

Пули врага также должны наносить урон, так что внесите эту правку в enemy_bullet.gd:
```gdscript

    @export var damage = 15
    func _on_body_entered(body):
        if body.name == "Player":
            body.shield -= damage
            queue_free() 

```

Кроме того, столкновение с врагом должно повреждать игрока, поэтому обновите это в enemy.gd:

```gdscript
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        return
    explode()
    body.shield -= 50
```

Если щит игрока заканчивается, и он теряет жизнь, вы должны сбросить щит до его максимального значения. Добавьте эту строку в set_lives() в main.gd:

```gdscript
shield = max_shield
```

Последнее дополнение к скрипту игрока - восстановление щита каждый кадр. Добавьте эту строку в _process() в player.gd:

```gdscript
shield += shield_regen * delta
```

Теперь, когда код завершен, вам нужно добавить новый элемент отображения в сцену HUD. Вместо отображения значения щита в виде числа, вы создадите полосу прогресса. TextureProgressBar - это узел Control, который отображает заданное значение в виде заполненной полосы. Кроме того, он позволяет присвоить текстуру для использования в полосе.

Перейдите к сцене HUD и добавьте два новых узла в качестве дочерних для существующего HBoxContainer: TextureRect и TextureProgressBar. Переименуйте TextureProgressBar в ShieldBar. Разместите их после метки Score и перед LivesCounter. Ваша структура узлов должна выглядеть так:

![Updated HUD node layout ](/img/2-space/27.png)



Перетащите res://assets/shield_gold.png в свойство **Texture** у **TextureRect**. Это будет значок, указывающий, что эта полоса отображает значение щита. Измените  **Stretch Mode** на **Keep Centered**, чтобы текстура не искажалась.

У **ShieldBar** есть три текстурных свойства: Under, Over и Progress. Progress - это текстура, которая будет использоваться для значения полосы. Перетащите res://assets/bar_green_200.png в это свойство. Другие две текстурные свойства позволяют настроить внешний вид, установив изображение, которое будет нарисовано выше или ниже текстуры прогресса. Перетащите res://assets/bar_glass_200.png в свойство Over.

В разделе Range вы можете установить числовые свойства полосы. **Min Value** и **Max Value** должны быть установлены на 0 и 1, поскольку эта полоса будет отображать отношение щита к его максимуму, а не его числовое значение. Это также означает, что Step должен быть меньше - установите его равным 0.01. Value - это свойство, которое управляет тем, насколько полная должна быть полоса. Измените его на 0,75, чтобы видеть частично заполненную полосу. Также в разделе Layout/Container Sizing установите флажок Expand и установите **Vertical** в **Shrink Center**.

HUD должен выглядеть примерно так после завершения:

![ Updated HUD with shield bar ](/img/2-space/28.png)

Теперь вы можете обновить скрипт для установки значения панели щита, а также изменить ее цвет по мере приближения к нулю. Добавьте следующие переменные в hud.gd:

```gdscript
@onready var shield_bar = $MarginContainer/HBoxContainer/ShieldBar
var bar_textures = {
    "green": preload("res://assets/bar_green_200.png"),
    "yellow": preload("res://assets/bar_yellow_200.png"),
    "red": preload("res://assets/bar_red_200.png")
}
```

Кроме зеленой полосы, у вас также есть красные и желтые полосы в папке с ресурсами. Это позволяет вам изменять цвет полосы щита по мере уменьшения значения. Загрузка текстур таким образом облегчит доступ к ним позже в скрипте, когда вам нужно будет присвоить соответствующее изображение панели:

```gdscript
func update_shield(value):
    shield_bar.texture_progress = bar_textures["green"]
    if value < 0.4:
        shield_bar.texture_progress = bar_textures["red"]
    elif value < 0.7:
        shield_bar.texture_progress = bar_textures["yellow"]
    shield_bar.value = value
```

Наконец, щелкните на узле Player в главной сцене и подключите сигнал shield_changed к функции update_shield() в HUD.

Запустите игру и проверьте, что щит работает. Вам может потребоваться увеличить или уменьшить скорость восстановления щита, чтобы получить подходящую для вас скорость. Когда вы будете готовы перейти к следующему этапу, в следующем разделе вы добавите звук в игру.,


## Звук и визуальные эффекты

Структура и геймплей игры завершены. В этом разделе вы добавите несколько дополнительных эффектов, чтобы улучшить игровой опыт.

## Звук и музыка

В папке res://assets/sounds есть несколько звуковых эффектов для игры. Чтобы воспроизвести звук, его нужно загрузить с помощью узла AudioStreamPlayer. Добавьте два таких узла в сцену Player, называя их LaserSound и EngineSound. Перетащите соответствующие звуковые файлы в свойство Stream каждого узла в инспекторе. Чтобы воспроизводить звук при стрельбе, добавьте эту строку в функцию shoot() в player.gd:

```gdscript
$LaserSound.play()
```
Запустите игру и попробуйте стрелять. Если звук вам кажется слишком громким, вы можете отрегулировать свойство Volume dB. Попробуйте начать с значением -10.

Звук двигателя работает немного по-другому. Он должен воспроизводиться, когда включено ускорение, но если вы просто попробуете вызвать play() для звука в функции get_input(), когда игрок нажимает клавишу, звук будет запускаться заново на каждом кадре. Это не звучит хорошо, поэтому вы хотите начать воспроизведение звука только в том случае, если он еще не воспроизводится. Вот соответствующий участок функции get_input():
```gdscript
if Input.is_action_just_pressed("thrust") and not $EngineSound.playing:
    $EngineSound.play()
elif Input.is_action_just_released("thrust"):
    $EngineSound.stop()
```


Обратите внимание, что может возникнуть проблема: если игрок умирает, удерживая клавишу ускорения, звук двигателя останется застрявшим во воспроизведении, потому что в состоянии DEAD вы игнорируете ввод игрока. Это можно решить, добавив $EngineSound.stop() в состояние DEAD в функции change_state().

В сцене Main добавьте еще три узла AudioStreamPlayer: ExplosionSound, LevelupSound и Music. В свойствах Stream перетащите файлы explosion.wav, levelup.ogg и Funky Gameplay_Looping.ogg.

Добавьте $ExplosionSound.play() в качестве первой строки в функции _on_rock_exploded(), и добавьте $LevelupSound.play() в функцию new_level().

Чтобы воспроизводить и останавливать фоновую музыку, добавьте $Music.play() в функцию new_game() и $Music.stop() в game_over(). Также врагу потребуются узлы ExplosionSound и ShootSound. Вы можете использовать enemy_laser.wav для звука их выстрелов.


## Частицы

Факел корабля игрока - это отличное применение эффектов частиц, создающих поток пламени от двигателя.

Добавьте узел CPUParticles2D и назовите его Exhaust. Возможно, вам захочется увеличить масштаб корабля во время выполнения этой части.

## Типы узлов частиц

Godot предлагает два типа узлов для работы с частицами: один использует ЦП, а другой - ГП для рендеринга. Поскольку не все платформы, особенно мобильные устройства или старые настольные компьютеры, поддерживают аппаратное ускорение для частиц, вы можете использовать версию для ЦП для более широкой совместимости. Если вы знаете, что ваша игра будет работать на более мощных системах, вы можете использовать версию для ГП.

Теперь вы видите строку белых точек, вытекающих из центра корабля. Вашей задачей является превращение этих точек в пламя факела.

При настройке этого эффекта у вас есть очень большое количество свойств на выбор. Пробуйте разные параметры, чтобы увидеть, как они влияют на результат.

Установите следующие свойства узла Exhaust:

`Amount : 25 
Drawing/Local Coords : On 
Transform/Position: (- 28, 0) 
Transform/Rotation : 180 
Visibility/Show Behind Parent : On `

Оставшиеся свойства, которые вы измените, будут влиять на поведение частиц. Начнем с Формы излучения: измените ее на Прямоугольник. Это позволит установить Размеры прямоугольника в (1, 5). Теперь частицы излучаются в пределах небольшой области, а не в одной точке.

Затем установите Направление/Разброс в 0 и Гравитацию в (0, 0). Обратите внимание, что частицы не падают и не распространяются, хотя они двигаются очень медленно.

Установите Максимальную начальную скорость/Максимальная скорость на 400, а затем прокрутите вниз к Размеру/Максимальному размеру и установите его на 8.

Чтобы изменять размер со временем, вы можете установить Кривую размера. Выберите Новую кривую, а затем щелкните, чтобы открыть ее. В небольшом графике справа щелкните правой кнопкой мыши, чтобы добавить две точки - одну слева и одну справа. Перетащите правую точку вниз, пока кривая не будет выглядеть так:

![Adding a particle scale curve ](/img/2-space/29.png)


Теперь вы должны видеть, как частицы уменьшаются по мере того, как они выходят из задней части корабля.

Последний раздел для настройки - это Цвет. Чтобы частицы выглядели как пламя, они должны начинаться ярко оранжево-желтыми и постепенно переходить в красный при затухании. В свойстве Цветовая рамка щелкните на Новый градиент, и вы увидите редактор градиента, который выглядит так:

![ Color Ramp settings](/img/2-space/30.png)


Два прямоугольных ползунка с метками 1 и 2 устанавливают начальные и конечные цвета градиента. Нажатие на любой из них покажет его цвет в ячейке с меткой 3. Выберите ползунок 1, а затем щелкните по ячейке 3, чтобы открыть выбор цвета. Выберите оранжевый цвет, и сделайте то же самое для ползунка 2, выбрав темно-красный цвет.

Теперь, когда частицы имеют правильный вид, они слишком долго существуют. В разделе  Time установите Lifetime в 0,1. Надеюсь, что исходящий поток из вашего корабля выглядит как пламя. Если это не так, не стесняйтесь настраивать параметры до тех пор, пока вам не понравится результат.

Как только пламя выглядит хорошо, его нужно включить и выключить в зависимости от ввода игрока. Перейдите в player.gd и добавьте $Exhaust.emitting = false в начало функции get_input(). Затем под if-условием, проверяющим ввод на тягу, добавьте $Exhaust.emitting = true.



## Преследование врага
Вы также можете использовать частицы, чтобы придать вражескому летающему блюду сверкающий след. Добавьте узел CPUParticles2D в сцену врага и настройте следующие параметры:

- Amount (Количество): 20
- Visibility/Show Behind Parent (Видимость/Показывать за родителем): Включено
- Emission Shape/Shape (Форма излучения): Sphere (Сфера)
- Emission Shape/Sphere Radius (Радиус сферы): 25
- Gravity (Гравитация): (0, 0)

Теперь у вас должны появиться частицы по всему радиусу летающего блюда (вы можете скрыть Sprite2D во время этого этапа, если хотите их лучше видеть). Форма частиц по умолчанию – это квадрат, но вы также можете использовать текстуру для еще более привлекательного визуального эффекта. Добавьте res://assets/corona.png в раздел Drawing/Texture (Рисование/Текстура).

Это изображение создает красивый свечение, но оно довольно крупное по сравнению с блюдцем, поэтому установите Scale/Scale Amount Max (Масштаб/Максимальное количество масштаба) в 0.1. Вы также заметите, что это изображение белое на черном фоне. Для корректного отображения его нужно изменить в режиме смешивания. Для этого найдите свойство Material и выберите New CanvasItemMaterial. Там вы можете изменить Blend Mode (Режим смешивания) с Mix (Смешивание) на Add (Сложение).

Наконец, вы можете заставить частицы исчезнуть, используя Scale Amount Curve в разделе Scale (Масштаб), так же, как вы сделали с частицами игрока.

Запустите вашу игру и наслаждайтесь эффектами. Что еще вы можете добавить с использованием частиц?


## Итог
В этой главе вы узнали, как работать с узлами RigidBody2D и получили больше информации о том, как работает физика в Godot. Вы также реализовали базовую конечную машину состояний – что-то, что будет полезным по мере роста ваших проектов и что вы будете использовать снова в будущих главах. Вы видели, как Узлы-Контейнеры помогают организовывать и поддерживать выравнивание узлов пользовательского интерфейса.

В конечном итоге вы добавили звуковые эффекты и познакомились с основами продвинутых визуальных эффектов, используя узлы Animation и CPUParticles2D.

Вы также продолжили создание игровых объектов с использованием стандартных иерархий Godot, таких как CollisionShapes, присоединенных к CollisionObjects, и сигналов, используемых для обмена информацией между узлами. На этом этапе эти практики должны начать казаться вам знакомыми.

Готовы ли вы попробовать создать этот проект самостоятельно? Попробуйте повторить все, или даже часть, этой главы, не заглядывая в книгу. Это отличный способ проверить, какую информацию вы усвоили, и что вам нужно пересмотреть. Вы также можете попробовать создать его с вашими собственными вариациями, а не делать точную копию.

Когда вы будете готовы двигаться дальше, в следующей главе вы создадите еще один стиль игры, который очень популярен: платформер в традициях Super Mario Bros.