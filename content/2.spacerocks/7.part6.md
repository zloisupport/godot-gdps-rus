# Щит игрока

В этом разделе вы добавите щит для игрока и элемент отображения в HUD, показывающий текущий уровень щита.

Сначала добавьте следующий код в верхнюю часть скрипта player.gd:

```gdscript
signal shield_changed
@export var max_shield = 100.0
@export var shield_regen = 5.0
var shield = 0: set = set_shield

func set_shield(value):
    value = min(value, max_shield)
    shield = value
    shield_changed.emit(shield / max_shield)
    if shield <= 0:
        lives -= 1
        explode()
```

Переменная `shield` работает аналогично `lives`, отправляя сигнал каждый раз, когда ее значение изменяется. Поскольку значение будет увеличиваться за счет регенерации щита, вам нужно убедиться, что оно не превышает значение `max_shield`. Затем, когда вы отправляете сигнал `shield_changed`, передавайте соотношение `shield / max_shield`, а не фактическое значение. Таким образом, отображение в HUD не должно знать ничего о том, насколько большим является щит, а только о его процентном содержании.

Также вы должны удалить строку `explode()` из `_on_body_entered()`, поскольку теперь вы не хотите, чтобы просто столкновение с камнем взрывало корабль - это произойдет только тогда, когда щит закончится.

Столкновение с камнем повредит щит, а более крупные камни должны наносить больше урона:

```gdscript
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        shield -= body.size * 25
        body.explode()
```

Пули врага также должны наносить урон, так что внесите эту правку в enemy_bullet.gd:
```gdscript
@export var damage = 15
func _on_body_entered(body):
    if body.name == "Player":
        body.shield -= damage
        queue_free() 
```

Кроме того, столкновение с врагом должно повреждать игрока, поэтому обновите это в enemy.gd:

```gdscript
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        return
    explode()
    body.shield -= 50
```

Если щит игрока заканчивается, и он теряет жизнь, вы должны сбросить щит до его максимального значения. Добавьте эту строку в set_lives() в main.gd:

```gdscript
shield = max_shield
```

Последнее дополнение к скрипту игрока - восстановление щита каждый кадр. Добавьте эту строку в _process() в player.gd:

```gdscript
shield += shield_regen * delta
```

Теперь, когда код завершен, вам нужно добавить новый элемент отображения в сцену HUD. Вместо отображения значения щита в виде числа, вы создадите полосу прогресса. TextureProgressBar - это узел Control, который отображает заданное значение в виде заполненной полосы. Кроме того, он позволяет присвоить текстуру для использования в полосе.

Перейдите к сцене HUD и добавьте два новых узла в качестве дочерних для существующего HBoxContainer: TextureRect и TextureProgressBar. Переименуйте TextureProgressBar в ShieldBar. Разместите их после метки Score и перед LivesCounter. Ваша структура узлов должна выглядеть так:

![Updated HUD node layout ](/img/2-space/27.png)



Перетащите res://assets/shield_gold.png в свойство **Texture** у **TextureRect**. Это будет значок, указывающий, что эта полоса отображает значение щита. Измените  **Stretch Mode** на **Keep Centered**, чтобы текстура не искажалась.

У **ShieldBar** есть три текстурных свойства: Under, Over и Progress. Progress - это текстура, которая будет использоваться для значения полосы. Перетащите res://assets/bar_green_200.png в это свойство. Другие две текстурные свойства позволяют настроить внешний вид, установив изображение, которое будет нарисовано выше или ниже текстуры прогресса. Перетащите res://assets/bar_glass_200.png в свойство Over.

В разделе Range вы можете установить числовые свойства полосы. **Min Value** и **Max Value** должны быть установлены на 0 и 1, поскольку эта полоса будет отображать отношение щита к его максимуму, а не его числовое значение. Это также означает, что Step должен быть меньше - установите его равным 0.01. Value - это свойство, которое управляет тем, насколько полная должна быть полоса. Измените его на 0,75, чтобы видеть частично заполненную полосу. Также в разделе Layout/Container Sizing установите флажок Expand и установите **Vertical** в **Shrink Center**.

HUD должен выглядеть примерно так после завершения:

![ Updated HUD with shield bar ](/img/2-space/28.png)

Теперь вы можете обновить скрипт для установки значения панели щита, а также изменить ее цвет по мере приближения к нулю. Добавьте следующие переменные в hud.gd:

```gdscript
@onready var shield_bar = $MarginContainer/HBoxContainer/ShieldBar
var bar_textures = {
    "green": preload("res://assets/bar_green_200.png"),
    "yellow": preload("res://assets/bar_yellow_200.png"),
    "red": preload("res://assets/bar_red_200.png")
}
```

Кроме зеленой полосы, у вас также есть красные и желтые полосы в папке с ресурсами. Это позволяет вам изменять цвет полосы щита по мере уменьшения значения. Загрузка текстур таким образом облегчит доступ к ним позже в скрипте, когда вам нужно будет присвоить соответствующее изображение панели:

```gdscript
func update_shield(value):
    shield_bar.texture_progress = bar_textures["green"]
    if value < 0.4:
        shield_bar.texture_progress = bar_textures["red"]
    elif value < 0.7:
        shield_bar.texture_progress = bar_textures["yellow"]
    shield_bar.value = value
```

Наконец, щелкните на узле Player в главной сцене и подключите сигнал shield_changed к функции update_shield() в HUD.

Запустите игру и проверьте, что щит работает. Вам может потребоваться увеличить или уменьшить скорость восстановления щита, чтобы получить подходящую для вас скорость. Когда вы будете готовы перейти к следующему этапу, в следующем разделе вы добавите звук в игру.,


## Звук и визуальные эффекты

Структура и геймплей игры завершены. В этом разделе вы добавите несколько дополнительных эффектов, чтобы улучшить игровой опыт.

## Звук и музыка

В папке res://assets/sounds есть несколько звуковых эффектов для игры. Чтобы воспроизвести звук, его нужно загрузить с помощью узла AudioStreamPlayer. Добавьте два таких узла в сцену Player, называя их LaserSound и EngineSound. Перетащите соответствующие звуковые файлы в свойство Stream каждого узла в инспекторе. Чтобы воспроизводить звук при стрельбе, добавьте эту строку в функцию shoot() в player.gd:

```gdscript
$LaserSound.play()
```
Запустите игру и попробуйте стрелять. Если звук вам кажется слишком громким, вы можете отрегулировать свойство Volume dB. Попробуйте начать с значением -10.

Звук двигателя работает немного по-другому. Он должен воспроизводиться, когда включено ускорение, но если вы просто попробуете вызвать play() для звука в функции get_input(), когда игрок нажимает клавишу, звук будет запускаться заново на каждом кадре. Это не звучит хорошо, поэтому вы хотите начать воспроизведение звука только в том случае, если он еще не воспроизводится. Вот соответствующий участок функции get_input():
```gdscript
if Input.is_action_just_pressed("thrust") and not $EngineSound.playing:
    $EngineSound.play()
elif Input.is_action_just_released("thrust"):
    $EngineSound.stop()
```


Обратите внимание, что может возникнуть проблема: если игрок умирает, удерживая клавишу ускорения, звук двигателя останется застрявшим во воспроизведении, потому что в состоянии DEAD вы игнорируете ввод игрока. Это можно решить, добавив $EngineSound.stop() в состояние DEAD в функции change_state().

В сцене Main добавьте еще три узла AudioStreamPlayer: ExplosionSound, LevelupSound и Music. В свойствах Stream перетащите файлы explosion.wav, levelup.ogg и Funky Gameplay_Looping.ogg.

Добавьте $ExplosionSound.play() в качестве первой строки в функции _on_rock_exploded(), и добавьте $LevelupSound.play() в функцию new_level().

Чтобы воспроизводить и останавливать фоновую музыку, добавьте $Music.play() в функцию new_game() и $Music.stop() в game_over(). Также врагу потребуются узлы ExplosionSound и ShootSound. Вы можете использовать enemy_laser.wav для звука их выстрелов.


## Частицы

Факел корабля игрока - это отличное применение эффектов частиц, создающих поток пламени от двигателя.

Добавьте узел CPUParticles2D и назовите его Exhaust. Возможно, вам захочется увеличить масштаб корабля во время выполнения этой части.

## Типы узлов частиц

Godot предлагает два типа узлов для работы с частицами: один использует ЦП, а другой - ГП для рендеринга. Поскольку не все платформы, особенно мобильные устройства или старые настольные компьютеры, поддерживают аппаратное ускорение для частиц, вы можете использовать версию для ЦП для более широкой совместимости. Если вы знаете, что ваша игра будет работать на более мощных системах, вы можете использовать версию для ГП.

Теперь вы видите строку белых точек, вытекающих из центра корабля. Вашей задачей является превращение этих точек в пламя факела.

При настройке этого эффекта у вас есть очень большое количество свойств на выбор. Пробуйте разные параметры, чтобы увидеть, как они влияют на результат.

Установите следующие свойства узла Exhaust:

`Amount : 25 
Drawing/Local Coords : On 
Transform/Position: (- 28, 0) 
Transform/Rotation : 180 
Visibility/Show Behind Parent : On `

Оставшиеся свойства, которые вы измените, будут влиять на поведение частиц. Начнем с Формы излучения: измените ее на Прямоугольник. Это позволит установить Размеры прямоугольника в (1, 5). Теперь частицы излучаются в пределах небольшой области, а не в одной точке.

Затем установите Направление/Разброс в 0 и Гравитацию в (0, 0). Обратите внимание, что частицы не падают и не распространяются, хотя они двигаются очень медленно.

Установите Максимальную начальную скорость/Максимальная скорость на 400, а затем прокрутите вниз к Размеру/Максимальному размеру и установите его на 8.

Чтобы изменять размер со временем, вы можете установить Кривую размера. Выберите Новую кривую, а затем щелкните, чтобы открыть ее. В небольшом графике справа щелкните правой кнопкой мыши, чтобы добавить две точки - одну слева и одну справа. Перетащите правую точку вниз, пока кривая не будет выглядеть так:

![Adding a particle scale curve ](/img/2-space/29.png)


Теперь вы должны видеть, как частицы уменьшаются по мере того, как они выходят из задней части корабля.

Последний раздел для настройки - это Цвет. Чтобы частицы выглядели как пламя, они должны начинаться ярко оранжево-желтыми и постепенно переходить в красный при затухании. В свойстве Цветовая рамка щелкните на Новый градиент, и вы увидите редактор градиента, который выглядит так:

![ Color Ramp settings](/img/2-space/30.png)


Два прямоугольных ползунка с метками 1 и 2 устанавливают начальные и конечные цвета градиента. Нажатие на любой из них покажет его цвет в ячейке с меткой 3. Выберите ползунок 1, а затем щелкните по ячейке 3, чтобы открыть выбор цвета. Выберите оранжевый цвет, и сделайте то же самое для ползунка 2, выбрав темно-красный цвет.

Теперь, когда частицы имеют правильный вид, они слишком долго существуют. В разделе  Time установите Lifetime в 0,1. Надеюсь, что исходящий поток из вашего корабля выглядит как пламя. Если это не так, не стесняйтесь настраивать параметры до тех пор, пока вам не понравится результат.

Как только пламя выглядит хорошо, его нужно включить и выключить в зависимости от ввода игрока. Перейдите в player.gd и добавьте $Exhaust.emitting = false в начало функции get_input(). Затем под if-условием, проверяющим ввод на тягу, добавьте $Exhaust.emitting = true.



## Преследование врага
Вы также можете использовать частицы, чтобы придать вражескому летающему блюду сверкающий след. Добавьте узел CPUParticles2D в сцену врага и настройте следующие параметры:

- Amount (Количество): 20
- Visibility/Show Behind Parent (Видимость/Показывать за родителем): Включено
- Emission Shape/Shape (Форма излучения): Sphere (Сфера)
- Emission Shape/Sphere Radius (Радиус сферы): 25
- Gravity (Гравитация): (0, 0)

Теперь у вас должны появиться частицы по всему радиусу летающего блюда (вы можете скрыть Sprite2D во время этого этапа, если хотите их лучше видеть). Форма частиц по умолчанию – это квадрат, но вы также можете использовать текстуру для еще более привлекательного визуального эффекта. Добавьте res://assets/corona.png в раздел Drawing/Texture (Рисование/Текстура).

Это изображение создает красивый свечение, но оно довольно крупное по сравнению с блюдцем, поэтому установите Scale/Scale Amount Max (Масштаб/Максимальное количество масштаба) в 0.1. Вы также заметите, что это изображение белое на черном фоне. Для корректного отображения его нужно изменить в режиме смешивания. Для этого найдите свойство Material и выберите New CanvasItemMaterial. Там вы можете изменить Blend Mode (Режим смешивания) с Mix (Смешивание) на Add (Сложение).

Наконец, вы можете заставить частицы исчезнуть, используя Scale Amount Curve в разделе Scale (Масштаб), так же, как вы сделали с частицами игрока.

Запустите вашу игру и наслаждайтесь эффектами. Что еще вы можете добавить с использованием частиц?
