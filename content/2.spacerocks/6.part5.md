# Обнаружение столкновений между твердыми телами

Когда вы летаете вокруг, корабль отскакивает от камней, потому что оба являются твердыми телами. Однако, если вы хотите, чтобы что-то произошло, когда два твердых тела сталкиваются, вам нужно включить мониторинг контактов. В сцене Player выберите узел Player и в инспекторе установите Contact Monitor в on. По умолчанию никакие контакты не отслеживаются, поэтому установите Max Contacts Reported равным 1. Теперь игрок будет испускать сигнал, когда он приходит в контакт с другим телом. Нажмите на вкладку Node и подключите сигнал body_entered:

```gdscript 
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        body.explode()
        lives -= 1
        explode()
func explode():
    $Explosion.show()
    $Explosion/AnimationPlayer.play("explosion")
    await $Explosion/AnimationPlayer.animation_finished
    $Explosion.hide() 
```

Теперь перейдите в сцену Main и подключите сигнал dead экземпляра Player к методу game_over(). Запустите игру и попробуйте столкнуться с камнем. Ваш корабль должен взорваться, стать неуязвимым на две секунды и потерять одну жизнь. Также проверьте, что игра заканчивается, если вас ударят три раза.

В этом разделе вы узнали о столкновениях твердых тел и использовали их для обработки столкновения корабля с камнями. Полный цикл игры теперь завершен: начальный экран ведет к геймплею, который завершается экраном завершения игры. В оставшихся разделах главы вы добавите несколько дополнительных функций в игру, таких как функцию паузы.

## Приостановка игры
Многие игры требуют какого-то рода режима паузы, чтобы позволить игроку отдохнуть от действия. В Godot пауза - это функция SceneTree и может быть установлена с использованием свойства paused. Когда SceneTree находится в состоянии паузы, происходит три важных события:

::list
    - Поток физики перестает выполняться.
    - Методы _process() и _physics_process() больше не вызываются для любых узлов.
    - Также не вызываются методы _input() и _input_event() для вводов.
::

Когда режим паузы активируется, каждый узел в работающей игре реагирует соответственно, в зависимости от того, как вы его настроили. Это поведение устанавливается через свойство Process/Mode узла, которое вы найдете ближе к концу списка в инспекторе.
Режим паузы можно установить в следующие значения:

::list
    - Наследовать – Узел использует тот же режим, что и его родитель.
    - Пауза – Узел приостанавливается, когда дерево сцены находится в режиме паузы.
    - При паузе – Узел выполняется только в случае, если дерево находится в режиме паузы.
    - Всегда – Узел всегда выполняется, игнорируя состояние паузы дерева.
    - Отключено – Узел никогда не выполняется, игнорируя состояние паузы дерева.
::

Откройте вкладку "Input Map" и создайте новое действие ввода с названием "pause". Назначьте клавишу, которую вы хотите использовать для включения/выключения режима паузы. Клавиша P - хороший выбор.

Добавьте следующую функцию в Main.gd:


```gdscript 
func _input(event):
    if event.is_action_pressed("pause"):
        if not playing:
            return
        get_tree().paused = not get_tree().paused
        var message = $HUD/VBoxContainer/Message
        if get_tree().paused:
            message.text = "Paused"
            message.show()
        else:
            message.text = ""
            message.hide() 
```

Этот код обнаруживает нажатие клавиши и переключает состояние паузы дерева в противоположное текущему состоянию. Он также отображает "Paused" на экране, чтобы игра не выглядела как зависшая.

Если вы запустите игру сейчас, возникнет проблема - все узлы приостановлены, включая Main. Это означает, что он больше не обрабатывает _input(), поэтому он не может обнаруживать ввод снова, чтобы возобновить игру! Чтобы исправить это, установите режим Process Mode для узла Main в Always.

Функция паузы - очень полезная вещь, которую стоит знать. Вы можете использовать этот метод в любой игре, так что внимательно изучите его, чтобы удостовериться, что понимаете, как он работает. Вы даже можете вернуться и добавить его в Coin Dash. В следующем разделе мы добавим врагов в игру.



## Враги

Космос наполнен не только скалами, но и другими опасностями. В этом разделе вы создадите вражеский космический корабль, который будет периодически появляться и стрелять в игрока.

## Следуя по пути

Когда враг появляется, он должен следовать по пути через экран. Это также будет выглядеть лучше, если он не будет двигаться только прямо. Чтобы избежать чрезмерной однообразности, вы можете создать несколько путей и случайным образом выбирать один из них, когда враг появляется.

Создайте новую сцену и добавьте узел Node. Назовите его EnemyPaths и сохраните. Чтобы нарисовать путь, добавьте узел Path2D. Как вы видели ранее, этот узел позволяет рисовать серию соединенных точек. Выбор этого узла отображает новую панель меню:

![Path drawing options  ](/img/2-space/23.png)

Эти кнопки позволяют вам рисовать и изменять точки пути. Нажмите на ту, где зеленый символ +, чтобы добавить точки. Кликните, чтобы начать путь где-то вне игрового окна, а затем добавьте еще несколько точек, чтобы создать кривую. Обратите внимание, что стрелки указывают направление пути. Пока не беспокойтесь о том, чтобы сделать его гладким:

![An example path ](/img/2-space/24.png)

Когда враг следует по пути, это не будет выглядеть очень гладко, когда он достигнет острых углов. Чтобы сгладить кривую, щелкните вторую кнопку на панели инструментов пути (в ее всплывающей подсказке написано "Выбрать точки управления"). Теперь, если вы щелкнете и перетащите любую из точек кривой, вы добавите точку управления, которая позволит вам изгибать линию в этой точке. Сглаживание линии приведет к чему-то вроде этого:

![ Using control points ](/img/2-space/25.png)

Добавьте два или три дополнительных узла Path2D в сцену и нарисуйте пути так, как вам нравится. Добавление петель и изгибов вместо прямых линий сделает врага более динамичным (и сделает его сложнее поразить). Помните, что первая точка, которую вы щелкаете, будет началом пути, поэтому убедитесь, что они начинаются с разных сторон экрана для разнообразия. Вот три примера путей:

![  Adding multiple paths ](/img/2-space/26.png)

Сохраните сцену. Вы добавите ее в сцену врага, чтобы предоставить ему пути, по которым он сможет двигаться.

## Вражеская сцена

Создайте новую сцену для врага, используя в качестве корневого узла Area2D. Добавьте дочерний узел Sprite2D и используйте res:/ assets/enemy_saucer.png в качестве свойства Texture. Установите Animation/HFrames на 3, чтобы вы могли выбирать между разноцветными тарелками:

::list
  -  Как и ранее, добавьте CollisionShape2D и предоставьте ему масштабированную CircleShape2D для покрытия изображения. Добавьте экземпляр сцены EnemyPaths и AnimationPlayer. В AnimationPlayer вы добавите анимацию для создания эффекта вспышки при попадании в тарелку.

  -  Добавьте анимацию с именем "flash". Установите Length на 0,25 и Snap на 0,01. Свойство, которое вы будете анимировать, - это Modulate Sprite2D (найденное в Visibility). Добавьте ключевые кадры для Modulate, чтобы создать трек, затем переместите скребок на 0,04 и измените цвет Modulate на красный. Переместитесь еще на 0,04 и измените цвет обратно на белый.

  -  Повторите этот процесс еще два раза, чтобы у вас было три вспышки в общей сложности.

  -  Добавьте экземпляр сцены Explosion и скройте его. Добавьте узел Timer с именем GunCooldown для управления тем, как часто враг будет стрелять. Установите Wait Time на 1,5 и Autostart в положение "on".

  -  Добавьте сценарий врага и подключите событие таймера. Пока не добавляйте ничего в эту функцию.

  -  В разделе Node в Area2D добавьте его в группу с именем "enemies". Как и с камнями, это даст вам способ идентификации объекта, даже если на экране будет несколько врагов одновременно.

::

## Перемещение врага

Для начала напишем код для выбора пути и движения врага по нему:

```gdscript 
extends Area2D
@export var bullet_scene : PackedScene
@export var speed = 150
@export var rotation_speed = 120
@export var health = 3
var follow = PathFollow2D.new()
var target = null
func _ready():
    $Sprite2D.frame = randi() % 3
    var path = $EnemyPaths.get_children()[randi() % $EnemyPaths.get_child_count()]
    path.add_child(follow)
    follow.loop = false 
```

Напоминаем, что узел PathFollow2D автоматически перемещается вдоль родительского узла Path2D. По умолчанию он зацикливается вокруг пути, когда достигает конца, поэтому вам нужно установить это значение в false, чтобы отключить его.
Следующим шагом является движение вдоль пути и удаление врага, когда он достигает конца пути.

```gdscript 
func _physics_process(delta):
    rotation += deg_to_rad(rotation_speed) * delta
    follow.progress += speed * delta
    position = follow.global_position
    if follow.progress_ratio >= 1:
        queue_free() 
```

Вы можете обнаружить конец пути, когда значение progress становится больше общей длины пути. Тем не менее более простым будет использование progress_ratio, который изменяется от нуля до единицы в течение всей длины пути, так что вам не нужно знать длину каждого пути.


## Генерация врагов


В сцене Main добавьте новый узел Timer с именем EnemyTimer. Установите его свойство One Shot в "on". Затем в main.gd добавьте переменную для ссылки на сцену врага:

```gdscript
@export var enemy_scene : PackedScene
```

Добавьте следующую строку в функцию new_level():

```gdscript
    $EnemyTimer.start(randf_range(5, 10))
```

Подключите сигнал timeout EnemyTimer:

```gdscript
func _on_enemy_timer_timeout():
    var e = enemy_scene.instantiate()
    add_child(e)
    e.target = $Player
    $EnemyTimer.start(randf_range(20, 40))
```

Этот код создает врага, когда таймер EnemyTimer завершает отсчет. Вы не хотите создавать нового врага сразу после этого, поэтому таймер перезапускается с более длительной задержкой.
Запустите игру, и вы должны увидеть тарелку, появляющуюся и летящую вдоль своего пути.

## Стрельба и столкновения

Просто переведи текст: Враг должен стрелять в игрока, а также реагировать на попадание игрока или пуль игрока. Пуля врага будет похожей на пулю игрока, но мы будем использовать другую текстуру. Вы можете создать ее заново с нуля или воспользоваться следующим процессом для повторного использования узла. Откройте сцену Bullet и выберите Сцена | Сохранить сцену как, чтобы сохранить ее как enemy_bullet.tscn (после этого не забудьте переименовать корневой узел). Удалите сценарий, нажав кнопку Отсоединить сценарий. Отключите соединения сигналов, выбрав вкладку Узел и выбрав Отсоединить. Вы можете увидеть, какие узлы имеют подключенные сигналы, обратив внимание на иконку ![ Node ](/img/2-space/icon_node_1.png) рядом с именем узла. Замените текстуру спрайта изображением laser_green.png и добавьте новый сценарий к корневому узлу. Сценарий для пули врага будет очень похож на обычную пулю. Подключите сигнал body_entered области и сигнал screen_exited VisibleOnScreenNotifier2D:

```gdscript
extends Area2D
@export var speed = 1000
func start(_pos, _dir):
    position = _pos
    rotation = _dir.angle()
func _process(delta):
    position += transform.x * speed * delta
func _on_body_entered(body):
    queue_free()
func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free() 
```

Обратите внимание, что вам нужно указать позицию и направление для пули. Это потому, что, в отличие от игрока, который всегда стреляет вперед, враг всегда будет стрелять в сторону игрока.

На данный момент пуля не будет наносить урон игроку. Вы добавите защитный щит игроку в следующем разделе, и тогда сможете добавить его.

Сохраните сцену и перетащите ее в свойство Bullet объекта Enemy.

В enemy.gd добавьте переменную для некоторого случайного разнообразия для пули и функцию shoot():

```gdscript
@export var bullet_spread = 0.2
func shoot():
    var dir = global_position.direction_to(target.global_position)
    dir = dir.rotated(randf_range(-bullet_spread,bullet_spread))
    var b = bullet_scene.instantiate()
    get_tree().root.add_child(b)
    b.start(global_position, dir) 
```

Сначала вы находите вектор, указывающий на позицию игрока, затем добавляете немного случайности, чтобы пуля могла "промахнуться".
Вызывайте функцию shoot() при каждом завершении времени GunCooldown:

```gdscript
func _on_gun_cooldown_timeout():
    shoot() 
```

Для дополнительного вызова вы можете заставить врага стрелять импульсами или несколькими быстрыми выстрелами:

```gdscript
func shoot_pulse(n, delay):
    for i in n:
        shoot()
        await get_tree().create_timer(delay).timeout 
```

Это будет выпускать заданное количество пуль, n, с интервалом в delay секунд между ними. Вы можете вызвать это вместо того, когда срабатывает откат:

```gdscript
func _on_gun_cooldown_timeout():
    shoot_pulse(3, 0.15)
```

Это вызовет импульс из 3 пуль с интервалом в 0.15 секунды между ними. Трудно уклониться!

Далее врагу необходимо получать урон, когда его поражает выстрел от игрока. Он будет мигать с использованием созданной вами анимации, а затем взорвется, когда его здоровье достигнет 0.

Добавьте эти функции в enemy.gd:

```gdscript
func take_damage(amount):
    health -= amount
    $AnimationPlayer.play("flash")
    if health <= 0:
        explode()

func explode():
    speed = 0
    $GunCooldown.stop()
    $CollisionShape2D.set_deferred("disabled", true)
    $Sprite2D.hide()
    $Explosion.show()
    $Explosion/AnimationPlayer.play("explosion")
    await $Explosion/AnimationPlayer.animation_finished
    queue_free()
```

Также подключите сигнал body_entered врага, чтобы враг взорвался, если игрок сталкивается с ним:

```gdscript
func _on_body_entered(body):
    if body.is_in_group("rocks"):
        return
    explode() 
```

Опять же, вы ждете реализации щита игрока, прежде чем наносить урон игроку, поэтому на данный момент эта коллизия только разрушает врага.

В настоящее время пуля игрока обнаруживает только камни, потому что ее сигнал body_entered не срабатывает при столкновении с врагом, который является объектом Area2D. Чтобы обнаружить врага, перейдите в сцену Bullet и подключите сигнал area_entered:

```gdscript
func _on_area_entered(area):
    if area.is_in_group("enemies"):
        area.take_damage(1)
```

Попробуйте снова поиграть, и вы столкнетесь с агрессивным пришельцем-противником! Убедитесь, что все комбинации столкновений обрабатываются (за исключением того, что враг стреляет в игрока). Также обратите внимание, что пули врага могут быть заблокированы камнями - возможно, вы сможете спрятаться за ними!

Теперь, когда в игре есть враги, она стала намного сложнее. Если вы по-прежнему считаете ее слишком легкой, попробуйте увеличить характеристики врага: как часто он появляется, сколько урона он наносит и сколько выстрелов ему требуется, чтобы уничтожить его. Это нормально, если вы сделаете его слишком сложным, потому что в следующем разделе вы добавите игроку небольшую поддержку, добавив щит для поглощения урона.
