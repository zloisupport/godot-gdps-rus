# Космический корабль игрока

Корабль игрока является сердцем этой игры. Большая часть кода, который вы напишете для этого проекта, будет связан с работой корабля. Он будет управляться в классическом стиле "Астероидов" - вращение влево/вправо и тяга вперед. Игрок также сможет стрелять лазером и уничтожать плавающие камни.

![HUD](/img/2-space/4.png)


## Настройка тела и физики

Создайте новую сцену и добавьте в нее RigidBody2D с именем Player в качестве корневого узла, а также с дочерними узлами Sprite2D и CollisionShape2D. Добавьте изображение res://assets/player_ship.png в свойство Texture у Sprite2D. Изображение корабля довольно крупное, поэтому установите свойство Scale у Sprite2D в (0.5, 0.5) и Rotation в 90.


![HUD](/img/2-space/5.png)

## Ориентация спрайта

Изображение для корабля нарисовано, указывая вверх. В Godot поворот на 0 градусов указывает вправо (вдоль оси x). Это означает, что вам нужно повернуть спрайт так, чтобы он соответствовал направлению тела. Если вы используете изображение, нарисованное в правильной ориентации, вы можете избежать этого шага. Однако очень часто можно встретить изображения, нарисованные с ориентацией вверх, поэтому вам следует знать, что делать.

В свойстве Shape объекта CollisionShape2D добавьте CircleShape2D и масштабируйте его так, чтобы он как можно ближе соответствовал изображению.

![HUD](/img/2-space/6.png)


Изображение корабля игрока выполнено в стиле пиксельного искусства, но если вы увеличите его, вы, возможно, заметите, что оно выглядит размытым и "сглаженным". По умолчанию в Godot используется техника сглаживания при отображении текстур, что выглядит хорошо с некоторыми изображениями, но не желательно для пиксельного искусства. Вы можете устанавливать сглаживание индивидуально для каждого спрайта (в разделе *CanvasItem*), либо установить его глобально в настройках проекта.
Откройте настройки проекта ( Project Settings) и включите переключатель Advanced Settings, а затем найдите раздел *rendering/textures*. Внизу вы увидите две настройки для Canvas Textures. Установите *Default Texture Filter* в значение *Nearest*.

![Default Texture Filter settings ](/img/2-space/7.png)


Сохраните сцену. При работе над проектами большего масштаба рекомендуется организовывать ваши сцены и скрипты в папки на основе каждого игрового объекта, а не сохранять их все в корневой папке проекта. Например, если вы создадите папку "player" (игрок), вы можете сохранить все файлы, связанные с игроком, там. Это упрощает поиск и изменение различных игровых объектов. Хотя этот проект относительно небольшой - у вас будет всего несколько сцен - это хорошая привычка, которую стоит принять, по мере того как ваши проекты растут по размеру и сложности.

## Машины состояний

Корабль игрока может находиться в различных состояниях во время игры. Например, когда он жив, корабль виден и может быть управляем игроком, но при этом уязвим для столкновения с камнями. С другой стороны, когда он находится в режиме неуязвимости, корабль должен быть полупрозрачным и быть невосприимчивым к урону.
Один из способов, которым программисты часто обрабатывают подобные ситуации, - это добавление булевых переменных или флагов в код. Например, флаг неуязвимости устанавливается в true, когда игрок впервые появляется, или alive устанавливается в false, когда игрок мертв. Однако это может привести к ошибкам и странным ситуациям, когда по какой-то причине оба alive и неуязвимость установлены в false одновременно. Что произойдет, если камень столкнется с игроком в этой ситуации? Было бы лучше, если бы корабль мог находиться только в одном четко определенном состоянии в каждый момент времени.
Решением этой проблемы является использование конечного автомата (finite state machine-FSM). При использовании FSM сущность может находиться только в одном состоянии в определенный момент времени. При проектировании FSM вы определяете несколько состояний и то, какие события или действия могут вызвать переход из одного состояния в другое.
На следующей диаграмме изображен FSM для корабля игрока:

![State machine diagram ](/img/2-space/8.png)

Существует четыре состояния, изображенных овалами, и стрелки указывают, какие переходы могут происходить между состояниями, а также что вызывает переход. Проверяя текущее состояние, вы можете решить, что разрешено игроку. Например, в состоянии DEAD (мертв), не разрешать ввод, или в состоянии INVULNERABLE (неуязвим), разрешать движение, но не разрешать стрельбу.

Реализации продвинутых конечных автоматов могут стать довольно сложными, и детали выходят за рамки данной книги (см. Приложение для дополнительного чтения). В чистом смысле, здесь вы не будете создавать настоящий конечный автомат, но в рамках этого проекта будет достаточно проиллюстрировать концепцию и предотвратить проблемы с булевыми флагами.

Добавьте скрипт к узлу Player и начните с создания скелета реализации конечного автомата (FSM):


```gdscript
extends RigidBody2D
enum {INIT, ALIVE, INVULNERABLE, DEAD}
var state = INIT 
```

Перечисление (сокращенно от "enumeration") - удобный способ создать набор констант. Оператор enum в предыдущем коде эквивалентен написанию следующего кода:

```gdscript
const INIT = 0
const ALIVE = 1
const INVULNERABLE = 2
const DEAD = 3 
```

Далее создайте функцию change_state() для обработки переходов между состояниями:

```gdscript 
func _ready():
    change_state(ALIVE)
func change_state(new_state):
    match new_state:
        INIT:
            $CollisionShape2D.set_deferred("disabled",true)
        ALIVE:
            $CollisionShape2D.set_deferred("disabled",false)
        INVULNERABLE: 
            $CollisionShape2D.set_deferred("disabled",true)
        DEAD:
            $CollisionShape2D.set_deferred("disabled",  true)
    state = new_state 
```


Всякий раз, когда вам нужно изменить состояние игрока, вы вызовете функцию change_state() и передадите ей значение нового состояния. Затем, используя оператор match, вы можете выполнить код, который должен сопровождать переход к новому состоянию, или запретить его, если вы не хотите, чтобы этот переход произошел. В данном случае узел CollisionShape2D включается/выключается в зависимости от нового состояния. В _ready() мы устанавливаем ALIVE в качестве начального состояния - это для тестирования, но мы заменим его на INIT позже.

## Добавление управления игроком

Добавьте следующие переменные в верхней части скрипта:

```gdscript 
@export var engine_power = 500
@export var spin_power = 8000
var thrust = Vector2.ZERO
var rotation_dir = 0 
```
engine_power и spin_power контролируют, насколько быстро корабль может ускоряться и поворачиваться. thrust представляет собой силу, приложенную двигателем: либо (0, 0), когда корабль движется инерционно, либо вектор, направленный вперед, когда двигатель включен. rotation_dir указывает, в каком направлении поворачивается корабль, чтобы вы могли применить к нему крутящий момент или вращательную силу.

Как мы видели ранее в настройках проекта(Project Settings), физический движок предоставляет некоторое затухание, которое уменьшает скорость и вращение тела. В космосе нет трения, поэтому для реализма не должно быть никакого затухания вообще. Однако для классического аркадного ощущения предпочтительно, чтобы корабль останавливался, когда вы отпускаете клавиши. В инспекторе установите Linear/Damp в 1 и Angular/Damp в 5. Вы можете отрегулировать их позже, чтобы изменить характеристики корабля.

Следующим шагом является обнаружение ввода и перемещение корабля:

```gdscript 
func _process(delta):
    get_input()
func get_input():
    thrust = Vector2.ZERO
    if state in [DEAD, INIT]:
        return
    if Input.is_action_pressed("thrust"):
        thrust = transform.x * engine_power
    rotation_dir = Input.get_axis("rotate_left",
        "rotate_right")
func _physics_process(delta):
    constant_force = thrust
    constant_torque = rotation_dir * spin_power 
```

Функция get_input() захватывает клавишные действия и включает или выключает тягу корабля. Обратите внимание, что направление тяги зависит от transform.x тела, который всегда представляет собой "вперёд" тела (см. Приложение для обзора трансформаций).

Input.get_axis() возвращает значение на основе двух входов, представляя отрицательные и положительные значения. Таким образом, rotation_dir будет либо по часовой стрелке, либо против, либо ноль, в зависимости от состояния двух входных действий.

Наконец, при использовании физических тел и связанных с ними функций всегда следует вызывать в _physics_process(). Здесь можно применять силы, установленные вводами, чтобы фактически перемещать тело.

Запустите сцену, и вы должны сможете свободно летать вокруг.