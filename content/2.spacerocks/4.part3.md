# Тестирование корабля игрока

Создайте новую сцену с использованием узла, названного Main, и добавьте дочерний объект Sprite2D с именем Background. В свойстве Texture используйте res:/assets/space_background.png. Добавьте экземпляр Player в сцену.
Запустите основную сцену и проверьте, можете ли вы летать и стрелять.
Теперь, когда ваш игровой корабль работает, это хорошее время для остановки и проверки вашего понимания. Работа с жесткими телами может быть сложной; уделите несколько минут экспериментам с некоторыми настройками и кодом из этого раздела. Просто убедитесь, что вы их восстановите перед переходом к следующему разделу, где вы добавите астероиды в игру.

## Добавление камней
Цель игры - уничтожать плавающие космические скалы, поэтому теперь, когда у вас есть возможность стрелять, настало время добавить их. Как и
корабль, скалы будут использовать RigidBody2D, что заставит их двигаться по прямой линии со стабильной скоростью, если только их не нарушат. Они также будут отскакивать друг от друга реалистичным образом. Чтобы сделать вещи более интересными, скалы будут начинаться
большими, и, когда вы попадете в них, разбиваться на несколько более мелких скал.

## Настройка сцены

Создайте новую сцену с узлом RigidBody2D, названным Rock, и добавьте дочерний объект Sprite2D с использованием текстуры res://assets/rock.png. Добавьте CollisionShape2D, но еще не устанавливайте его форму. Поскольку вы будете создавать астероиды разных размеров, форма столкновения должна быть установлена в коде и настроена на правильный размер.

Вы не хотите, чтобы астероиды замедлялись, поэтому им нужно игнорировать стандартное линейное и угловое затухание. Установите как Linear/Damp, так и Angular/Damp в 0, а Damp Mode для обоих установите на Replace. Астероиды также должны отскакивать от друг друга. Вы можете сделать это в свойстве Physics Material. Выберите New PhysicsMaterial, а затем щелкните по нему, чтобы развернуть. Установите отображаемое свойство Bounce на 1.

## Камни переменного размера
Прикрепите скрипт к узлу Rock и определите переменные класса (члены класса):

```
extends RigidBody2D
var screensize = Vector2.ZERO
var size
var radius
var scale_factor = 0.2 
```

Главный скрипт будет отвечать за создание новых скал, как в начале уровня, так и за появление более мелких скал после взрыва крупной. Крупная скала будет иметь размер 3, разбиваться на скалы размером 2 и так далее. Множитель scale_factor умножается на размер для установки масштаба Sprite2D, радиуса коллизии и так далее. Вы можете позже отрегулировать это, чтобы изменить размер каждой категории скалы.

Все это будет установлено методом start():

```
func start(_position, _velocity, _size):
    position = _position
    size = _size
    mass = 1.5 * size
    $Sprite2D.scale = Vector2.ONE * scale_factor * sizeradius = int($Sprite2D.texture.get_size().x / 2 * $Sprite2D.scale.x)
    var shape = CircleShape2D.new()
    shape.radius = radius
    $CollisionShape2d.shape = shape
    linear_velocity = _velocity
    angular_velocity = randf_range(-PI, PI) 
```
Это место, где вы вычисляете правильный размер коллизии на основе размера скалы. Обратите внимание, что поскольку переменные position и size уже используются как переменные класса, вы можете использовать подчеркивание для аргументов функции, чтобы предотвратить конфликт.
Также скалы должны обтекать экран, как и игрок, поэтому используйте тот же прием с _integrate_forces():

```
func _integrate_forces(physics_state):
    var xform = physics_state.transform
    xform.origin.x = wrapf(xform.origin.x, 0 - radius,screensize.x + radius)
    xform.origin.y = wrapf(xform.origin.y, 0 - radius, screensize.y + radius)
    physics_state.transform = xform 
```

Единственное отличие здесь заключается в том, что включение радиуса астероида в расчет приводит к более плавному телепортации. Астероид будет казаться полностью покидает экран, прежде чем появится на противоположной стороне. Вы можете попробовать сделать то же самое с кораблем игрока. Попробуйте и посмотрите, что вам нравится больше.


## Создание экземпляров камней

При создании новых скал главная сцена должна выбирать случайное начальное местоположение. Для этого вы можете использовать математику для выбора случайной точки вдоль периметра экрана, но вместо этого вы можете воспользоваться другим типом узла Godot. Вы создадите путь вдоль края экрана, и скрипт выберет случайное местоположение вдоль этого пути.

В сцене Main добавьте узел Path2D и назовите его RockPath. Когда вы выберете узел, вы увидите появление новых кнопок в верхней части окна редактора:

![ Path drawing tools ](/img/2-space/9.png)


Выберите среднюю кнопку (Добавить точку -Add Point)  , чтобы нарисовать путь, кликая по точкам, показанным на следующем скриншоте. Чтобы сделать так, чтобы точки выравнивались, убедитесь, что включена опция Использовать привязку к сетке(Use Grid Snap). Эту опцию можно найти на панели инструментов в верхней части окна редактора:

![ Enabling grid snapping ](/img/2-space/10.png)

Нарисуйте точки в порядке, показанном на следующем снимке экрана. После щелчка четвертой точки нажмите кнопку Close Curve (обозначенную 5 на снимке экрана), и ваш путь будет завершен.

![Path drawing order](/img/2-space/11.png)

Не кликайте снова в окне редактора, если у вас выбран RockPath! Если вы это сделаете, то добавите дополнительные точки к кривой, и ваши скалы могут появляться не там, где вы этого хотите. Вы можете нажать Ctrl + Z, чтобы отменить любые дополнительные точки, которые вы могли добавить.

Теперь, когда путь определен, добавьте PathFollow2D в качестве дочернего элемента RockPath и назовите его RockSpawn. Цель этого узла - автоматическое перемещение вдоль своего родительского пути, используя свойство Progress, представляющее собой смещение вдоль пути. Чем выше смещение, тем дальше по пути он движется. Поскольку наш путь замкнут, он также будет зацикливаться, если значение смещения больше длины пути.

Добавьте следующий скрипт в main.gd:
```
extends Node
@export var rock_scene : PackedScene
var screensize = Vector2.ZERO
func _ready():
    screensize = get_viewport().get_visible_rect().size
    for i in 3:
        spawn_rock(3)
```
Вы начинаете с получения размеров экрана, чтобы передать их скалам при их появлении. Затем вы создаете три скалы размером 3. Не забудьте перетащить rock.tscn на свойство Rock.

Вот функция spawn_rock():

```
func spawn_rock(size, pos=null, vel=null):
    if pos == null:
        $RockPath/RockSpawn.progress = randi()
        pos = $RockPath/RockSpawn.position
    if vel == null:
        vel = Vector2.RIGHT.rotated(randf_range(0, TAU)) *randf_range(50, 125)
    var r = rock_scene.instantiate()
    r.screensize = screensize
    r.start(pos, vel, size)
    call_deferred("add_child", r) 
```

Эта функция служит двум целям. Если вызывается только с параметром размера, она выбирает случайное положение вдоль RockPath и случайную скорость. Однако, если эти значения предоставлены, она будет использовать их вместо. Это позволит вам появлять более мелкие скалы в месте взрыва, указывая их свойства.

Запустите игру, и вы должны увидеть три скалы, плывущие вокруг, но ваши пули на них не воздействуют.

## Разрушение астероидов

Пуля проверяет наличие тел в группе rocks, поэтому в сцене Rock выберите вкладку Node и выберите Groups. Введите rocks и нажмите Add:

![ Adding a “rocks” group ](/img/2-space/12.png)


Теперь, если вы запустите игру и выстрелите в астероид, вы увидите сообщение об ошибке, потому что пуля пытается вызвать метод explode() у астероида, который вы еще не определили. Этот метод должен сделать три вещи:

::list
  -  Удалить астероид.

  -  Воспроизвести анимацию взрыва.

  -  Уведомить основную сцену о создании новых, более мелких астероидов.
::

## Сцена взрыва

Взрыв будет представлять собой отдельную сцену, которую вы сможете добавить к астероиду, а затем к игроку. Он будет содержать два узла:
::list
  -  Sprite2D с именем Explosion
  -  AnimationPlayer
::

Для свойства Texture узла Sprite2D используйте res://assets/explosion.png. Вы заметите, что это спрайт-лист - изображение, состоящее из 64 меньших изображений, расположенных в сетке. Эти изображения представляют собой отдельные кадры анимации. Вы часто будете встречать анимации в таком формате, и узел Sprite2D в Godot поддерживает их использование.

В разделе Animation настроек спрайта в Инспекторе установите Vframes и Hframes оба равными 8. Это разделит спрайт-лист на 64 отдельных изображения. Вы можете проверить это, изменяя значение свойства Frame на различные значения от 0 до 63. Убедитесь, что вы установили его обратно на 0, прежде чем продолжить.

![ Sprite Animation settings ](/img/2-space/13.png)


Узел AnimationPlayer может использоваться для анимации любого свойства любого узла. Вы будете использовать его для изменения свойства Frame со временем. Начнем с выбора узла, и вы увидите открывающуюся внизу панель Animation:

![ Animation panel](/img/2-space/14.png)

Нажмите кнопку Animation и выберите New. Дайте анимации имя explosion. Установите длину анимации (Animation Length) на 0.64 и Snap to 0.01. Выберите узел Sprite2D, и вы заметите, что у каждого свойства в Инспекторе теперь есть символ ключа рядом с ним. Нажатие на ключ создаст ключевую точку в текущей анимации.


![  Animation time settings](/img/2-space/15.png)


Кликните на ключ рядом со свойством Frame у узла Explosion и подтвердите, что вы хотите создать новый трек анимации. Снимите выделение с опции Create RESET Track(s). Теперь вы создали ключевую точку, указывающую AnimationPlayer, что при времени 0 вы хотите, чтобы значение свойства Frame спрайта было равно 0.

Переместите ползунок времени к моменту 0.64 (вы можете регулировать масштаб с помощью ползунка, если не видите его). Установите значение Frame в 63 и снова нажмите на ключ. Теперь анимация знает, что нужно использовать последнее изображение в конечный момент времени анимации. Однако вам также нужно сообщить AnimationPlayer, что вы хотите использовать все промежуточные значения между этими двумя точками. Справа от трека анимации находится выпадающий список Update Mode. В настоящее время он установлен на Discrete, и вам нужно изменить его на Continuous:

![ Setting Update Mode ](/img/2-space/16.png)

Нажмите кнопку Play в панели Animation, чтобы посмотреть анимацию. Теперь вы можете добавить взрыв к астероиду. В сцене Rock добавьте экземпляр Explosion и щелкните по иконке глаза рядом с узлом, чтобы скрыть его. Добавьте следующую строку в функцию start():

```gdscript
$Explosion.scale = Vector2.ONE * 0.75 * size
```

Это гарантирует, что взрыв масштабируется в соответствии с размером астероида.

Добавьте сигнал с именем `exploded` в верхней части скрипта, затем добавьте функцию `explode()`, которая будет вызвана, когда пуля попадает в астероид:

```gdscript 
func explode():
    $CollisionShape2D.set_deferred("disabled", true)
    $Sprite2d.hide()
    $Explosion/AnimationPlayer.play("explosion")
    $Explosion.show()
    exploded.emit(size, radius, position, linear_velocity)
    linear_velocity = Vector2.ZERO
    angular_velocity = 0
    await $Explosion/AnimationPlayer.animation_finished
    queue_free() 
```

Здесь вы скрываете астероид и воспроизводите анимацию взрыва, ожидая ее завершения перед удалением астероида. Когда вы отправляете сигнал `exploded`, вы также включаете всю информацию об астероиде, чтобы функция `spawn_rock()` в Main смогла создать более мелкие астероиды в том же месте.

Протестируйте игру и убедитесь, что вы видите взрывы, когда стреляете в астероиды.


## Создание более мелких астероидов

Сцена Rock излучает сигнал, но Main еще не слушает его. Вы не можете подключить сигнал во вкладке Node, потому что астероиды создаются в коде. Они будут существовать только позже, когда игра будет запущена. Добавьте эту строку в конец функции `spawn_rock()`:

```gdscript 
r.exploded.connect(self._on_rock_exploded) 
```

Это подключает сигнал астероида к функции в Main, которую вам также нужно создать:

```gdscript 
func _on_rock_exploded(size, radius, pos, vel):
    if size <= 1:
        return
    for offset in [-1, 1]:
        var dir = $Player.position.direction_to(pos)
        .orthogonal() * offset
        var newpos = pos + dir * radius
        var newvel = dir * vel.length() * 1.1
        spawn_rock(size - 1, newpos, newvel) 
```

В этой функции вы создаете два новых астероида, если только что уничтоженный астероид не был размера 1 (самого маленького размера). Переменная цикла смещения (offset) гарантирует, что два новых астероида движутся в противоположных направлениях (то есть скорость одного будет отрицательной). Переменная dir находит вектор между игроком и астероидом, затем использует orthogonal(), чтобы получить вектор, перпендикулярный к нему. Это гарантирует, что новые астероиды не летят прямо на игрока.

![ Explosion diagram  ](/img/2-space/17.png)

Сыграйте в игру еще раз и проверьте, что все работает ожидаемым образом.

Это отличное место для остановки и обзора того, что вы уже сделали. Вы завершили все основные функции игры: игрок может перемещаться и стрелять; астероиды плавают, отскакивают и взрываются; и появляются новые астероиды. На данном этапе вы должны чувствовать себя более уверенно в использовании жестких тел. В следующем разделе вы начнете создавать интерфейс, позволяющий игроку начать игру и видеть важную информацию во время геймплея.


## Создание пользовательского интерфейса (UI)

Создание UI для вашей игры может быть очень сложным или, по крайней мере, затратным по времени. Точное расположение отдельных элементов и обеспечение их работоспособности на различных экранах и устройствах — наименее интересная часть разработки игр для многих программистов. Godot предоставляет разнообразные узлы Control, чтобы помочь в этом процессе. Изучение различных узлов Control поможет уменьшить трудности создания отполированного пользовательского интерфейса.

Для этой игры вам не нужен очень сложный пользовательский интерфейс. Игра должна предоставлять следующую информацию и взаимодействие:

::list
   - Кнопка "Старт"
   - Статусное сообщение (например, "Готовьтесь" или "Конец игры")
   - Счет
   - Счетчик жизней
::

Вот предварительный просмотр того, что вы сделаете:

![UI layout](/img/2-space/18.png)

Создайте новую сцену и добавьте узел CanvasLayer с именем HUD в качестве корневого узла. Вы будете строить пользовательский интерфейс на этом слое, используя функции компоновки узла Control.

## Слои (Layers)

Узлы Control в Godot включают в себя несколько специализированных контейнеров. Эти узлы могут быть вложены друг в друга для создания необходимого макета. Например, MarginContainer автоматически добавляет отступ вокруг своего содержимого, в то время как HBoxContainer и VBoxContainer организуют свое содержимое в строки или столбцы соответственно.
Следуйте этим шагам для создания макета:

1.Начните с добавления дочерних узлов Timer и MarginContainer, которые будут содержать счетчики очков и жизней. В выпадающем меню Layout выберите опцию Top Wide.

![Top Wide control alignment ](/img/2-space/19.png)

::list
 -  В Инспекторе установите четыре поля (margins) в разделе Theme Overrides/Constants равными 20.

 -   Установите свойство One Shot для Timer в положение on, а Wait Time в 2.

 -   Как дочерний узел контейнера добавьте HBoxContainer, который будет располагать счетчик очков слева, а счетчик жизней справа. В этот контейнер добавьте Label (назовите его ScoreLabel) и еще один HBoxContainer (названный LivesCounter).

::
Установите для текста ScoreLabel значение 0, и в разделе Layout/Container Sizing/Horizontal установите флажок Expand. В настройках Label добавьте шрифт, как вы делали в Главе 2, используя res://assets/kenvector_future_thin.ttf и установив размер шрифта равным 64.


::list

  -  Выберите LivesCounter и установите Theme Overrides/Constants/Separation равным 20, затем добавьте дочерний узел TextureRect и назовите его L1. Перетащите res://assets/player_small.png в свойство Texture и установите режим Stretch Mode в Keep Aspect Centered. Убедитесь, что у вас выбран узел L1, и нажмите Ctrl + D дважды, чтобы создать L2 и L3 (они будут автоматически названы). Во время игры на HUD будут отображаться или скрываться эти три текстуры, указывая, сколько жизней осталось у игрока.

  -  В более крупном и сложном пользовательском интерфейсе вы, возможно, сохранили бы этот раздел как отдельную сцену и внедрили бы ее в другие разделы пользовательского интерфейса. Однако для этой игры достаточно объединить все элементы в одну сцену.

  -  Как дочерний узел HUD, добавьте VBoxContainer, а внутри него добавьте Label с именем Message и TextureButton с именем StartButton. Установите макет VBoxContainer в Center Wide и Theme Overrides/Constants/Separation в 100.

 -   В папке res://assets есть две текстуры для StartButton, одна нормальная (play_button.png) и одна, которая будет отображаться, когда указатель мыши наведен на нее ('play_button_h.png). Перетащите их в Textures/Normal и Textures/Hover в инспекторе. Установите Layout/Container Sizing/Horizontal кнопки в Shrink Center, чтобы она была центрирована по горизонтали.

 -   Установите текст Message в "Space Rocks!" и установите его шрифт с теми же параметрами, что и у ScoreLabel. Установите горизонтальное выравнивание в Center.

::

Когда закончите, ваша сцена должна выглядеть следующим образом в дереве сцен:

 ![ HUD node layout](/img/2-space/20.png)