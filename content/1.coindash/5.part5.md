# Часть 5-Финишная примая

Поздравляю с созданием полноценной, работающей игры! В этом разделе вы добавите несколько дополнительных элементов, чтобы сделать игру более захватывающей. Разработчики игр используют термин "сок" (juice), чтобы описать элементы, которые делают игру приятной в процессе игры. Сок может включать в себя такие вещи, как звук, визуальные эффекты или любые другие дополнения, которые добавляют к удовольствию игрока, не обязательно изменяя характер геймплея.


## Визуальные эффекты

При подборе монет они просто исчезают, что не очень привлекательно. Добавление визуального эффекта сделает сбор монет более удовлетворительным. 

## Что такое твин(tween) ?

Твин (tween) - это способ интерполяции (постепенного изменения) некоторого значения в течение времени с использованием определенной математической функции. 
Например, вы можете выбрать функцию, которая постепенно изменяет значение, или такую, которая начинается медленно, но затем ускоряется.


Твининг иногда также называют easing. Вы можете увидеть анимированные примеры множества функций твининга на https://easings.net/.


При использовании твина в Godot вы можете назначить его для изменения одного или нескольких свойств узла. В данном случае вы собираетесь увеличить масштаб монеты и также вызвать ее исчезновение, используя свойство Modulate. Как только твин завершит свою работу, монета будет удалена.


Однако есть проблема. Если мы не удалим монету немедленно, то есть возможность того, что игрок снова наступит на монету, вызвав сигнал area_entered второй раз и регистрировав его как второй сбор. Чтобы предотвратить это, вы можете отключить форму столкновения, чтобы монета больше не могла вызывать дополнительные столкновения.
Ваша новая функция `pickup()` должна выглядеть так:

```gdscript
func pickup():
    $CollisionShape2d.set_deferred("disabled", true)
    var tw = create_tween().set_parallel().
        set_trans(Tween.TRANS_QUAD)tw.tween_property(self, "scale", scale * 3, 0.3)
    tw.tween_property(self, "modulate:a", 0.0, 0.3)
    await tw.finished
    queue_free() 
```

## Звук


Звук - важная, но часто пренебрегаемая часть дизайна игры. Хороший звуковой дизайн может добавить большое количество "сока" в вашу игру за небольшое количество усилий. Звуки могут предоставить обратную связь игроку, связать его эмоционально с персонажами или даже быть прямой частью геймплея ("вы слышите шаги сзади").


В этой игре вы собираетесь добавить три звуковых эффекта. В сцене Main добавьте три узла AudioStreamPlayer и назовите их CoinSound, LevelSound и EndSound. Перетащите каждый звук из папки res://assets/audio/ в соответствующее свойство узла Stream.


Чтобы воспроизвести звук, вызывайте функцию play() для соответствующего узла. Добавьте каждую из следующих строк, чтобы воспроизвести звуки в нужные моменты:
```gdscript
$CoinSound.play() to _on_player_pickup() 
$EndSound.play() to game_over() 
$LevelSound.play() to spawn_coins() (but not inside the loop!) 
````
## Бонусы

Существует много вариантов объектов, которые предоставляют игроку небольшое преимущество или бонус. В этом разделе вы добавите предмет powerup, который дает игроку небольшой бонус времени при сборе. Он будет появляться время от времени на короткое время, а затем исчезать.

Новая сцена будет очень похожа на сцену Coin, которую вы уже создали, поэтому перейдите в свою сцену Coin и выберите Сцена -> Сохранить сцену как, сохраните ее как powerup.tscn. Измените имя корневого узла на Powerup и удалите сценарий, нажав кнопку Отсоединить сценарий. 

Во вкладке Группы удалите группу coins, нажав кнопку корзины, и добавьте новую группу с именем powerups. 

В AnimatedSprite2D замените изображения на изображения powerup, которые вы можете найти в папке res:/assets/pow/. 

Щелкните, чтобы добавить новый сценарий, и скопируйте код из сценария coin.gd. 

Затем добавьте узел таймера с именем Lifetime. Он ограничит время, в течение которого объект останется на экране. Установите его значение времени ожидания на 2, а оба параметра One Shot и Autostart - включены. Подключите его сигнал тайм-аута, чтобы powerup можно было удалить в конце указанного периода времени:

```gdscript
func _on_lifetime_timout():
    queue_free() 
```

Теперь перейдите к своей сцене Main и добавьте еще один узел таймера с именем PowerupTimer. Установите его свойство One Shot в значение On. Также есть звук Powerup.wav в папке audio, который вы можете добавить с помощью еще одного узла AudioStreamPlayer. Подключите сигнал тайм-аута и добавьте следующий код для создания powerup:

```gdscript
func _on_powerup_timer_timeout():
    var p = powerup_scene.instantiate()
    add_child(p)
    p.screensize = screensize
    p.position = Vector2(randi_range(0, screensize.x),
        randi_range(0, screensize.y)) 
```


Сцену Powerup нужно связать с переменной, как вы сделали с сценой Coin, поэтому добавьте следующую строку в начало main.gd, а затем перетащите powerup.tscn в новое свойство:

```gdscript
@export var powerup_scene : PackedScene
```

Powerups должны появляться непредсказуемо, поэтому время ожидания PowerupTimer должно быть установлено при начале нового уровня. Добавьте это в функцию _process() после создания новых монет с помощью spawn_coins():
```gdscript
func _process(delta: float) -> void:
    # ... (другой код)
    if timer_time == 0:
        spawn_coins()
        PowerupTimer.wait_time = rand_range(5, 15)
````


Теперь у вас будут появляться powerups; последний шаг - предоставить игроку возможность собирать их. В настоящее время скрипт игрока предполагает, что все, с чем он сталкивается, является либо монетой, либо препятствием. Измените код в player.gd, чтобы проверять, с каким видом объекта произошло столкновение:

```gdscript
func _on_area_entered(area):
    if area.is_in_group("coins"):
        area.pickup()
        pickup.emit("coin")
    if area.is_in_group("powerups"):
        area.pickup()
        pickup.emit("powerup")
        if area.is_in_group("obstacles"):
        hurt.emit()
        die() 
```

Обратите внимание, что теперь сигнал pickup отправляется с дополнительным аргументом, который указывает тип объекта. Соответствующую функцию в main.gd теперь нужно изменить так, чтобы она принимала этот аргумент и определяла соответствующее действие:


```gdscript
func _on_player_pickup(type):
    match type:
        "coin":
            $CoinSound.play()
            score += 1
            $HUD.update_score(score)
        "powerup":
            $PowerupSound.play()
            time_left += 5
            $HUD.update_timer(time_left) 
````

Теперь, когда сигнал pickup отправляется из игрока с аргументом типа, функция on_player_pickup будет обрабатывать поднятие в соответствии с типом объекта. Если это монета, увеличится счет, а если это бонус, таймер игры продлится, и будет проигран соответствующий звук. Адаптируйте действия внутри оператора match в зависимости от вашей конкретной логики игры.

Оператор `match` - это удобная альтернатива операторам `if`, особенно когда у вас есть большое количество возможных значений для проверки.

Попробуйте запустить игру и подберите бонус (помните, что его не будет на первом уровне). Убедитесь, что звук воспроизводится, и таймер увеличивается на пять секунд.

## Анимация монет

Когда вы создавали монету, вы использовали **AnimatedSprite2D**, но она еще не проигрывается. Анимация монеты отображает эффект "мерцания", двигающегося по лицу монеты. Если все монеты будут отображать это одновременно, это будет выглядеть слишком регулярно, поэтому каждая монета должна иметь небольшую случайную задержку в своей анимации.

Сначала щелкните по **AnimatedSprite2D**, а затем по ресурсу **SpriteFrames**. Убедитесь, что Animation Looping установлен в Off, а Speed установлен на 12 FPS.

![HUD](/img/1-coin/28.png)

Добавьте узел Timer в сцену Coin, а затем добавьте следующий код в скрипт монеты:
```gdscript
func _ready():
    $Timer.start(randf_range(3, 8)) 
```

Затем подключите сигнал timeout таймера и добавьте следующий код:
```gdscript
func _on_timer_timeout():
    $AnimatedSprite2d.frame = 0
    $AnimatedSprite2d.play() 
```


Попробуйте запустить игру и посмотреть на анимацию монет. Это приятный визуальный эффект при небольших затратах усилий, по крайней мере, с точки зрения программиста – художнику пришлось нарисовать все эти кадры! Вы заметите много подобных эффектов в профессиональных играх. Несмотря на их незаметность, визуальная привлекательность создает гораздо более приятный опыт.



## Препятствие 

Наконец, игру можно сделать более сложной, введя препятствие, которое игрок должен избегать. Прикосновение к препятствию завершит игру.

![HUD](/img/1-coin/29.png)

Создайте новую сцену **Area2D** и назовите ее `Cactus`. Добавьте в нее дочерние элементы Sprite2D и CollisionShape2D. Перетащите текстуру кактуса из файловой системы в свойство Texture у Sprite2D. Добавьте **RectangleShape2D** к коллизионной форме и установите ее размер так, чтобы она покрывала изображение. Помните, когда вы добавляли `if area.is_in_group("obstacles")?` в код игрока? Добавьте Кактус в группу obstacles, используя вкладку Node. Запустите игру и посмотрите, что произойдет, когда вы столкнетесь с кактусом.

Возможно, вы заметили проблему – монеты могут появляться поверх кактуса, что делает их недоступными для сбора. Когда монета размещается, ей нужно перемещаться, если она обнаруживает перекрытие с препятствием. В сцене Монеты подключите ее сигнал `area_entered` и добавьте следующий код:

```gdscript
func _on_area_entered(area):
    if area.is_in_group("obstacles"):
        position = Vector2(randi_range(0, screensize.x),
        randi_range(0, screensize.y)) 
```
Если вы добавили объект **Powerup** из предыдущего раздела, вам нужно сделать то же самое в его скрипте.
Запустите игру и проверьте, что объекты все правильно появляются и не перекрываются с препятствием. Столкновение с препятствием должно завершать игру.

Считаете ли вы игру сложной или легкой? Прежде чем перейти к следующей главе, потратьте время на размышления о других вещах, которые вы можете добавить в эту игру. Попробуйте добавить их, используя то, что вы узнали до сих пор. Если не получится, запишите идеи и вернитесь к ним позже, после того как вы узнаете еще несколько техник в следующих главах.


