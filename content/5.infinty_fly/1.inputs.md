# Input(Ввод)

Вы будете управлять самолетом с помощью клавиш вверх, вниз, влево и вправо. Вы можете добавить их в **Input Map** (Карта ввода) так же, как вы делали это в других проектах. Назовите четыре ввода `pitch_up` ( вверх), `pitch_down` ( вниз), `roll_left` (влево) и `roll_right` (вправо). Вы можете назначить на них стрелки и/или клавиши W, A, S и D, но если у вас есть геймпад, вы также можете использовать джойстик для более точного управления. Чтобы добавить ввод с джойстика, вы можете выбрать **Joypad Axes** (Оси геймпада) после нажатия кнопки +. Значения имеют соответствующие метки, например **Left Stick Up** (Левый стик вверх), так что вы легко сможете их отследить:

![Конфигурация ввода](/img/infinity-fly/6.2.jpg)

Рисунок 6.2: Конфигурация ввода

Преимущество этой настройки заключается в том, что вашему коду не нужно будет каким-либо образом отличаться для разных типов ввода. Используя `Input.get_axis()` и передавая четыре события ввода, вы получите результат независимо от того, нажал ли игрок клавишу или переместил стик. Нажатие клавиш эквивалентно тому, чтобы до упора отклонить стик в одном направлении.

Теперь, когда проект настроен, вы можете начать создавать игровые объекты, начиная с управляемого игроком самолета.

# Сцена самолета (Airplane scene)

В этом разделе вы создадите самолет, которым будет управлять игрок. Он будет лететь вперед, при этом игрок сможет перемещать его вверх, вниз, влево и вправо.

Начните новую сцену самолета с узла **CharacterBody3D** под названием Plane и сохраните ее.

Вы можете найти 3D-модель самолета в папке assets, под названием cartoon_plane.glb. Название указывает на то, что модель хранится как двоичный файл `.gltf` (экспортированный из Blender). Godot импортирует файлы `.gltf` как сцены, содержащие сетки, анимации, материалы и другие объекты, которые могли быть экспортированы в этом файле. Нажмите кнопку **Instance a Child Scene** (Создать дочернюю сцену) и выберите модель самолета. Вы увидите, что он появляется как **Node3D**, но он смотрит в неправильном направлении. Выберите его и установите функцию **Rotation/Y** (Вращение/Y) на 180 в панели Inspector (Инспектор), чтобы он указывал вдоль оси z, которая является «прямым» направлением Godot. Обратите внимание, что ввести значение напрямую проще, чем пытаться точно повернуть узел с помощью мыши.

## Ориентация модели

Как упоминалось в предыдущей главе, различные программы 3D-дизайна используют разные ориентации осей. Очень часто при импорте ваша модель имеет направление вперед, не совпадающее с направлением Godot. Если вы создаете модель самостоятельно, вы можете исправить это при экспорте, но если вы используете модель, созданную кем-то другим, ее обычно нужно переориентировать в Godot.

Если вы щелкнете правой кнопкой мыши по узлу `cartoon_plane` и выберете **Editable Children** (Редактировать дочерние элементы), вы увидите все сетки, из которых состоит самолет, а также **AnimationPlayer** (Проигрыватель анимации):

![Mesh самолета](/img/infinity-fly/6.3.jpg)
Рисунок 6.3: Mesh самолета

AnimationPlayer содержит анимацию для вращения пропеллера, поэтому выберите его и установите анимацию prop_spin для функции Autoplay on Load (Автозапуск при загрузке):

![Авто воспроизведение анимации](/img/infinity-fly/6.4.jpg)
Рисунок 6.4: Авто воспроизведение анимации

# CollisionShape

Добавьте узел **CollisionShape3D** к **Plane** и выберите **New CylinderShape3D** для его настройки **Shape** (Форма). Вы можете изменить размер цилиндра с помощью двух оранжевых маркеров размера, но вам нужно повернуть его вокруг оси x на 90 градусов, чтобы выровнять его по фюзеляжу самолета. Вы можете сделать это с помощью gizmo (не забудьте включить привязку с помощью значка *«Use Smart Snap»*(Использовать умную привязку), чтобы идеально выровнять его) или ввести значение непосредственно в **Inspector** (Инспектор).

![Use Smart Snap](/img/infinity-fly/use_smart_snap.jpg)

Крылья также нужно закрыть, поэтому добавьте второй узел **CollisionShape3D**. На этот раз используйте **BoxShape3D**. Разместите его так, чтобы он закрывал крылья:

![Use Smart Snap](/img/infinity-fly/6.5.jpg)

Рисунок 6.5: Airplane collision shapes

# Скриптирование самолета (Scripting the plane)

Вы можете начать с управления самолетом. Есть две оси движения: «pitch up» (вверх) и «pitch down» ( вниз) будут поднимать или опускать нос самолета (вращаясь вокруг его оси x), заставляя его двигаться вверх или вниз. Функции `roll_left` (влево) и `roll_right` (вправо) будут вращать самолет вокруг его оси z, заставляя его двигаться влево или вправо.

Для любого ввода вам потребуется плавное вращение, и когда игрок отпускает кнопку или возвращает стик в центр, самолет должен плавно вращаться обратно в исходное положение. Вы можете добиться этого путем интерполяции вращения, а не его прямой установки при вращении.

**Линейная интерполяция**, обычно сокращаемо обозначаемая как **lerp**, является термином, который вы часто будете встречать при разработке игр. Это означает вычисление промежуточного значения между двумя заданными значениями с использованием функции прямой линии. На практике его можно использовать для плавного изменения значения с одного на другое с течением времени.

Для начала прикрепите скрипт к узлу Plane и определите некоторые переменные:

```gdscript
extends CharacterBody3D
@export var pitch_speed = 1.1
@export var roll_speed = 2.5
@export var level_speed = 4.0
var roll_input = 0
var pitch_input  = 0
```
Экспортируемые переменные позволяют вам устанавливать скорость вращения самолета в любом направлении, а также скорость его автоматического возврата к горизонтальному полету.

В своей функции `get_input()` вы будете проверять значения входов из **Input Map**, чтобы определить, в какую сторону вращать:

```gdscript
func get_input(delta):
    pitch_input = Input.get_axis("pitch_down", "pitch_up")
    roll_input = Input.get_axis("roll_left", "roll_right")
```
Функция `Input.get_axis()` возвращает значение от -1 до 1, основанное на двух входах. При использовании клавиш, которые могут быть только нажаты или не нажаты, это означает, что вы получите только -1, когда нажата одна клавиша, 1 для другой и 0, когда не нажата ни одна или обе. Однако при использовании аналогового входа, такого как ось джойстика, вы можете получить полный диапазон значений. Это позволяет более точно управлять, так как легкое отклонение джойстика вправо дает небольшое значение `roll_input`, например, 0,25.

В функции `_physics_process()` вы затем можете вращать самолет вокруг его оси x на основе ввода танга:
```gdscript
func _physics_process(delta):
    get_input(delta)
    rotation.x = lerpf(rotation.x, pitch_input, pitch_speed * delta)
    rotation.x = clamp(rotation.x, deg_to_rad(-45), deg_to_rad(45))
```
Также важно использовать `clamp()` для ограничения вращения, чтобы самолет не перевернулся полностью вверх дном.

Вы можете проверить это, создав новую тестовую сцену и добавив туда самолет и **Camera3D**, например, так:

![Тестовая сцена](/img/infinity-fly/6.6.jpg)

Разместите камеру позади самолета и запустите сцену, чтобы проверить, правильно ли нажатие кнопок pitch up (танга вверх) и pitch down (танга вниз) наклоняет самолет вверх и вниз.

Для крена вы также можете вращать корпус по оси z, но тогда два вращения будут складываться, и вам будет очень сложно вернуть самолет в горизонтальное положение. Поскольку в этой игре вы хотите, чтобы самолет продолжал двигаться вперед, будет проще вращать дочерний объект mesh. Добавьте следующую строку в `_physics_process()`:

```gdscript
$cartoon_plane.rotation.z = lerpf($cartoon_plane.rotation.z, roll_input, roll_speed * 
```
Проверьте это снова в вашей тестовой сцене и убедитесь, что все элементы управления работают должным образом.

Чтобы завершить движение, добавьте еще две переменные в начало скрипта. Скорость полета вашего самолета будет `forward_speed`. Позже вы сможете ее изменить, чтобы усложнить игру. Вы можете использовать `max_altitude`, чтобы самолет не вылетел за пределы экрана: 

```gdscript
@export var forward_speed = 25
var max_altitude = 20
```

В `get_input()`, после проверки управления,  добавьте этот фрагмент, чтобы самолет выравнивался, если он достигнет максимальной высоты:

```gdscript
if position.y >= max_altitude and pitch_input > 0:
    position.y = max_altitude
    pitch_input = 0
```
Тогда добавьте этот фрагмент в `_physics_process()` для обработки движения. Линейная скорость вперед будет равна значению `forward_speed`:

```gdscript
velocity = -transform.basis.z * forward_speed
```

Для движения из стороны в сторону (по оси x) вы можете умножить на величину вращения, чтобы сделать его быстрее или медленнее в зависимости от того, насколько самолет накренился. Затем масштабируйте скорость на основе `forward_speed` (делим на два, чтобы сделать ее немного медленнее - поэкспериментируйте здесь, чтобы изменить ощущения):

```gdscript
velocity += transform.basis.x * $cartoon_plane.rotation.z / deg_to_rad(45) * forward_move_and_slide()
```

Ваш самолет теперь должен летать вперед, а элементы управления должны работать должным образом. Не переходите к следующему шагу, пока не убедитесь, что самолет ведет себя правильно. В следующем разделе вы создадите окружение, в котором будет летать самолет.