
# Сохранение рекорда
Сохранение рекорда игрока - еще одна распространенная функция во многих играх (ее можно добавить и в другие игры из этой книги). Поскольку счет необходимо сохранять между сессиями игры, вам нужно будет сохранить его во внешнем файле, который игра сможет прочитать при следующем открытии.


Вот процесс:

1. При запуске игры проверьте наличие файла сохранения.
2. Если файл сохранения существует, загрузите из него счет, иначе используйте 0.
3. Когда игра заканчивается, проверьте, превышает ли счет текущий рекорд. Если да, сохраните его в файл.
4. Покажите рекорд на титульном экране.

Так как вам потребуется доступ к переменной с рекордом из разных частей игры, имеет смысл использовать автозагрузку. В редакторе скриптов нажмите Файл -> Новый скрипт и назовите его global.gd. Для начала вам понадобятся две переменные:


```gdscript

extends Node
var high_score = 0
var score_file = "user://hs.dat"

```

## О расположении файлов

Обратите внимание, что путь к файлу сохранения не начинается с res://, как у всех остальных файлов, с которыми вы работали. Обозначение res:// указывает на папку проекта вашей игры - место, где находятся все скрипты, сцены и ресурсы. Однако, когда вы экспортируете игру, эта папка становится доступной только для чтения.

Для хранения постоянных данных используется место на устройстве, выделенное для записи игрой: user://. Фактическое расположение этой папки зависит от используемой операционной системы. Например, в Windows это будет %APPDATA%\Godot\app_userdata\[project_name]. Пути для других поддерживаемых операционных систем можно найти здесь: (https://docs.godotengine.org/en/stable/tutorials/io/data_paths.html
)![ссылка на документацию по Godot - расположение user://] (документация Godot по расположению user://).


Доступ к файлам в Godot осуществляется через объект FileAccess. Этот объект отвечает за открытие, чтение и запись файлов. Добавьте эти функции в global.gd:

```
func _ready():
    load_score()

func load_score():
    if FileAccess.file_exists(score_file):
        var file = FileAccess.open(score_file, FileAccess.READ)
        high_score = file.get_var()
    else:
        high_score = 0

func save_score():
    var file = FileAccess.open(score_file, FileAccess.WRITE)
    file.store_var(high_score)
```

Как видите, скрипт вызывает load_score() в _ready(), поэтому это происходит сразу после запуска игры. Функция load_score() использует FileAccess для проверки существования файла сохранения. Если он существует, функция открывает его и извлекает данные, которые были сохранены с помощью get_var().

Функция save_score() делает обратное. Обратите внимание, что вам не нужно проверять, существует ли файл - если вы попытаетесь записать в несуществующий файл, он будет создан.

Сохраните этот скрипт и добавьте его как автозагрузку в **Project Settings**.


![ Добавление глобального скрипта](/img/infinity-fly/6.17.jpg)
## Рисунок 6.17: Добавление глобального скрипта

Перейдите на сцену Title и добавьте еще один Label для отображения рекорда. Установите шрифт и расположите его на экране -  хорошим выбором может быть нижняя середина. Добавьте этот код в скрипт, чтобы счет отображался при каждой загрузке титульного экрана:

```
func _ready():
  $Label2.text = "High Score: " + str(Global.high_score)
```

Наконец, в конце игры вам нужно проверить, установлен ли новый рекорд. Переменная score хранится в сцене plane, поэтому откройте plane.gd и найдите функцию die(), которая вызывается при завершении игры. Добавьте проверку счета и вызовите save_score() при необходимости:

```
if score > Global.high_score:
  Global.high_score = score
  Global.save_score()
```

Запустите игру, чтобы проверить, отображается ли рекорд, сохраняется ли он и загружается ли снова при следующем запуске игры.

Этот метод можно использовать для любого типа данных, которые вы хотите сохранить между запусками игры. Это полезная техника для создания запоминающихся игр.

анный способ можно использовать для любых данных, которые вы хотите сохранить между запусками игры. Это полезный прием для создания запоминающихся игр. Повторное использование кода - отличный способ ускорить разработку, поэтому, как только у вас появится система сохранения, которая вас устраивает, придерживайтесь ее!