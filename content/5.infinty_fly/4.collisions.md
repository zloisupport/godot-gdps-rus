# Столкновения (Collisions)

Следующий шаг - заставить самолет взрываться, если он наткнется на что-нибудь, например, на землю [ground] или здания. Если это произойдет, вы воспроизведете анимацию взрыва, и это будет конец игры.

# Взрыв [Explosion]

Перейдите в сцену **Plane** и добавьте дочерний элемент **AnimatedSprite3D**. Назовите его Explosion.

Узел **AnimatedSprite3D** работает очень похоже на 2D-версию, которую вы использовали ранее в книге. Добавьте новый ресурс SpriteFrames в свойстве Frames и нажмите на него, чтобы открыть панель SpriteFrames в нижней части экрана. Перетащите пять изображений из res://assets/smoke/ в поле Animation Frames, установите Speed на 10 FPS и отключите Loop.

![ Спрайты взрыва](/img/infinity-fly/6.13.jpg)
Рисунок 6.13: Спрайты взрыва

Вы могли заметить, что не видите спрайт во вьюпорте [viewport]. При отображении 2D-изображения, которое рисуется пикселями, в 3D движке нужно знать, насколько велик пиксель в 3D-пространстве. Чтобы размер взрыва соответствовал размеру самолета, установите Pixel Size на 0.5 в инспекторе [Inspector]. В разделе Flags установите флажок Billboard. Это гарантирует, что спрайт всегда будет обращен к камере. Теперь вы должны увидеть большое облако (первый кадр анимации), наложенное на ваш самолет.

![ Спрайт взрыва](/img/infinity-fly/6.14.jpg)
Рисунок 6.14: Спрайт взрыва

Вы не хотите видеть взрыв, поэтому нажмите на значок глаза, чтобы скрыть Explosion.

## Скриптинг столкновений [Scripting the collisions]

Добавьте новый сигнал в верхней части plane.gd, который уведомит игру о том, что игрок разбился:

```gdscript
signal dead
```

В _physics_process() вы используете move_and_slide() для перемещения самолета. Всякий раз, когда узел CharacterBody3D перемещается с помощью этого метода, он может проверять столкновения скольжения. Поскольку неважно, с чем столкнулся самолет, а только то, что произошло столкновение, добавьте это сразу после move_and_slide():

```gdscript
if get_slide_collision_count() > 0:
    die()
```

Затем вы можете определить функцию die(), чтобы обработать то, что должно произойти при падении самолета. Во-первых, он перестанет двигаться вперед. Затем вы можете спрятать самолет и показать взрыв, воспроизводя анимацию. После того, как анимация закончится, вы можете перезапустить игру. Поскольку вы еще не создали экран заставки, вы можете просто перезагрузиться сейчас:

```gdscript
func die():
    set_physics_process(false)
    $cartoon_plane.hide()
    $Explosion.show()
    $Explosion.play("default")
    await $Explosion.animation_finished
    $Explosion.hide()
    dead.emit()
    get_tree().reload_current_scene()
```

Вы удалите эту последнюю строку позже, когда будет настроена оставшаяся часть игры.

Запустите сейчас сцену Main и попробуйте во что-нибудь врезаться, чтобы убедиться, что взрыв проигрывается, а сцена перезапускается.

# Топливо и счет [Fuel and score]

Следующий шаг - отслеживать очки, заработанные при сборе колец. Вы также добавите компонент топлива к самолету. Это значение будет постоянно уменьшаться, и игра закончится, если топливо закончится. Игрок получает топливо обратно, собирая кольца.

Добавьте два новых сигнала в верхней части plane.gd:

```gdscript
signal score_changed
signal fuel_changed
```

Они уведомят интерфейс [UI] о необходимости отображения значений очков и топлива.

Затем добавьте эти новые переменные:
```gdscript
@export var fuel_burn = 1.0 var max_fuel = 10.0
var fuel = 10.0:
    set = set_fuel
var score = 0:
    set = set_score
```

Функции-сеттеры [setter functions] для этих переменных будут обновлять их значения и посылать сигналы [emit signals].

```gdscript
func set_fuel(value):
    fuel = min(value, max_fuel)
    fuel_changed.emit(fuel)
    if fuel <= 0:
        die()
func set_score(value):
    score = value
    score_changed.emit(score)

```
Чтобы со временем уменьшить количество топлива, добавьте эту строку в `_physics_process()`:

```gdscript
fuel -= fuel_burn * delta
```

Попробуйте сыграть в главную сцену, и вы увидите, что у вас закончится топливо, и вы взорветесь примерно через 10 секунд.

Теперь вы можете сделать так, чтобы кольца обновляли счет и возвращали немного топлива в зависимости от того, насколько близко игрок находился к центру кольца. Вы уже устанавливаете метку кольца, и вы можете сделать все остальное в том же разделе ring.gd:

```gdscript
if d < 2.0:
    $Label3D.text = "200"
    $Label3D.modulate = Color(1, 1, 0)
    body.fuel = 10
    body.score += 200
elif d > 3.5:
    $Label3D.text = "50"
    body.fuel += 1
    body.score += 50
else:
    $Label3D.text = "100"
    body.fuel += 2.5
    body.score += 100
```

Если вы снова протестируете игру, вы сможете летать дольше, если будете собирать кольца. Однако сложно сказать, сколько топлива у вас осталось, поэтому вам следует добавить оверлей [overlay] пользовательского интерфейса [UI], который будет отображать топливо и счет.

## UI

Создайте новую сцену с слоем CanvasLayer под названием «UI». Добавьте два дочерних элемента: TextureProgressBar (FuelBar) и Label (Score).

Установите текст в поле Score в свойстве Text на 0 и добавьте шрифт, как вы делали ранее, установив его размер [Size] на 48. Используйте меню панели инструментов, чтобы установить расположение в правом верхнем углу [Top Right].

Для FuelBar у вас есть две текстуры в папке assets. Вы можете использовать bar_red.png для текстуры Progress и bar_glass.png для текстуры Over. В разделе Range установите Max Value на 10, а Step на 0.01.

Вы можете расположить полосу в левом нижнем углу, но если вы хотите ее изменить размер, вам нужно будет изменить еще несколько настроек. Установите флажок с надписью Nine Patch Stretch в инспекторе [Inspector]. Затем вы можете изменить размер полосы, перетаскивая ее ограничивающий бокс. Однако вы заметите, что контур сильно искажается - увеличьте его масштаб, чтобы увидеть эффект. Девятипатчевое растяжение как раз и помогает этого избежать, сохраняя границы неразмеренными при растяжении внутренней части. В разделе Stretch Margin установите все четыре значения на 6. Вы увидите, что теперь, независимо от того, как вы изменяете размер полосы, границы остаются нерастянутыми:


![ Настройки Nine Patch Stretch](/img/infinity-fly/6.15.jpg)

Рисунок 6.15: Настройки Nine Patch Stretch

Сделайте полосу удобного размера, а затем добавьте скрипт к UI:

```
extends CanvasLayer

func update_fuel(value):
  $FuelBar.value = value

func update_score(value):
  $Score.text = str(value)
```

Добавьте экземпляр сцены UI в Main. Подключите сигнал score_changed самолета и сигнал fuel_changed к функциям, которые вы только что создали в UI:

![Подключение сигнала самолета к UI](/img/infinity-fly/6.16.jpg)
Рисунок 6.16: Подключение сигнала самолета к UI

Запустите сцену еще раз и убедитесь, что полоса показывает изменение топлива, а счет обновляется правильно при сборе колец.

Вы почти закончили! На данный момент у вас есть в основном работающая игра. Потратьте немного времени, чтобы сыграть в нее несколько раз, чтобы убедиться, что вы не пропустили никаких взаимодействий. Увеличивается ли сложность чанков по мере того, как вы летите дальше? Вы должны увидеть движущиеся кольца, а затем кольца, которые появляются слева и справа от центра. Обязательно просмотрите предыдущие разделы, если вам что-то непонятно. Когда будете готовы, переходите к созданию стартового экрана.



# Заставка [Title screen]

Заставка служит для представления игры и дает возможность начать ее, нажав кнопку. В этом разделе не будет подробно рассматриваться стилистика - вы должны экспериментировать с настройками и попытаться сделать ее привлекательной.

Начните сцену TitleScreen с узла Control и добавьте Label, TextureButton, а также TextureRect для фона.

Для свойства Texture узла TextureRect вы можете использовать styled_sky.hdr. Он намного больше размера экрана, поэтому вы можете масштабировать и / или размещать его по своему вкусу.

Для TextureButton в папке res://assets/buttons/ есть три изображения для текстур Normal, Pressed и Hover. Изображения довольно большие, чтобы их можно было масштабировать, поэтому вы можете установить флажок Ignore Texture Size и установить Stretch Mode на Keep Aspect, чтобы можно было изменить его размер.

Узел Label предназначен для отображения названия игры. Настройте шрифт с большим размером, например 128. Разместите Label и TextureButton на экране. Установите их макет [layout] на Center, а затем переместите их вверх и вниз, чтобы расположить.

Единственный необходимый код - это определить, что делать при нажатии кнопки, поэтому добавьте скрипт к сцене и подключите сигнал pressed кнопки. При нажатии кнопки она должна загрузить главную сцену:

```gdscript
extends Control
func _on_texture_button_pressed():
    get_tree().change_scene_to_file("res://main.tscn")
```

Чтобы вернуться на титульный экран в конце игры, удалите `get_tree().reload_current_scene()` из функции `die()` самолета, а затем перейдите на сцену Main и подключите сигнал dead экземпляра самолета:

```
var title_screen = "res://title_screen.tscn"

func _on_plane_dead():
  get_tree().change_scene_to_file(title_screen)
```

# Aудио

Теперь, когда вы разобьётесь, вы должны сразу вернуться на титульный экран, где сможете снова нажать «Играть».

В папке assets находятся два звуковых файла: impact.wav для взрыва самолета и three_tone.wav для звука сбора кольца.  Вы можете добавить узлы AudioStreamPlayer к сценам Plane и Ring для их воспроизведения в нужный момент.

Для фоновой музыки, которая должна воспроизводиться циклически во время игры, добавьте AudioStreamPlayer в сцену Main, используя Riverside_Ride_Short_Loop.wav для Stream. Поскольку он должен автоматически воспроизводиться при запуске, вы можете установить флажок Autoplay.

Звуковое оформление этой игры намеренно простое и оптимистичное. Хотя есть звуковой эффект для каждого major игрового события (пролет сквозь кольцо, столкновение), вы также можете попробовать добавить дополнительные звуки для работы двигателя самолета, бонусов или предупреждение, когда уровень топлива низкий. Экспериментируйте, чтобы увидеть, что работает для вас.
