# Создание мира

Поскольку это игра в бесконечном стиле, игрок будет продолжать летать по миру как можно дольше. Это означает, что вам нужно постоянно создавать новые части мира, чтобы он их видел - случайные здания, предметы для сбора и так далее. Было бы непрактично создавать все это заранее, как потому, что вы не знаете, как далеко зайдет игрок, так и потому, что вы не хотите, чтобы игра была одинаковой каждый раз, когда вы играете. Также было бы неэффективно загружать огромный игровой мир, если игрок не увидит большую его часть.

По этой причине более разумно использовать стратегию разделения на фрагменты (chunking strategy). Вы будете случайным образом генерировать мир меньшими частями или фрагментами. Затем вы можете создавать их по мере необходимости - по мере того, как игрок движется вперед. Вы также можете удалить их, как только они будут пройдены, когда игре больше не нужно их отслеживать.

## Объекты мира (World objects)

Каждый раз, когда вы генерируете новый фрагмент мира, он будет содержать ряд различных объектов мира. Вы можете начать с двух: зданий, которые будут препятствиями, и колец, которые игрок пытается собрать, пролетая через них.

### Здания (Buildings)

Для первого здания начните новую сцену с узлом `StaticBody3D` и назовите ее **Building1**. Добавьте узел MeshInstance3D и перетащите `res://assets/building_meshes/Build_01.obj` в свойство **Mesh**. Сетка здания хранится в формате OBJ, а не в файле .glTF. Существует также отдельный файл .mtl, который содержит материал сетки - Godot скрывает его в панели **FileSystem**, но он будет использоваться для текстуры в экземпляре сетки.

Вы заметите, что здание центрировано по центру. Поскольку ваши здания будут разных размеров, это затруднит их размещение на земле - у всех них будут разные смещения. Если все ваши здания будут последовательно смещены заранее, их можно будет легче разместить.

Чтобы расположить сетку здания, измените свойство **Position** узла **MeshInstance3D** на (0, 6, -8), что перемещает его вверх и размещает его край по центру. Добавьте форму коллизии, выбрав сетку и выбрав Mesh -> Create Trimesh Collision Sibling (Создать сопутствующий объект коллизии Trimesh).

Сохраните сцену в новой папке под названием `res://buildings/` и повторите процесс с другими зданиями, начиная каждую сцену с узла **StaticBody3D**, добавляя сетку, смещая ее, а затем создавая форму коллизии. Поскольку каждое здание имеет разный размер, вот смещения, которые идеально их расположат:

| Здание (Building) | Смещение (Offset) |
|-------------------|-------------------|
| 1                 | (0, 6, -8)        |
| 2                 | (0, 8, -4)        |
| 3                 | (0, 10, -6)       |
| 4                 | (0, 10, -6)       |
| 5                 | (0, 11, -4)       |


Часть (chunk) теперь может загружать и случайно размещать эти здания, создавая разнообразный городской пейзаж.

Rings(Кольца)
Кольца будут появляться перед игроком, и самолет должен пролетать через них, чтобы набрать очки. Если самолет окажется очень близко к центру кольца, игрок получит бонусные очки. По мере прохождения игры кольца могут стать более сложными для прохождения - менять размер, двигаться вперед-назад и так далее.

Прежде чем начать, и не заглядывая вперед, подумайте, какой тип узла (node) лучше всего подходит для объекта кольца.

Вы выбрали Area3D? Поскольку вы хотите определить, когда самолет пролетает через кольцо, но не сталкивается с ним, обнаружение body_entered области будет идеальным решением.



Начните новую сцену кольца с узлом Area3D и добавьте дочерний узел MeshInstance3D. 
Для **Mesh** выберите **TorusMesh**, а в свойствах меша установите **Inner Radius** на 3.5 и **Outer Radius** на 4, чтобы получить узкое кольцо.

Добавьте узел CollisionShape3D и выберите **New CylinderShape3D** для его **Shape**. В этот раз установите значение свойства **Height** на 0.5, а **Radius** на 3.
Позже вы захотите анимировать движение кольца вверх и вниз. Простой способ сделать это - переместить форму столкновения относительно позиции корневого узла. 

Так как вы хотите, чтобы меш также двигался, перетащите его, чтобы сделать его дочерним объектом CollisionShape3D. Поверните форму столкновения на 90 градусов вокруг x, чтобы поставить ее вертикально.

Простое белое кольцо не очень интересно, поэтому вы можете добавить текстуру. В свойстве **Mesh** узла MeshInstance3D добавьте **New StandardMaterial3D** и разверните его. В разделе **Albedo/Texture** добавьте **res://assets/textures/ texture_09.png**. Вы заметите, что текстура, представляющая собой сетку из чередующихся светлых и темных квадратов, сильно растянута вокруг тора. Вы можете настроить то, как текстура обернута вокруг меша, изменив значения **UV1/Scale**. Попробуйте (12, 1, 1) в качестве начального значения и отрегулируйте его по своему вкусу. В разделе **Shading** установите **Shading Mode** на **Unshaded** - это гарантирует, что кольцо будет игнорировать освещение и тени, оставаясь ярким и видимым в любое время.

Далее добавьте узел Label3D к узлу Ring. Вы будете использовать его, чтобы показать игроку, сколько очков он набрал за кольцо и получил ли он бонус за центр. Установите поле **Text/Text** на 100, чтобы увидеть что-то для тестирования. В разделе **Text/Font** добавьте **Baloo2-Medium.ttf** из папки ресурсов и установите размер шрифта на 720. Чтобы текст всегда смотрел на камеру, установите **Flags/Billboard** в значение **Enabled**.

Добавьте скрипт к кольцу и подключите сигнал **body_entered**. Сначала функция Label3D должна быть скрыта, а кольцо будет скрыто, когда к нему прикоснется самолет. Однако есть проблема: что, если кольцо появляется и перекрывает здание? Сигнал **body_entered** все равно будет срабатывать, но вы ведь не хотите, чтобы здание собирало кольцо! 

Вы можете решить эту проблему с помощью слоев столкновений.  На сцене с самолетом (Plane) измените значение Collision/Layer на 2 (убрав 1), затем вернитесь к узлу Ring и установите для параметра Collision/Mask значение только для слоя 2. Теперь вы можете быть уверены, что если кольцо обнаруживает входящее тело, это может быть только самолет.

```gdscript
extends Area3D
func _ready():
    $Label3D.hide()
```

После этого вам нужно найти расстояние от самолета до центра кольца, чтобы определить, заработал ли игрок бонус, и установить для свойства текста правильное значение. Если самолет попадает прямо в центр кольца (ближе 2.0 единиц), вы также можете окрасить текст в желтый цвет, чтобы показать идеальное попадание.


```gdscript
func _on_body_entered(body):
    $CollisionShape3D/MeshInstance3D.hide()
    var d = global_position.distance_to(body.global_position) 
    if d < 2.0:
        $Label3D.text = "200"
        $Label3D.modulate = Color(1, 1, 0)
    elif d > 3.5:
        $Label3D.text = "50"
    else:
            $Label3D.text = "100"
            $Label3D.show()
```

Продолжая функцию `_on_body_entered()`, добавим немного анимации к метке, чтобы она двигалась и исчезала:  

```gdscript
var tween = create_tween().set_parallel()
tween.tween_property($Label3D, "position",Vector3(0, 10, 0), 1.0)
tween.tween_property($Label3D, "modulate:a", 0.0, 0.5)
```

Наконец, добавьте кольцу приятный эффект вращения:

```gdscript
func _process(delta):
    $CollisionShape3D/MeshInstance3D.rotate_y(deg_to_rad(50) * delta)
```


Chunks

Теперь, когда у вас есть строительные блоки для чанка, вы можете создать  **сами сцены чанков [chunk scene]**. Это сцена, которую игра будет создавать всякий раз, когда впереди игрока потребуется больше мира. Когда вы создаете новый чанк, он будет случайным образом размещать здания вдоль левой и правой сторон, а также порождать кольца в случайных точках по всей его длине.

Начните сцену чанка с узла **Node3D** и дочернего элемента **MeshInstance3D** с именем Ground. Установите для свойства **Mesh** значение **PlaneMesh** и установите для параметра Size значение (50, 200). Это размер одного чанка.


![Параметры размера плоскости](/img/infinity-fly/6.7.jpg)

Рисунок 6.7: Параметры размера плоскости
Поместите его так, чтобы он начинался в начале координат, установив его положение Z в -100:

![Позиционирование плоскости](/img/infinity-fly/6.8.jpg)
Рисунок 6.8: Позиционирование плоскости

Добавьте материал и используйте texture_01.png в качестве **Albedo/Texture** и установите значения UV1/Scale на (2, 10, 2). По умолчанию Godot связывает три значения масштаба, чтобы они оставались одинаковыми, поэтому вам нужно снять флажок кнопки ссылки, чтобы разрешить им быть разными:

![Регулировка масштаба UV](/img/infinity-fly/6.9.jpg)

Рисунок 6.9: Регулировка масштаба UV

Выберите узел Ground и выберите **Mesh -> Create Trimesh Static Body**, чтобы добавить узел **StaticBody3D** и узел **CollisionShape3D**, соответствующий размеру земли [Ground].

По мере того, как плоскость движется к концу чанка [chunk], вы будете создавать новый чанк впереди, а также можете удалять старые чанки, как только они пройдут. Чтобы помочь с последним, добавьте узел VisibleOnScreenNotifier3D и установите его свойство Position на (0, 0, -250), которое помещает его за конец наземной плоскости [ground plane].

Теперь вы можете добавить скрипт к узлу **Chunk** и подключить сигнал notifier's screen_exited, чтобы удалить чанк.

```gdscript
func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()
```
В верхней части скрипта загрузите сцены, которые необходимо создать экземпляры:

```gdscript
extends Node3D
var buildings = [
    preload("res://buildings/building_1.tscn"),
    preload("res://buildings/building_2.tscn"),
    preload("res://buildings/building_3.tscn"),
    preload("res://buildings/building_4.tscn"),
    preload("res://buildings/building_5.tscn"),
]
var ring = preload("res://ring.tscn")
var level = 0
```

## Загрузка множества сцен

В более крупной игре, где у вас есть гораздо больше зданий и, возможно, других сцен, вы не захотите прописывать их все по отдельности в скрипте, как вы сделали здесь. Другим решением будет написать здесь код, который загружает каждый файл сцены, сохраненный в определенной папке.

Переменная **level** может быть установлена главной сценой при загрузке чанка, чтобы можно было увеличивать сложность, порождая кольца с разным поведением (подробнее об этом позже).

В функции `_ready()` чанк должен выполнять три вещи:

- Разместить здания по бокам наземной плоскости [ground plane]
- Иногда появляются здания посередине, чтобы служить препятствиями
- Spawn кольца [spawn rings]

Каждый из этих шагов будет включать код, поэтому для лучшей организации вы можете создать три отдельные функции:

```gdscript
func _ready():
    add_buildings()
    add_center_buildings()
    add_rings()
```

Первый шаг - разместить боковые здания. Поскольку они должны располагаться по обе стороны чанка [chunk], вы повторяете цикл дважды - один раз для положительного направления X и один раз для отрицательного направления. Каждый раз вы будете перемещаться вдоль длины чанка, спавня случайные здания:

```gdscript
func add_buildings():
    for side in [-1, 1]:
        var zpos = -10
        for i in 18:
            if randf() > 0.75:
                zpos -= randi_range(5, 10)
                continue
            var nb = buildings[randi_range(0,buildings.size()-1)].instantiate()
            add_child(nb)
            nb.transform.origin.z = zpos
            nb.transform.origin.x = 20 * side
            zpos -= nb.get_node("MeshInstance3D").mesh.get_aabb().size.z
```

Функция `randf()` - это распространенная функция для получения случайного числа, которая возвращает число с плавающей точкой между 0 и 1, что упрощает расчет процентов. Проверьте, больше ли случайное число 0.75, чтобы иметь 25% шанс того, что в определенном месте не будет здания.

Получив размер меша здания с помощью `get_aabb()`, вы можете гарантировать, что здания не будут перекрывать друг друга. Позиция следующего здания будет точно на краю предыдущего.

Далее,  размещение зданий посередине [spawning middle buildings]  не будет происходить в начале, но позже в игре они начнут появляться с вероятностью 20%:

```gdscript
func add_center_buildings():
    if level > 0:
        for z in range(0, -200, -20):
            if randf() > 0.8:
                var nb = buildings[0].instantiate()
                add_child(nb)
                nb.position.z = z
                nb.position.x += 8
                nb.rotation.y = PI / 2
```
Третий шаг - это  появление колец [spawning rings]. Сейчас он просто размещает несколько колец в случайных фиксированных положениях. Позже, по мере развития игры, вы добавите здесь еще кое-какие вариации:

```gdscript
func add_rings():
    for z in range(0, -200, -10):
        if randf() > 0.76:
            var nr = ring.instantiate()
            nr.position.z = z
            nr.position.y = randf_range(3, 17)
            add_child(nr)
```

Вы закончили настройку чанка. Когда он загружается, он заботится о том, чтобы заполнить себя случайным набором зданий и колец, а также удаляет себя, когда позже выходит за пределы экрана. В следующем разделе вы объедините все это в сцене, которая создает экземпляры чанков по мере того, как плоскость движется вперед.
