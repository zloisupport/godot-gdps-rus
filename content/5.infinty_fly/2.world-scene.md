# Создание мира

Поскольку это игра в бесконечном стиле, игрок будет продолжать летать по миру как можно дольше. Это означает, что вам нужно постоянно создавать новые части мира, чтобы он их видел - случайные здания, предметы для сбора и так далее. Было бы непрактично создавать все это заранее, как потому, что вы не знаете, как далеко зайдет игрок, так и потому, что вы не хотите, чтобы игра была одинаковой каждый раз, когда вы играете. Также было бы неэффективно загружать огромный игровой мир, если игрок не увидит большую его часть.

По этой причине более разумно использовать стратегию разделения на фрагменты (chunking strategy). Вы будете случайным образом генерировать мир меньшими частями или фрагментами. Затем вы можете создавать их по мере необходимости - по мере того, как игрок движется вперед. Вы также можете удалить их, как только они будут пройдены, когда игре больше не нужно их отслеживать.

## Объекты мира (World objects)

Каждый раз, когда вы генерируете новый фрагмент мира, он будет содержать ряд различных объектов мира. Вы можете начать с двух: зданий, которые будут препятствиями, и колец, которые игрок пытается собрать, пролетая через них.

### Здания (Buildings)

Для первого здания начните новую сцену с узлом `StaticBody3D` и назовите ее **Building1**. Добавьте узел MeshInstance3D и перетащите `res://assets/building_meshes/Build_01.obj` в свойство **Mesh**. Сетка здания хранится в формате OBJ, а не в файле .glTF. Существует также отдельный файл .mtl, который содержит материал сетки - Godot скрывает его в панели **FileSystem**, но он будет использоваться для текстуры в экземпляре сетки.

Вы заметите, что здание центрировано по центру. Поскольку ваши здания будут разных размеров, это затруднит их размещение на земле - у всех них будут разные смещения. Если все ваши здания будут последовательно смещены заранее, их можно будет легче разместить.

Чтобы расположить сетку здания, измените свойство **Position** узла **MeshInstance3D** на (0, 6, -8), что перемещает его вверх и размещает его край по центру. Добавьте форму коллизии, выбрав сетку и выбрав Mesh -> Create Trimesh Collision Sibling (Создать сопутствующий объект коллизии Trimesh).

Сохраните сцену в новой папке под названием `res://buildings/` и повторите процесс с другими зданиями, начиная каждую сцену с узла **StaticBody3D**, добавляя сетку, смещая ее, а затем создавая форму коллизии. Поскольку каждое здание имеет разный размер, вот смещения, которые идеально их расположат:

| Здание (Building) | Смещение (Offset) |
|-------------------|-------------------|
| 1                 | (0, 6, -8)        |
| 2                 | (0, 8, -4)        |
| 3                 | (0, 10, -6)       |
| 4                 | (0, 10, -6)       |
| 5                 | (0, 11, -4)       |


Часть (chunk) теперь может загружать и случайно размещать эти здания, создавая разнообразный городской пейзаж.

Rings(Кольца)
Кольца будут появляться перед игроком, и самолет должен пролетать через них, чтобы набрать очки. Если самолет окажется очень близко к центру кольца, игрок получит бонусные очки. По мере прохождения игры кольца могут стать более сложными для прохождения - менять размер, двигаться вперед-назад и так далее.

Прежде чем начать, и не заглядывая вперед, подумайте, какой тип узла (node) лучше всего подходит для объекта кольца.

Вы выбрали Area3D? Поскольку вы хотите определить, когда самолет пролетает через кольцо, но не сталкивается с ним, обнаружение body_entered области будет идеальным решением.



Начните новую сцену кольца с узлом Area3D и добавьте дочерний узел MeshInstance3D. 
Для **Mesh** выберите **TorusMesh**, а в свойствах меша установите **Inner Radius** на 3.5 и **Outer Radius** на 4, чтобы получить узкое кольцо.

Добавьте узел CollisionShape3D и выберите **New CylinderShape3D** для его **Shape**. В этот раз установите значение свойства **Height** на 0.5, а **Radius** на 3.
Позже вы захотите анимировать движение кольца вверх и вниз. Простой способ сделать это - переместить форму столкновения относительно позиции корневого узла. 

Так как вы хотите, чтобы меш также двигался, перетащите его, чтобы сделать его дочерним объектом CollisionShape3D. Поверните форму столкновения на 90 градусов вокруг x, чтобы поставить ее вертикально.

Простое белое кольцо не очень интересно, поэтому вы можете добавить текстуру. В свойстве **Mesh** узла MeshInstance3D добавьте **New StandardMaterial3D** и разверните его. В разделе **Albedo/Texture** добавьте **res://assets/textures/ texture_09.png**. Вы заметите, что текстура, представляющая собой сетку из чередующихся светлых и темных квадратов, сильно растянута вокруг тора. Вы можете настроить то, как текстура обернута вокруг меша, изменив значения **UV1/Scale**. Попробуйте (12, 1, 1) в качестве начального значения и отрегулируйте его по своему вкусу. В разделе **Shading** установите **Shading Mode** на **Unshaded** - это гарантирует, что кольцо будет игнорировать освещение и тени, оставаясь ярким и видимым в любое время.

Далее добавьте узел Label3D к узлу Ring. Вы будете использовать его, чтобы показать игроку, сколько очков он набрал за кольцо и получил ли он бонус за центр. Установите поле **Text/Text** на 100, чтобы увидеть что-то для тестирования. В разделе **Text/Font** добавьте **Baloo2-Medium.ttf** из папки ресурсов и установите размер шрифта на 720. Чтобы текст всегда смотрел на камеру, установите **Flags/Billboard** в значение **Enabled**.

Добавьте скрипт к кольцу и подключите сигнал **body_entered**. Сначала функция Label3D должна быть скрыта, а кольцо будет скрыто, когда к нему прикоснется самолет. Однако есть проблема: что, если кольцо появляется и перекрывает здание? Сигнал **body_entered** все равно будет срабатывать, но вы ведь не хотите, чтобы здание собирало кольцо! 

Вы можете решить эту проблему с помощью слоев столкновений.  На сцене с самолетом (Plane) измените значение Collision/Layer на 2 (убрав 1), затем вернитесь к узлу Ring и установите для параметра Collision/Mask значение только для слоя 2. Теперь вы можете быть уверены, что если кольцо обнаруживает входящее тело, это может быть только самолет.

```gdscript
extends Area3D
func _ready():
    $Label3D.hide()
```

После этого вам нужно найти расстояние от самолета до центра кольца, чтобы определить, заработал ли игрок бонус, и установить для свойства текста правильное значение. Если самолет попадает прямо в центр кольца (ближе 2.0 единиц), вы также можете окрасить текст в желтый цвет, чтобы показать идеальное попадание.


```gdscript
func _on_body_entered(body):
    $CollisionShape3D/MeshInstance3D.hide()
    var d = global_position.distance_to(body.global_position) 
    if d < 2.0:
        $Label3D.text = "200"
        $Label3D.modulate = Color(1, 1, 0)
    elif d > 3.5:
        $Label3D.text = "50"
    else:
            $Label3D.text = "100"
            $Label3D.show()
```

Продолжая функцию `_on_body_entered()`, добавим немного анимации к метке, чтобы она двигалась и исчезала:  

```gdscript
var tween = create_tween().set_parallel()
tween.tween_property($Label3D, "position",Vector3(0, 10, 0), 1.0)
tween.tween_property($Label3D, "modulate:a", 0.0, 0.5)
```

Наконец, добавьте кольцу приятный эффект вращения:

```gdscript
func _process(delta):
    $CollisionShape3D/MeshInstance3D.rotate_y(deg_to_rad(50) * delta)
```